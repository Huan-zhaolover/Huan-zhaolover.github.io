<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[前端基础2]]></title>
    <url>%2F2018%2F12%2F01%2F%E9%9D%A2%E8%AF%95%2FFrontPrevew1%2F</url>
    <content type="text"><![CDATA[js 1.JS的typeof 会返回什么数据类型 -&gt; (object| number|function|boolen|undefind) 判断一个字符串中出现的次数最多的字符，统计这个次数 12345678910111213141516171819test1()&#123; var str = 'asdfssaaasasasasaa'; var json = &#123;&#125;; for (var i = 0; i &lt; str.length; i++) &#123; if(!json[str.charAt(i)])&#123; json[str.charAt(i)] = 1; &#125;else&#123; json[str.charAt(i)]++; &#125; &#125;; var iMax = 0; var iIndex = ''; for(var i in json)&#123; if(json[i]&gt;iMax)&#123; iMax = json[i]; iIndex = i; &#125; &#125; alert('出现次数最多的是:'+iIndex+'出现'+iMax+'次');&#125; 写一个获取非行间样式的函数 1234567891011getStyle(obj,attr,value) &#123; if(!value) &#123; if(obj.currentStyle) &#123; //ie return obj.currentStyle(attr); &#125;else&#123; //标准浏览器 obj.getComputedStyle(attr,false); &#125; &#125;else &#123; obj.style[attr] = value; &#125;&#125; 闭包是什么，有什么特性，对页面有什么影响 闭包是能读取其他函数内部变量的函数 会延长函数变量的声明周期 JSONP 的原理 为什么不是真正的Ajax jsonp 只是动态创建script标签，回调函数 Ajax 是页面无刷新请求数据操作 JS的本地对象，内置对象 宿主对象 本地对象可以new实例化的 array obj regexp 内置对象 不可以实例化 的，gload math 等 宿主对象 BOM对象 document window等 Window.location.search 返回什么？(返回问好后面的，?number1&amp;page=2&amp;id=2111) Window.location.hash返回的是什么？(#后面的锚点http://www.sina.com/getage?#age 中的#age) 阻止冒泡函数 兼容W3C 和IE 12345678stopPropagation(e) &#123; e = e || window.event; if(e.stopPropagation) &#123; //W3C阻止冒泡方法 e.stopPropagation(); &#125; else &#123; e.cancelBubble = true; //IE阻止冒泡方法 &#125; &#125; 对象和函数的log 12345678910111213unction f1()&#123; var tmp = 1; this.x = 3; console.log(tmp); //A console.log(this.x); //B&#125;var obj = new f1(); //1console.log(obj.x) //2console.log(f1()); //3 // 1 构造函数，内部的this 就是f1 ,log:1,3// 2 创建的实例：log:3// 3. 简单的一个函数：this是window，JS特性是向外层去找，所以log: 1 3 undefined 函数的作用域问题： 1234567891011121314function changeObjectProperty (o) &#123; o.siteUrl = "http://www.csser.com/"; o = new Object(); o.siteUrl = "http://www.popcg.com/";&#125;var CSSer = new Object();changeObjectProperty(CSSer);console.log(CSSer.siteUrl); ///*如果 CSSer 参数是按引用传递的，那么结果应该是 "http://www.popcg.com/"，但实际结果却仍是"http://www.csser.com/"。事实是这 样的:在函数内部修改了引用类型值的参数，该参数值的原始引用保持不变。我们可 以把参数想象成局部变量，当参数被重写时，这个变量引用的就是一个局部变量，局 部变量的生存期仅限于函数执行的过程中，函数执行完毕，局部变量即被销毁以释放 内存。(补充:内部环境可以通过作用域链访问所有的外部环境中的变量对象，但 外部环境无法访问内部环境。每个环境都可以向上搜索作用域链，以查询变量和函数 名，反之向下则不能。)*/ JS 加减运算 alert(&#39;5&#39;+3) 数字和字符串加 转换为字符串格式 alert(‘5’-3) 字符串和数字减 转换为Number类型 为什不能定义1PX 的div 容器 IE6这个问题是默认行高造成的，解决：overflow:hidden zoom:0.08 line-height:1px 闭包函数运行log 123456789101112131415161718192021222324function foo()&#123; foo.a = function()&#123; alert(1) &#125;; this.a = function()&#123; alert(2) &#125;; a = function()&#123; alert(3) &#125;; var a = function()&#123; alert(4) &#125;;&#125;;foo.prototype.a = function()&#123; alert(5)&#125;; foo.a = function()&#123; alert(6)&#125;;foo.a(); //6var obj = new foo();obj.a(); //2foo.a(); //1 匹配输入的字符：第一个必须是字母或下划线开头，后面的是字母数字或者下划线构成，长度5-20 /^[a-zA-Z_][a-zA-Z0-9_]{4,19}/ html添加事件的几种方法 onclick attachEvent addEventListener BOM的对象？ Window 是JS的最顶层 其他BOM对象都是Window的属性 doucument 文档对象 location 浏览器的当前URL navigation 浏览器本身信息 screen 客户端屏幕信息 history 浏览器访问历史信息 JS中的简单继承 Call方法 12345678910111213141516171819202122function textCallAction() &#123; function Parent(name, money)&#123; this.name = name; this.money = money; this.info = function()&#123; console.log('姓名: '+this.name+' 钱: '+ this.money); &#125; &#125; //定义孩子类 function Children(name)&#123; Parent.call(this, name); //继承 姓名属性，不要钱。 this.info = function()&#123; console.log('姓名: '+this.name); &#125; &#125; //实例化类 var per = new Parent('parent', 800000000000); var chi = new Children('child'); per.info(); // 查询自己有方法 chi.info(); // 查询自己有方法，如果没有向父类查询&#125; bind() live() delegate() 的区别？ bind 绑定事件，对新添加的事件不起作用，方法用于将一个处理成语附加到每个匹配事件上并返回Jquery 对象 live 方法将一个时间处理程序附加到与当前选择器匹配到所有的元素的制定事件上并返回JQuery对象 delegate 放大基于一组特定的根元素将处理程序附加到匹配选择器的所有元素的一个或者多个事件上 typeof [1,2] 返回的object | 返回的类型有 boolen string number object function undefined Link 和import的区别 用途：Link是Html标签 除了加载CSS 外，还可以定义RSS的其他事物，@import 属于CSS范畴 只能加载CSS 载入时机：Link引用CSS时，在页面载入的时候加载，@import 网页完全载入之后加载 兼容性问题：Link时html标签，无兼容性问题 @import时CSS2.1提出来的，低版本无法兼容 改变样式：Link支持用JS控制DOM去改变样式 @import不支持 Window.onload 和Window.ready的区别？ Load需要图片和包含的文件都在加进来之后执行 ready是不包含图片和非文字的 文档结构准备好就执行 DOM结构绘制完成之后就执行 如何优化代码 代码重用 避免使用全局变量 拆分函数 -&gt; 避免函数过于臃肿单一职责 适当的注释 尤其是复杂的业务逻辑和计算逻辑 应写出业务逻辑的具体过程 内存管理，闭包的变量的释放 文本域当按下enter 键时，不换行，而是换成 123456789function replaceTextEnterKey()&#123; var dom = document.getElementsByTagName('textarea') dom.onkeyup = function (e)&#123; e.preventDefault() //为了阻止 enter 键的默认换行效果 if(e.keycode == 'enter键码')&#123; dom.value+="&#123;&#123;enter&#125;&#125;"; &#125; &#125;&#125; 用原声的JS实现Jquer的Post/get 请求 以及跨域问题 1234占位置：POST：GET：跨域配置 web 前端性能优化 优化思路？ 网络资源 ：设置缓存 减少Http请求 本地资源：多个小图配置程精灵图， 加载进度 JS 循环引用 重复代码合并抽取 没用的图片定期删除 减小包体积 reayonly 与disable的区别 readonly 只针对inputtext / passwodd 和textarea 有效 而disable 对于所有的表单元素都有效，当表单元素使用了disable之后，当把表单提交的时候，元素值不会传递出去 readonly 会将值传递出去 尽可能详尽的解释Ajax的工作原理 Ajax原理通过XMLHttpRequest对象来向服务器发异步请求 ，从服务器获得数据，然后通过JS来操作DOM来更新界面， XMLHttpRequest时Ajax的核心机制，是IE5首先引入的，支持异步请求的技术， JS同源策略: 域名 协议 端口 相同 如何实现设计中用了非标准的字体? HTTP 协议中GET 金和POST有什么区别，分别使用什么场景 使用场景： get 传送的数据长度有限制，post没有 get 通过url 传递 在浏览器地址栏可见，post在报文中传递 post一般用于表单提交 get一般用于简单的数据查询，严格要求不那么高的场景 HTTP状态码 【200 302 304 403 404 500】分别表示什么 200请求成功 302临时重定向 客户端应当继续原有的地址发送以后的请求，只有在cache-control 或Expirse中进行了指定的情况下这个相应才是可缓存的 304如果客户端 发送了一个带条件的GET请求并且被允许，而内容没有改变，304响应禁止包含消息体 因此消息头后以第一个空行结尾 403 服务器拒绝执行 404 请求失败，请求的资源未在服务器上发现 500 服务器遇到了一个未曾预料的状况，导致无法完成对请求的处理，一般出现在服务器端代码出现错误 HTTP协议中，header信息里面 -&gt; 怎么控制页面失效时间？ last-modified cache-control Expires Last-Modified 文档最后修改的时间 客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304(Not Modified)状态 Last-Modified也可以通过setDateHeader 方法来设置 Expires 应该在什么时候认为文档过期，从而不再缓存它 优化常用的优化WEB页面加载速度的方法(从网络请求 CSS JS 服务器等) JS中实现一个map 123456789101112function testMap()&#123; Array.prototype.map2=function(callback)&#123; for (var i = 0; i &lt; this.length; i++) &#123; this[i]=callback(this[i]); &#125; &#125;; var temq = [&#123;name:'1'&#125;,&#123;name:'2'&#125;,&#123;name:'3'&#125;,&#123;name:'4'&#125;] temq.map2(obj=&gt; obj2.name) var nameStr = temq.map2(function (amodel) &#123; return amodel.name &#125;) &#125; 如何获取对象A的所有属性(可枚举的，不可枚举的，不包括继承来的属性) 123456Object.keys——IE9+//或者使用 for...in 并过滤出继承的属性 for(o in obj)&#123; if(obj.hasOwnproperty(o))&#123; //把 o 这个属性放入到一个数组中 &#125; &#125; 三种弹框的单词三种弹框的功能 【alert confirm prompt】 console.log(8 | 1) -&gt; log:9 JS数组添加，删除 排序 方法有哪些 12345678910111213Array.contact() //拼接数组Array.join() // 用，拼接 Array.length // 数组长度Array.pop() //尾部删除并返回数组的最后一个元素Array.push() 尾部给添加元素Array.shift() 头部移除Array.unshift() 头部插入Array.splice() 删除位置，长度Array.slice() 返回数组的一部分Array.reverse() 反转Array.sort() 排序 函数或箭头函数Array.toString() 转换为字符串Array.toLocaleString() 将数组 转换成局部字符串 JS中callee 和 caller的作用区别 caller :返回一个函数的引用 该函数调用了当前函数fn.caller() callee 返回正在被执行的function 函数 ，也就是指定的function对象的上下文 arguments.callee 在JS中什么是伪数组？如何将伪数组转化为数组 伪数组(类数组) 无法调用length，但可以通过for遍历，典型的函数是arguments 还有使用getElementsByTagName,document.childNodes 等返回的Nodeist都是伪数组 立即执行函数/闭包 12345678910setImmedFunc()&#123; (function test()&#123; var a,b=5; console.log(typeof a); console.log(typeof b); &#125;)(); console.log(typeof a); console.log(typeof b);&#125;// number number undefined number 运算符之间的操作 123456789101112131415161718192021222324var a;var b = a * 0; if (b == b) &#123; console.log(b * 2 + "2" - 0 + 4);&#125; else &#123; console.log(!b * 2 + "2" - 0 + 4);&#125;// 26---------------------------------------&lt;script&gt; var a = 1;&lt;/script&gt;&lt;script&gt; var a; var b = a * 0; if (b == b) &#123; //b=0 console.log(b * 2 + "2" - 0 + 4); &#125; else &#123; console.log(!b * 2 + "2" - 0 + 4); &#125; //6&lt;/script&gt; btn.addEvenetListener() 1234567var btn = document.getElementById('btn'); var handler = &#123; id: '_eventHandler', exec: function()&#123; alert(this.id); &#125;&#125;btn.addEventListener('click', handler.exec); 原型链继承 1234567891011121314151617var obj = &#123; proto: &#123;a:1,b:2&#125;&#125;; function F()&#123;&#125;;F.prototype = obj.proto;var f = new F(); obj.proto.c = 3;obj.proto = &#123;a:-1, b:-2&#125;;alert(f.a);//1alert(f.c);//3delete F.prototype['a'];alert(f.a);//undefinedalert(obj.proto.a);//-1添加属性会继承，父影响子，子不影响父 写出函数DateDemo()123456 function DateDemo()&#123; var d, s="今天日期是:"; d = new Date(); s += (d.getMonth() + 1) + "/"; s += d.getDate() + "/"; s += d.getFullYear(); return s;&#125;console.log(DateDemo()) HTML5 CSS3算法 农场买了一只羊，第一年是小羊，第二年底生一只，第三年不生，第四年底再生一只，第 五年死掉 写出代码对下列数组去重并从大到小排列 {5,2,3,6,8,6,5,4,7,1,9}先去重再排序 约瑟夫环 已知 n 个人(以编号 1，2，3…分别表示)围坐在一张圆桌周围。从编号为k的人开始报数，数到m的那个人出列;他的下一个人又从1开始报数，数到m的那个人又出列;依此规律重复下去，直到圆桌周围的人全部 出列 有 1 到 10w 这个 10w 个数，去除 2 个并打乱次序，如何找出那两个数? 请写一个正则表达式:要求最短 6 位数，最长 20 位，阿拉伯数和英文字 母(不区分大小写)组成^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])[a-zA-Z\d]{6,20}$ 统计 1 到 400 亿之间的自然数中含有多少个 1?比如 1-21 中，有1、10、11、12、13、14、15、16、17、18、19、20、21 这么多自然数有 13 个 1 删除与某个字符相邻且相同的字符，比如 fdaffdaaklfjklja 字符串处理之后成为“fdafdaklfjklja” 请写出一个程序，在页面加载完成后动态创建一个 form 表 单，并在里面添加一个 input 对象并给它任意赋值后义 post 方式 提交到:http://127.0.0.1/save.php 用 JavaScript 实现冒泡排序。数据为 23、45、18、37、92、13、24 Jquery $.ajax()常用的参数有哪些 用post请求并带有发送数据的和返回数据的样例 jQuery 的 slideUp 动画 ，如果目标元素是被外部事件驱动, 当鼠标快速地连续触发外部元素事件, 动画会滞后的反复执行， 该如何处理呢? JS高级JS流行框架移动开发Node.js前端概括性问题]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转-读书笔记---你不知道的JavaScript(上).md]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0---%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript(%E4%B8%8A)%2F</url>
    <content type="text"><![CDATA[Q&amp;A 1.问:为什么要写这么长,有必要吗?是不是脑子秀逗了?答:我想这是大部分人看到这个标题都会问的问题.因为作为一个男人,我喜欢长一点,也不喜欢分割成几个部分.一家人就要在一起,整整齐齐.好吧,正经点,其实整篇前言可以说都是在回答这个问题.你可以选择先看完前言,再决定要不要和书本搭配起来阅读. 这里先简单捋一下:1,内容多:首先这篇读书笔记本来内容就很多,是对书本的全方位详解.2,针对新人:针对那种红宝书草草读过一遍,对js只浮于接口调用的新手.3,留给读者自己提炼:读这种社科类书籍一般是先读厚,再读薄.这篇笔记就属于最开始’读厚’的阶段.在读者彻底读懂后,再自己进一步提炼.关于怎么读书,我后面会详细介绍. 2.问:这么长,那到底包含了些什么内容?答:笔记的目录结构和书本的完全一致.对每一节的内容进行更通俗的解读(针对新人),对示例进行更深的说明,有的会辅以流程图,并提供对应的mdn连接;对内容进行归纳,小节脉络更清晰;添加了大量实际工作时的注意事项,增加了更加清晰和易懂的示例及注释,并在原文基础上进行了拓展和总结;对书中的错误和说了后面会进行介绍,而没有介绍的填坑,翻译或者容易引起误会的称呼的说明;添加了个人读书时的感受和吐槽. 3.问:书已经够多了,还要看你这么长的笔记?答:首先你要知道读这种技术类书籍,不是读小说!读完并不意味着你读懂了.而是需要将书中的知识转换成你自己的.这篇笔记就是,帮助新手更方便地理解知识点,更流畅地进行阅读.也可以在读完一节后,通过对比,发现自己有什么知识点是不懂或者遗漏,理解有误的. 并且一些注意事项,容易被误导的,关于书中观点的吐槽等等,其实想说的都已经写在笔记里了. 4.问:这本书到底怎么样,有没有其他人说的那么好?答:这是一个先扬后抑的回答.首先毫无疑问这是一本非常不错的书!它系统地全面地对JavaScript进行解读,优点缺点全都有.当你彻底读懂这本书后,你对JavaScript的几乎所有疑问都会得到解答(我对作用域是不是”对象”的疑问?也得到了解答).但它也是有一定门槛的,如果你对JS不熟,常用接口都不熟,很多名词的表层意思都不太理解.这本书并不适合你,你花在问谷歌娘的时间可能比你读书的都长,读起来也是一知半解;不同于其他书,这本书很多时候没有给出明确的概念定义,需要你自己反复阅读理解他的话.每一小节的脉络结构也不是那么清晰,有时候需要自己去梳理;不知道是不是翻译的锅,很多东西解释得有点迷,本来很简单,但却说一堆并不常用的术语(可能国内不是这么叫的),看得你一脸懵逼!有时候同一个概念,前后会出现三四个不同的名词进行指代,没有任何说明;整本书,具有很强的作者主观情感在里面.前半段,把JS捧得很高,说它引擎的各种优化好!但到后半段关于JavaScript中模拟类和继承”的批评,说它们具有很大误导性!更是嗤之以鼻!就差爆粗口了,好像JavaScript就是一个异教徒,应该绑在十字架上被烧死!但是他这样的观点,都是站在其他类语言的角度来看待,产生的.我想更多的读者可能是只接触过JavaScript这一种语言,对他们来说,其实是根本没有这些”疑惑”的! 读书建议: 1.不要抱任何功利和浮躁的心来读书!这种以理论,概念为主的书,其实大家都是不那么愿意读的.一是读起来很费劲,抽象.二是实际工作,几乎不会用到,在现在浮躁的前端圈这是吃力不讨好.那这本书最大的用处是什么?没错,就是被很多人用来应付面试!? 这本身没什么问题,你读懂系列三本书,所有涉及JS的面试都能轻松应对.但是当抱着功利心时,你更多的则是敷衍.对书中的概念进行机械的复制,再粘贴上自己肤浅的理解.OK,应付那些也是跟风的面试官足够了.一般你回答了,他们也不会继续往下问,问深了自己也不清楚,也不好否定你.如果你够自信,’瞎扯’也可以唬住.如果你答不上,脸皮厚的会让你回去自己查.真正知道的面试官,其实都是会给你解释的,他们也不会忙到差这点时间.其实他们心里也是很乐意展示自己学识丰富的一面.这种功利读书方式,即使你读完了(更多人是半途而废),对你的技术也不会有任何帮助.因为读完,你其实是一知半解的.这样反而更糟,甚至可能会对你之前JavaScript正确的理解产生混淆. 2.认认真真读完一本书好过收藏一百篇相关文章(其实你压根连一半都不会看)! 我一直认为想系统弄懂一门知识,书本才是最好的选择,它绝对比你东拼西凑找来的一堆文章要好得多!现在前端圈随便看看,一大堆全是原型链,闭包,this…这些内容.里面的内容大同小异,很多理解也是比较浅显,考虑的也比较片面.但浮躁的人就是喜欢这种文章,觉得自己收藏了,看了就彻底理解了(!?).其实这些文章里有很多都是借鉴了本书. 首先,你必须知道知识都是有体系的,不是完全独立的.例如想要彻底理解,原型链,闭包,this.就必须先弄清作用域和函数.知识都是环环相扣,相互关联的.如果你想彻底弄懂,还是选择读书吧,由浅入深,全面理清所有知识点的关联.记住 “一知半解”永远比”无知”更糟!(当然不懂装懂,还振振有词的人另当别论). 3.如何读书:先读厚,再读薄!首先先把书读厚: 将每一节里的所有知识点弄懂,不留遗漏.记下所有提到的知识点,并将重要的知识点高亮标识(电子书的话).然后在自己本地的MD笔记里,按照一定的逻辑顺序,尽量用自己的话语进行阐述总结这些知识点.如果有读几遍也不理解的地方,可以查询MDN,结合自己的实际工作经验,或者先圈起来,继续往下读,随着后面理解的深入,前面不懂的地方自然也就明了了.这篇读书笔记就是带你怎么把书读厚.然后把书读薄: 这部分需读者你自己在彻底理解的基础上,并站在全局的角度进行归纳去总结.先是按章进行思维导图式的总结.然后章与章之间进行规律总结,并记住特例.例如:作用域与原型链都有一个类似的”就近原则”,由于就近原则所以就产生了”屏蔽”.这些都是需要自己站在全局融会贯通的角度去总结.虽然网上有别人总结好的,但我们不应该养成什么都依赖别人,自己直接复制的习惯(如果你想一直做一个’复制粘贴’程序员的话). 第一部分 作用域和闭包链接：https://juejin.im/post/5bfaa2e26fb9a04a0440b0e4来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 第一章 作用域是什么1.1 编译原理传统编译的三个步骤 1,分词/词法分析(Tokenizing/Lexing) : 这个过程会将由字符组成的字符串分解成(对编程语言来说)有意义的代码块，这些代码块被称为词法单元(token)。例如，考虑程序var a = 2;。这段程序通常会被分解成 为下面这些词法单元:var、a、=、2、;。空格是否会被当作词法单元，取决于空格在 这门语言中是否具有意义。 2,解析/语法分析(Parsing): 这个过程是将词法单元流(数组)转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”(Abstract Syntax Tree，AST)。var a = 2; 的抽象语法树中可能会有一个叫作 VariableDeclaration 的顶级节点，接下来是一个叫作Identifier(它的值是a)的子节点，以及一个叫作 AssignmentExpression 的子节点。AssignmentExpression 节点有一个叫作 NumericLiteral(它的值是 2)的子节点。 3,代码生成: 将 AST 转换为可执行代码的过程称被称为代码生成。这个过程与语言、目标平台等息息相关。抛开具体细节，简单来说就是有某种方法可以将 var a = 2; 的 AST 转化为一组机器指令，用来创建一个叫作 a 的变量(包括分配内存等)，并将一个值储存在 a 中。 说明: 此处只需记住第一步:分词/词法分析.第二步:解析/语法分析,得到抽象语法树(AST).第三步:代码生成,将抽象语法树转换为机器指令. JavaScript与传统编译的不同点: 1,JavaScript 引擎不会有大量的(像其他语言编译器那么多的)时间用来进行优化. 2,JavaScript与传统的编译语言不同，它不是在构建之前提前编译的，大部分情况下,它是在代码执行前的几微秒(甚至更短)进行编译. 3,JavaScript 引擎用尽了各种办法(比如 JIT，可以延 迟编译甚至实施重编译)来保证性能最佳。 4,JavaScript的编译结果不能在分布式系统中进行移植。 1.2 理解作用域1.2.1 演员表(代码编译到执行的参与者)首先介绍将要参与到对程序 var a = 2; 进行处理的过程中的演员们，这样才能理解接下来将要听到的对话。 引擎从头到尾负责整个 JavaScript 程序的编译及执行过程。 编译器引擎的好朋友之一，负责语法分析及代码生成等脏活累活(详见前一节的内容)。 作用域引擎的另一位好朋友，负责收集并维护由所有声明的标识符(变量)组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。1.2.2 对话(代码编译执行过程) 1.2.3 作用域的LHS查询和RHS查询由上图可知,引擎在获得编译器给的代码后,还会对作用域进行询问变量. 现在将例子改为var a = b;此时引擎会对变量a和变量b都向作用域进行查询.查询分为两种:LHS和RHS.其中L代表左.R代表右.即对变量a进行LHS查询.对变量b进行RHS查询. 单单从表象上看.LHS就是作用域对=左边变量的查询.RHS就是作用域对=右边变量的查询.但实际上并不是这么简单,首先LHS和RHS都是对变量进行查询,这也是我为什么要将例子从var a=2;改为var a=b;两者的区别是两者最终要查询到的东西并不一致.LHS是要查询到变量的声明(而不是变量的值),从而后面可以为其赋值.RHS是要查询到变量最终的值.还有一点,LHS 和 RHS 的含义是“赋值操作的左侧或右侧”并不一定意味着就是“= 赋值操作符的左侧或右侧”。赋值操作还有其他几种形式，因此在概念上最 好将其理解为“赋值操作的目标是谁(LHS)”以及“谁是赋值操作的源头(RHS)”.或者这样理解如果这段代码需要得到该变量的’源值’,则会进行RHS查询. 1.2.4 引擎和作用域的对话这部分比较简单就是通过拟人方式比喻引擎和作用域的合作过程.一句话概括就是,引擎进行LHS和RHS查询时都会找作用域要.1234function foo(a) &#123; console.log( a ); // 2&#125;foo( 2 ); 让我们把上面这段代码的处理过程想象成一段对话，这段对话可能是下面这样的。 引擎:我说作用域，我需要为 foo 进行 RHS 引用。你见过它吗?作用域:别说，我还真见过，编译器那小子刚刚声明了它。它是一个函数，给你。引擎:哥们太够意思了!好吧，我来执行一下 foo。引擎:作用域，还有个事儿。我需要为 a 进行 LHS 引用，这个你见过吗?作用域:这个也见过，编译器最近把它声名为 foo 的一个形式参数了，拿去吧。引擎:大恩不言谢，你总是这么棒。现在我要把 2 赋值给 a。引擎:哥们，不好意思又来打扰你。我要为 console 进行 RHS 引用，你见过它吗?作用域:咱俩谁跟谁啊，再说我就是干这个。这个我也有，console 是个内置对象。 给你。引擎:么么哒。我得看看这里面是不是有 log(..)。太好了，找到了，是一个函数。引擎:哥们，能帮我再找一下对 a 的 RHS 引用吗?虽然我记得它，但想再确认一次。作用域:放心吧，这个变量没有变动过，拿走，不谢。引擎:真棒。我来把 a 的值，也就是 2，传递进 log(..)。 1.3作用域嵌套当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。进而形成了一条作用域链.因此，在当前作用 域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量， 或抵达最外层的作用域(也就是全局作用域)为止。 当引擎需要对作用域进行查询时.引擎会从当前的执行作用域开始查找变量，如果找不到， 就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都 会停止。 1.4 异常例子:12345function foo(a) &#123; console.log( a + b ); b = a;&#125;foo( 2 ); 如果 RHS 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 ReferenceError 异常。例如上面例子中console.log(a+b)由于RHS此时是找不到b的值.故会抛出ReferenceError. 如果 RHS 查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作， 比如试图对一个非函数类型的值进行函数调用，或着引用 null 或 undefined 类型的值中的 属性，那么引擎会抛出另外一种类型的异常，叫作 TypeError。 当引擎执行 LHS 查询时，如果在顶层(全局作用域)中也无法找到目标变量，全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎，前提是程序运行在非 “严格模式”下。例如上面例子中的b=a;. 在严格模式中 LHS 查询失败时，并不会创建并返回一个全局变量，引擎会抛出同 RHS 查询 失败时类似的 ReferenceError 异常。 1.5 LHS与RHS小结 LHS和RHS查询都是引擎对作用域的查询 LHS和RHS查询都是只对变量进行查询 LHS和RHS都会沿着作用域链进行查询,直到最上层的全局作用域.如果没找到的话,在非严格模式下,LHS则会在全局创建一个相同名称的变量.RHS则会抛出ReferenceError的异常. 如果查找的目的是对变量进行赋值，那么就会使用 LHS 查询;如果目的是获取变量的值，就会使用 RHS 查询。 LHS只是找到变量的容器而已,方便进行赋值 =操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。此时都会进行LHS查询 RHS查询则需要找到变量的值. 第二章 词法作用域作用域分为两种工作模式: 1,词法作用域.是目前最为普遍的，被大多数编程语言所采用的模式.当然JavaScript也是使用的词法作用域. 2,动态作用域.使用较少,比如 Bash 脚本、Perl 中的一些模式等. 2.1 词法阶段词法阶段: 大部分标准语言编译器的第一个工作阶段叫作词法化(也叫单词化)。词法化的过程会对源代码中的字符进行检查，如果是有状态的解析过程，还会赋予单词语义。 词法作用域: 词法作用域就是定义在词法阶段的作用域也被称为静态作用域。即在JavaScript里作用域的产生是在编译器出来的第一阶段词法阶段产生的,并且是你在书写完代码时就已经确定了的. 词法作用域位置: 词法作用域位置范围完全由写代码期间函数所声明的位置来决定. 理解词法作用域及嵌套:看下例子:12345678910function foo(a) &#123; var b = a * 2; function bar(c) &#123; console.log( a, b, c ); &#125; bar( b * 3 ); &#125;foo( 2 ); // 2, 4, 12 在这个例子中有三个逐级嵌套的作用域。为了帮助理解，可以将它们分成3个逐级包含的”气泡作用域”。 1:包含着整个全局作用域，其中只有一个标识符:foo。 2:包含着 foo 所创建的作用域，其中有三个标识符:a、bar 和 b。 3:包含着 bar 所创建的作用域，其中只有一个标识符:c。 注意: 没有任何函数的气泡可以(部分地)同时出现在两个外部作用域的气泡中，就如同没有任何函数可以部分地同时出现在两个父级函数中一样。 引擎对作用域的查找:这一部分在上一节中已经说过,就是从当前作用域逐级向上,直到最上层的全局作用域.这里再进一步进行讲解.作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，这叫作“遮蔽效应”(内部的标识符“遮蔽”了外部的标识符)。抛开遮蔽效应， 作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止。 注意: 全局变量会自动成为全局对象(比如浏览器中的 window对象)的属性，因此可以不直接通过全局对象的词法名称，而是间接地通过对全局对象属性的引 用来对其进行访问。例如:window.a 通过这种技术可以访问那些被同名变量所遮蔽的全局变量。但非全局的变量如果被遮蔽了，无论如何都无法被访问到。 词法作用域查找只会查找一级标识符，比如 a、b 和 c。如果代码中引用了 foo.bar.baz，词法作用域查找只会试图查找 foo 标识符，找到这个变量后，对象属性访问规则会分别接管对 bar 和 baz 属性的访问。 2.2 欺骗词法欺骗词法: 引擎在运行时来“修改”(也可以说欺骗)词法作用域.或者说就是在引擎运行时动态地修改词法作用域(本来在编译词法化就已经确定的). 欺骗词法的两种机制:(下面这两种机制理解了解即可,不推荐实际开发使用) 2.2.1 evalJavaScript 中的 eval(..) 函数可以接受一个字符串为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码。即将eval放在该词法作用域,然后eval携带的代码就会动态加入到该词法作用域. 通过下面的例子加深理解:123456function foo(str, a) &#123; eval( str ); // 欺骗! console.log( a, b );&#125;var b = 2;foo( "var b = 3;", 1 ); // 1, 3 eval(..) 调用中的 “var b = 3;” 这段代码会被当作本来就在那里一样来处理。由于那段代码声明了一个新的变量 b，因此它对已经存在的 foo(..) 的词法作用域进行了修改。当 console.log(..) 被执行时，会在 foo(..) 的内部同时找到 a 和 b，但是永远也无法找到外部的 b。因此会输出“1, 3”而不是正常情况下会输出的“1, 2”。 注意: eval(..) 通常被用来执行动态创建的代码.可以据程序逻辑动态地将变量和函数以字符形式拼接在一起之后传递进去。 在严格模式下,eval(…)无法修改所在的作用域。 与eval(…)类似,setTimeout(..)和 setInterval(..) 的第一个参数可以是字符串，字符串的内容可以被解释为一段动态生成的函数代码。 new Function(..) 函数的行为也很类似，最后一个参数可以接受代码字符串，并将其转化为动态生成的函数(前面的参数是这个新生成的函数的形参)。这种构建函数的语法比 eval(..) 略微安全一些，但也要尽量避免使用。12var sum = new Function("a", "b", "return a + b;");console.log(sum(1, 1111)); //1112 2.2.2 with(不推荐实际使用)例子:12345678910111213141516171819function foo(obj) &#123; with (obj) &#123; a = 2; &#125;&#125;var o1 = &#123; a: 3&#125;;var o2 = &#123; b: 3&#125;;foo( o1 );console.log( o1.a ); // 2foo( o2 );console.log( o2.a ); // undefinedconsole.log( a ); // 2——不好，a 被泄漏到全局作用域上了! 起初你会觉得o1的a属性被with里的a进行了词法引用被遮蔽了成为了2.而o2没有a属性,此时with不能进行词法引用,所以此时o2.a就会变成undefined.但是,为什么最后console.log(a)会为2?因为在执行foo(o2)时,with会对其中的a=2进行LHS查询,但它在o2作用域,foo()作用域,全局作用域都没找到,因此就创建了一个全局变量a并随后赋值2. 总的来说,with就是将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符。 注意: 使用 eval(..) 和 with 的原因是会被严格模式所影响(限制)。with 被完全禁止，而在保留核心功能的前提下，间接或非安全地使用 eval(..) 也被禁止了。 2.2.3 性能JavaScript 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。但是eval(..) 和 with会在运行时修改或创建新的作用域，以此来欺骗其他在书写时定义的词法作用域。这么做就会导致引擎无法知道eval和with它们对词法作用域进行什么样的改动.只能对部分不进行处理和优化!因此如果代码中大量使用 eval(..) 或 with，那么运行起来一定会变得非常慢!。 2.3 小结 词法作用域是在你书写代码时就已经决定了的.在编译的第一阶段词法分析阶段产生词法作用域.此时词法作用域基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它 们进行查找。 eval(..) 和 with。前者可以对一段包含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域(在运行时)。后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域(同样是在运行时)。 一般不要在实际代码中使用eval(…)和with,因为不仅危险,而且会造成性能问题! 第三章 函数作用域和块作用域3.1 函数中的作用域 JavaScript 具有基于函数的作用域，一般情况下每声明 一个函数都会创建一个函数作用域. 函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用(事实上在嵌套的作用域中也可以使用)。这样的好处是JavaScript 变量可以根据需要改变值类型。 3.2 隐藏内部实现因为 子级函数作用域可以直接访问父级函数作用域里的标识符; 父级函数作用域不能直接访问子级函数作用域里的标识符. 所以用函数声明对代码进行包装，实际上就是把这些代码“隐藏”起来了。 为什么要将代码进行”隐藏”?因为最小授权或最小暴露原则。这个原则是指在软件设计中，应该最小限度地暴露必 要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计。隐藏的好处: 实现代码私有化,减少外部对内部代码的干扰,保持其稳定性. 规避冲突: 可以避免同名标识符之间的冲突， 两个标识符可能具有相同的名字但用途却不一样，无意间可能造成命名冲突。冲突会导致 变量的值被意外覆盖。那么一般规避冲突的手段有哪些? 全局命名空间: 变量冲突的一个典型例子存在于全局作用域中。当程序中加载了多个第三方库时，如果它们没有妥善地将内部私有的函数或变量隐藏起来，就会很容易引发冲突。这些库通常会在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象(命名空间)的属性，而不是将自己的标识符暴漏在顶级的词法作用域中。 2.模块管理: 另外一种避免冲突的办法和现代的模块机制很接近，就是从众多模块管理器中挑选一个来 使用。实际上就是我们常用的amd,commonjs,import模块机制. 3.3 函数作用域函数声明与函数表达式:123function foo() &#123; ...&#125; 我们知道函数foo内的变量和函数被隐藏起来了,是不会对全局作用域造成污染.但是变量名foo仍然存在于全局作用域中,会造成污染.那有什么方法能避免函数名的污染呢?那就是作为函数表达式,而不是一个标准的函数声明.这样函数名只存在于它自己的函数作用域内,而不会存在于其父作用域,这样就没有了污染.举个函数声明的例子:123456var a = 2;(function foo()&#123; var a = 3; console.log( a ); // 3 &#125;)(); console.log( a ); // 2 当我们用()包裹一个函数,并立即执行.此时这个包装函数声明是从(function开始的而不是从function关键字开始.这样foo就会被当做一个函数表达式,而不是一个函数声明(即foo不会存在于父级作用域中).回到上面的例子中,全局作用域是访问不到foo的,foo只存在于它自己的函数作用域中. 补充: 什么是函数声明和函数表达式首先我们得了解JS声明函数的三种方式: 函数表达式(Function Expression): 将函数定义为表达式语句（通常是变量赋值,也可以是自调用形式）的一部分。通过函数表达式定义的函数可以是命名的，也可以是匿名的。因为它可以没有函数名,因此常被用作匿名函数.如果有,其函数名也只存在自身的函数作用域.并且函数表达式不能以“function”开头.函数表达式可以存储在变量或者对象属性里. (在函数声明前加上运算符是可以将其转化为函数表达式的.例如!,+,-,().举个例子:!function(){console.log(1)}()的结果是1,并不会报错) 函数声明(Function Declaration): 函数声明是一种独立的结构,它会声明一个具名函数,并必须以function开头. 且函数声明会进行函数提升.使它能在其所在作用域的任意位置被调用,即后面的代码中可以将此函数通过函数名赋值给变量或者对象属性. Function()构造器: 即使用Function构造器创建函数.不推荐这种用法, 容易出问题123456789101112131415//Function()构造器var f =new Function()// 函数表达式var f = function() &#123; console.log(1); &#125;// 函数声明function f ()&#123; console.log(2);&#125;console.log(f())//思考一下,这里会打印出什么 怎么区分函数声明和函数表达式:看 function 关键字出现在声明中的位置(不仅仅是一行代码，而是整个声明中的位置)。如果 function 是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。例如上例中,是从(开始而不是function. 补充: 上面这段是原书的解释,我觉得这个解释并不完全,这里给出我自己的解释. 表象区别:和它说的一样,只要是以function开头进行声明,并且含有函数名的就一定是函数声明. 内在区别:其实我在上面补充两者的定义时已经说得很清楚了,我再对比总结下. 函数提升:函数声明,会将整个函数进行提升.而函数表达式则不会提升,它是在引擎运行时进行赋值，且要等到表达式赋值完成后才能调用。 函数表达式是可以没有函数名的,如果有,它的函数名也只存在于自身的作用域,var f = function fun(){console.log(fun)}其他地方是没有的.这也避免了全局污染,也方便递归. 3.3.1 匿名和具名函数表达式可以是匿名的，而函数声明则不可以省略函数名.有函数名的就是具名函数,没有函数名的就是匿名函数. 匿名函数的缺点: 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。 如果没有函数名，当函数需要引用自身时只能使用已经过期的arguments.callee引用，比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。 匿名函数省略了对于代码可读性/可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。 所以给函数表达式指定一个函数名可以有效解决以上问题。始终给函数表达式命名是一个最佳实践. PS: 个人意见是如果函数表达式有赋值给变量或属性名或者就是一次性调用的.其实是没必要加上函数名.因为代码里取名本来就很难,取不好反而会造成误解. 3.3.2 立即执行函数表达式比如 (function foo(){ .. })()。第一个 ( ) 将函数变成表达式，第二个 ( ) 执行了这个函数。这就是立即执行函数表达式,也被称为IIFE，代表立即执行函数表达式 (Immediately Invoked Function Expression); IIFE可以具名也可以匿名.好处和上面提到的一样.IIFE还可以是这种形式(function(){ .. }()).这两种形式在功能上是一致的。 3.4 块作用域函数作用域是JavaScript最常见的作用域单元,有时我们仅会将var赋值变量在if或for的{…}内使用,而不会在其他地方使用.但它仍然会对外层的函数作用域造成污染.这个时候就会希望能有一个作用域能将其外部的函数作用域隔开,声明的变量仅在此作用域有效.块作用域(通常就是{…}包裹的内部)就可以帮我们做到这点. 从 ES3 发布以来，JavaScript 中就有了块作用域，而 with 和 catch 分句就是块作用域的两个小例子。 3.4.1 with我们在第 2 章讨论过 with 关键字。它不仅是一个难于理解的结构，同时也是块作用域的一个例子(块作用域的一种形式)，用 with 从对象中创建出的作用域仅在 with 声明中而非外部作用域中有效。 3.4.2 try/catchtry/catch 的 catch 分句会创建一个块作用域，其中声明的变量仅在 catch 内部有效。1234567try &#123; undefined(); // 执行一个非法操作来强制制造一个异常&#125;catch (err) &#123; console.log( err ); // 能够正常执行! &#125;console.log( err ); // ReferenceError: err not found err 仅存在 catch 分句内部，当试图从别处引用它时会抛出错误。那么如果我们想用catch创建一个不是仅仅接收err的块作用域,该怎么做呢?1234try&#123;throw 2;&#125;catch(a)&#123; console.log( a ); // 2&#125;console.log( a ); // ReferenceError 这样就创建了一个块作用域,且a=2,仅在catch分句中存在.在ES6之前我们可以使用这种方法来使用块作用域. 3.4.3 letES6 引入了新的 let 关键字，提供了除 var 以外的另一种变量声明方式。let 关键字可以将变量绑定到所在的任意作用域中(通常是 { .. } 内部)。 用 let 将变量附加在一个已经存在的块作用域上的行为是隐式的。例如在if的{…}内用let声明一个变量.那什么是显式地创建块作用域呢?就是单独创建{}来作为let的块作用域.而不是借用if或者for提供的{}.例如{let a=2;console.log(a)}注意: 使用 let 进行的声明不会在块作用域中进行提升.块作用域的好处: 1,垃圾收集12345678910111213function process(data)&#123; // 在这里做点有趣的事情 &#125; var someReallyBigData=function()&#123; //dosomeing &#125; process(someReallyBigData); var btn=document.getElementById("my_button"); btn.addEventListener("click",function click(evt)&#123; alert("button click"); //假如我们在这里继续调用someReallyBigData就会形成闭包,导致不能垃圾回收(这段是书里没有,我加上方便理解的) &#125;,false); click 函数的点击回调并不需要 someReallyBigData 变量。理论上这意味着当 process(..) 执行后，在内存中占用大量空间的数据结构就可以被垃圾回收了。但是，由于 click 函数形成了一个覆盖整个作用域的闭包，JavaScript 引擎极有可能依然保存着这个结构(取决于具体实现)。但显式使用块作用域可以让引擎清楚地知道没有必要继续保存 someReallyBigData 了: 123456789101112function process(data)&#123; // 在这里做点有趣的事情 &#125; // 在这个块中定义的内容可以销毁了! &#123; let someReallyBigData = &#123; .. &#125;; process( someReallyBigData ); &#125; var btn=document.getElementById("my_button"); btn.addEventListener("click",function click(evt)&#123; alert("button click"); &#125;,false); let循环1234for (let i=0; i&lt;10; i++) &#123; console.log( i ); &#125;console.log( i ); // ReferenceError for 循环头部的 let 不仅将 i 绑定到了 for 循环的块中，事实上它将其重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。这样就避免了i对外部函数作用域的污染. 3.4.4 const除了 let 以外，ES6 还引入了 const，同样可以用来创建块作用域变量，但其值是固定的(常量)。之后任何试图修改值的操作都会引起错误。123456789var foo = true;if (foo) &#123; var a = 2; const b = 3; // 包含在 if 中的块作用域常量 a = 3; // 正常! b = 4; // 错误! &#125;console.log( a ); // 3console.log( b ); // ReferenceError! 3.5 小结函数是 JavaScript 中最常见的作用域单元。本质上，声明在一个函数内部的变量或函数会在所处的作用域中“隐藏”起来，可以有效地与外部作用域隔开. 但函数不是唯一的作用域单元。块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块(通常指 { .. } 内部)即块作用域。ES6中就提供了let和const来帮助创建块作用域. 第四章 提升4.1 先有鸡(赋值)还是先有蛋(声明)考虑第一段代码123a = 2;var a; console.log( a ); 输出结果是2,而不是undefined 考虑第二段代码12console.log( a ); var a = 2; 输出结果是undefined,而不是ReferenceError考虑完以上代码,你应该会考虑这个问题.到底是声明(蛋)在前，还是赋值(鸡)在前? 4.2 编译器再度来袭编译器的内容,回忆一下，引擎会在解释 JavaScript 代码之前首先对其进行编译。编译阶段中的一部分工作就是找到所有的声明，并用合适的作用域将它们关联起来。 之后引擎会询问作用域,对声明进行赋值操作. 那么,在编译阶段找到所有的声明后,编译器又做了什么?答案就是提升以上节的第一段代码为例,当你看到 var a = 2; 时，可能会认为这是一个声明。但 JavaScript 实际上会将其看成两个声明:var a;和a = 2;。 第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在原地等待执行阶段。在第一个声明在编译阶段时,编译器会对var a;声明进行提升(即把var a;置于所在作用域的最上面).而a = 2;则会保持所在位置不动.此时代码会变成123var a; a = 2;console.log( a ); 由此可知,在编译阶段,编译器会对声明进行提升.即先有蛋(声明)后有鸡(赋值)。哪些声明会被进行提升? 变量声明:例如上例中的var a;.不包括后面的a = 2;即不包含有赋值操作的声明. 函数声明:注意是函数声明,而不是函数表达式!(不清楚可以看前面的3.3节,我有详细说明).函数声明提升,是将整个函数进行提升,而不是仅仅函数名的提升. 4.3 函数优先函数声明和变量声明都会被提升。但是一个值得注意的细节(这个细节可以出现在有多个“重复”声明的代码中)是函数会首先被提升，然后才是变量。考虑以下代码:12345678foo(); // 1var foo;function foo() &#123; console.log( 1 );&#125;foo = function() &#123; console.log( 2 );&#125;; 会输出 1 而不是 2 !这个代码片段会被引擎理解为如下形式:1234567function foo() &#123; console.log( 1 );&#125;foo(); // 1foo = function() &#123; console.log( 2 );&#125;; 注意，var foo 尽管出现在 function foo()… 的声明之前，但它是重复的声明(因此被忽略了)，因为函数声明会被提升到普通变量之前。注意: js会忽略前面已经声明的声明(不管是变量声明还是函数声明,只要其名称相同,则后续不会再进行重复声明).但是对该变量新的赋值,会覆盖之前的值.一句话概括:函数声明的优先级高于变量声明,会排在它前面. 4.4 小结 对于var a = 2 JavaScript引擎会将var a和 a = 2当作两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务。 论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。 可以将这个过程形象地想象成所有的声明(变量和函数)都会被“移动”到各自作用域的最顶端，这个过程被称为提升。 声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升(即赋值操作都不会提升)。 注意:，当普通的 var 声明和函数声明混合在一起的时候，并且声明相同时(var的变量名和函数名相同时,会引发js对重复声明的忽略)!一定要注意避免重复声明! 第五章 作用域闭包5.1 启示 JavaScript中闭包无处不在，你只需要能够识别并拥抱它。 闭包是基于词法作用域书写代码时所产生的自然结果，你甚至不需要为了利用它们而有意识地创建闭包。 5.2 实质问题 &amp;&amp; 5.3 现在我懂了因为这两小节理解透了其实发现书里也没讲什么,这里就进行合并,并补充拓展我自己的理解和总结.什么是闭包?(广义版)书中解释: 当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。MDN的解释: 闭包是函数和声明该函数的词法环境的组合。我的解释(详细版): 必须包含两点: 1,有函数.由于函数自身的特性,它能访问所在的词法作用域.并能保存外部词法作用域的变量和函数到自己的函数作用域. 2,有该函数所在的词法环境.其实在JavaScript中任何函数都会处在一个词法环境中.不管是全局作用域还是函数作用域. 综上简单版就是:MDN的解释闭包是函数和声明该函数的词法环境的组合。还可以继续延伸成极简版:JavaScript中的函数就会形成闭包。Tips: 注意到上面对词法作用域和词法环境两词的分开使用了吗?1,里此时函数还没被执行,所以使用的是词法作用域即静态作用域.2,里,此时函数被执行,此时词法作用域就会变成词法环境(包含静态作用域与动态作用域).所以其实MDN的解释其实更准确一点, 我们日常使用时所说的闭包(狭义版,严格意义上的):为了便于对闭包作用域的观察和使用.我们实际使用时会将闭包的函数作用域暴露给当前词法作用域之外.也就是本书一直强调的闭包函数需要在它本身的词法作用域以外执行.作者认为符合这个条件才称得上是真正的闭包(也就是我们日常使用常说的’使用闭包’,并且使用任何回调函数其实也是闭包).所以狭义版就是:闭包是函数和声明该函数的词法环境的组合,并且将闭包的函数作用域暴露给当前词法作用域之外. 闭包暴露函数作用域的三种方式:下面部分是书中没有的,是自己实际使用时的总结,并且符合这三种形式之一的就是我们日常使用时所说的闭包(狭义版) 1,通过外部函数的参数进行暴露. 1234567891011function foo() &#123; var a = 2; function bar() &#123; baz(a) //通过外部函数的参数进行暴露 &#125; bar(); &#125;;function baz(val) &#123; console.log( val ); // 2 &#125;foo(); 2,通过外部作用域的变量进行暴露 12345678910var val;function foo() &#123; var a = 2; function bar() &#123; val=a //通过外部作用域的变量进行暴露 &#125; bar(); &#125;;foo();console.log(val) //2 3,通过return直接将整个函数进行暴露 123456789function foo() &#123; var a = 2; function bar() &#123; console.log(a) &#125; return bar //通过return直接将整个函数进行暴露&#125;;var val=foo();val() //2 关于闭包的内存泄露问题:首先必须声明一点:使用闭包并不一定会造成内存泄露,只有使用闭包不当才可能会造成内存泄露.(吐槽:面试很多新人时,张口就说闭包会造成内存泄露)为什么闭包可能会造成内存泄露呢?原因就是上面提到的,因为它一般会暴露自身的作用域给外部使用.如果使用不当,就可能导致该内存一直被占用,无法被JS的垃圾回收机制回收.就造成了内存泄露.注意: 即使闭包里面什么都没有,闭包仍然会隐式地引用它所在作用域里的所用变量. 正因为这个隐藏的特点,闭包经常会发生不易发现的内存泄漏问题.常见哪些情况使用闭包会造成内存泄露: 1,使用定时器未及时清除.因为计时器只有先停止才会被回收.所以决办法很简单,将定时器及时清除,并将造成内存的变量赋值为null(变成空指针) 2,相互循环引用.这是经常容易犯的错误,并且也不容易发现.举个栗子:12345678function foo() &#123; var a = &#123;&#125;; function bar() &#123; console.log(a); &#125;; a.fn = bar; return bar; &#125;; 这里创建了一个a 的对象，该对象被内部函数bar引用。然后，a创建了一个属性fn指向了bar，最后返回了innerFn()。这样就形成了bar和a的相互循环引用.可能有人说bar里不使用console.log(a)不就没有引用了吗就不会造成内存泄露了.NONONO,bar作为一个闭包,即使它内部什么都没有,foo中的所有变量都还是隐使地被 bar所引用。这个知识点是我前面忘记提到的,也是书中没有提到的.算了我现在加到前面去吧.所以即使bar内什么都没有还是造成了循环引用,那真正的解决办法就是,不要将a.fn = bar. 3,将闭包引用到全局变量上.因为全局变量是只有当页面被关闭的时候才会被回收. 4,在闭包中对DOM进行不当的引用.这个常见于老IE浏览器,现代浏览器已经长大了,已经学会了自己处理这种情况了.这里就不赘述了.想知道的可以自行问谷娘和度娘. 总而言之,解决办法就是使闭包的能正常引用,能被正常回收.如果实在不行,就是在使用完后,手动将变量赋值null,强行进行垃圾回收. 5.4 循环和闭包看如下例子:12345for (var i=1; i&lt;=5; i++) &#123; setTimeout( function timer() &#123; console.log( i ); &#125;, i*1000 );&#125; 我们期望的结果是分别输出数字 1~5，每秒一次，每次一个。但实际结果是,这段代码在运行时会以每秒一次的频率输出五次 6。(关于书里的解释,我觉得有点说复杂了,没说到点子上,下面是我的解释.)为什么会是这样的结果?timer毫无疑问是一个闭包,它是可以访问到外部的变量i.在进行for循环时,timer()会被重复执行5次,也就是它会 console.log( i )5次.(关键部分来了!)这5次i其实是同一个i.它是来自于外部作用域,即for里面声明的i.在词法作用域中变量i只可能对应一个唯一的值,即变量和它的值是一一对应的.不会变化的.那这个值到底是多少呢?这个值就是最终值! i的最终值就是6即for循环完后i的值.当引擎执行console.log( i )时,它会询问i所对应的作用域,问它i的值是多少.这个时候作用域进行RHS查询得到的结果就是最终值6. 为什么我们会以为分别输出1~5?因为在for循环中,我们错以为每一次循环时,函数所输出的i是根据循环动态变化的.即是1~5累加变化的.但实际上它所访问的i是同一个固定不变的值,即最终值6.可能你会有这样的疑惑,那我循环还有意义吗?i其实一开始就确定是6了.没有变化过!错!i变化过,它的确是从1逐步增加到6的.只是外部作用域的i值只可能是循环完后的最终值,并且函数timer()并没有保存每次i变化的值.它只是访问了外部作用域的i值即最终的值6. OK我们知道了出错的地方,就是我们没有把每次i的值保存在一个独立的作用域中.接下来,看下这个改进的例子结果是多少.1234567for (var i=1; i&lt;=5; i++) &#123; (function() &#123; setTimeout( function timer() &#123; console.log( i ); &#125;, i*1000 ); &#125;)();&#125; 它的最终值仍然是5个6.为什么?我们来分析下,上例中,它用了一个匿名函数包裹了定时器,并立即执行.在进行for循环时,会创造5个独立的函数作用域(由匿名函数创建的,因为它是闭包函数).但是这5个独立的函数作用域里的i也全都是对外部作用域的引用.即它们访问的都是i的最终值6.这并不是我们想要的,我们要的是5个独立的作用域,并且每个作用域都保存一个”当时”i的值. 解决办法:那我们这样改写.123456789for (var i=1; i&lt;=5; i++) &#123; (function () &#123; var j =i; setTimeout( function timer() &#123; console.log( j ); &#125;, j*1000 ); &#125;)();&#125;//这次终于结果是分别输出数字 1~5，每秒一次，每次一个。 这样改写后,匿名函数每次都通过j保存了每次i值,这样i值就通过j保存在了独立的作用域中.注意此时保存的i值是’当时’的值,并不是循环完后的最终值.这样循环完后,实际上就创建了5个独立的作用域,每个作用域都保存了一个’当时’i的值(通过j).当引擎执行console.log( j )询问其对应的独立作用域时,得到的值就是’当时’保存的值,再也不是6了.我们还可以进一步简写为这样:12345678for (var i=1; i&lt;=5; i++) &#123; (function(j) &#123; setTimeout( function timer() &#123; console.log( j ); &#125;, j*1000 ); &#125;)(i);&#125;//结果是分别输出数字 1~5，每秒一次，每次一个。 利用块作用域进行解决:在es6中,我们不仅可以使用函数来创建一个独立的作用域,我们还可以使用let声明来创建一个独立的块作用域(在{}内).所以我们还可以这样改写:123456for (let i=1; i&lt;=5; i++) &#123; setTimeout( function timer() &#123; console.log( i ); &#125;, i*1000 );&#125;//结果是分别输出数字 1~5，每秒一次，每次一个。 这样改写,在每次循环时,let都会对i进行声明.并通过循环自带的{}创建一个独立的块作用域.并且let声明的i,保存了’当时’i的值在当前块作用域里.因此当引擎执行console.log( i )时,它会询问对应的块作用域上i的值,得到的结果就是’当时’保存的值. 延伸:实际上块作用域可以称得上一个’伪’闭包(之所以是伪,是因为闭包规定了只能是函数).因为它几乎拥有闭包的所有特性.它也可以创建一个独立的作用域,同样外部作用域不能访问块作用域的变量.但块作用域可以访问外部作用域.举个栗子:123456789function foo() &#123; var a = 2; &#123; //通过&#123;&#125; 显示表示块作用域 let b = a; console.log('块作用域内',b) //2 &#125; console.log('块作用域外',b) //b is not defined&#125;foo() 说了相同点,说说不同点:1,保存变量到块作用域,必须通过let声明.2,块作用域不能和函数一样有名称(函数名)很多不方便使用闭包或者比较麻烦的时候,是可以考虑通过块作用域进行解决. 总结一下一般什么时候考虑使用闭包:这部分也是自己工作使用的总结,如果有补充或者不对的地方,欢迎留言指正. 1,需要创建一个独立的作用域并隐藏一些变量或函数,不被外部使用;或者想保存一些外部作用域的变量或函数到这个独立作用域. 2,只想暴露一部分自身作用域的变量或函数给外部使用. 5.5 模块首先看下面的例子:123456789101112131415161718function CoolModule() &#123; var something = "cool"; var another = [1, 2, 3]; function doSomething() &#123; console.log( something ); &#125; function doAnother() &#123; console.log( another.join( " ! " ) ); &#125; return &#123; doSomething: doSomething, doAnother: doAnother &#125;; &#125;var foo = CoolModule(); foo.doSomething(); // coolfoo.doAnother(); // 1 ! 2 ! 3 首先我们对上面这段代码进成分行分析:私有数据变量:something, another内部函数:doSomething, doAnother直接说结论,上面这个例子就是模块模式.它return返回的这个对象也就是模块也被称为公共API(至少书中是这样称呼的).CoolModule()就是模块构造器或者叫模块函数.注意: 这里的模块和我们所说的模块化开发不是完全一样的! 模块不一定非要是标准对象,也可以是一个函数,函数本质上也是对象,函数也可以有自己的属性. 书中有这样一句话CoolModule() 只是一个函数，必须要通过调用它来创建一个模块实例。如果不执行外部函数，内部作用域和闭包都无法被创建。我觉得这句话有必要延伸说一下.函数调用一次就会创建一个该函数的作用域(不调用就不会创建),包括创建它里面的变量和函数. 模块模式:模块模式需要具备以下2个条件:(这里结合上面的例子,对书中的定义进行说明方便理解) 1, 必须有外部的封闭函数(即CoolModule)，该函数必须至少被调用一次(每次调用都会创建一个新的模块实例–&gt;模块实例指的就是函数return返回的对象)。 2, 封闭函数(即CoolModule)必须返回至少一个内部函数(即doSomething, doAnother)，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态(即something, another)。 模块:表面上看由模块函数(例子中的CoolModule)所返回的对象就是模块.但模块还必须还包含模块函数的内部函数(即闭包函数).只有包含了才能真正称得上是模块.才强调一次这里的模块与模块化里的模块是有区别的,也不是nodejs里的模块. 模块函数:模块函数也就是模块构造器,例子中的CoolModule().一般它有两个常见用法. 通过接受参数,对输出的模块进行修改. 通过添加模块里添加相关的内部函数,实现对输出模块数据的增删改查.(书中用命名将要作为公共API返回的对象.我觉得命名应该是用错了,应该是修改即增删改查更好) 5.5.1 现代的模块机制大多数模块依赖加载器 / 管理器本质上都是将这种模块定义封装进一个友好的 API。下面就介绍一个简单的模块管理器实现例子(对书中的例子进行逐行解读):1234567891011121314151617181920212223242526272829303132//首先实例化我们的模块管理器,取名myModulesvar MyModules=(function Manager() &#123; //作为我们的模块池,保存所有定义的模块 var modules=&#123;&#125;; /** *使用类似AMD的方式定义新模块，接收3个参数 *name:模块名 *deps:数组形式表示所依赖的其他模块 *impl:模块功能的实现 **/ function define(name,deps,impl) &#123; //遍历依赖模块数组的每一项，从程序池中取出对应的模块,并赋值. //循环完后,deps由保存模块名的数组变成了保存对应模块的数组. for (var i=0;i&lt;deps.length;i++) &#123; deps[i]=modules[deps[i]]; &#125; //将新模块存储进模块池，并通过apply注入它所依赖的模块(即遍历后的deps,实际上就是用deps作为impl的入参) modules[name]=impl.apply(impl,deps); &#125; //从模块池中取出对应模块 function get (name) &#123; return modules[name]; &#125; //暴露定义模块和获取模块的两个api return &#123; define: define, get: get &#125;&#125;)() 说明: 后面书中说了这么一句为了模块的定义引入了包装函数(可以传入任何依赖),这里包装函数指的是Manger(),同样也是我们上节提到的模块函数.首先说明下什么是包装函数.例如函数A当中还有一个函数B.当我们想要调用函数B的时候,则需要先调用函数A.那么函数A就叫做函数B的包装函数.也就是说我们想调用某个模块时,需要先调用它的包装函数即这里的Manger().接着是后面那句并且将返回值，也就是模块的 API，储存在一个根据名字来管理的模块列表中。注意这里的返回值是指impl的返回值. 接着看通过管理器来定义和使用模块 123456789101112131415161718192021222324252627282930313233MyModules.define('bar',[],function () &#123; function hello (who) &#123; return "Let me introduce: " + who; &#125; //返回公共API 即提供一个hello的接口 return &#123; hello:hello &#125;;&#125;);MyModules.define('foo',['bar'],function (bar) &#123; var hungry = "hippo"; functin awesome () &#123; //这里的bar为返回模块bar返回的公共API console.log( bar.hello( hungry ).toUpperCase() ); &#125; //返回公共API 即提供一个awesome的接口 return &#123; awesome:awesome &#125;&#125;)var bar=MyModules.get('bar');//通过管理器获取模块'bar'var foo=MyModules.get('foo');//通过管理器获取模块'foo'console.log(//调用模块bar的hello接口 bar.hello( "hippo" ) ); // Let me introduce: hippo //调用模块foo的awesome接口foo.awesome(); // LET ME INTRODUCE: HIPPO 这节的主要内容还是了解现在是如何对模块进行一个规范处理.主要是两部分内容,一个是通过名称和依赖合理定义模块并储存.另一个则是通过名称对存储的模块的调用.其实还可以再增加一个删除模块的方法. 5.5.2 未来的模块机制ok,这节说的模块,就是我们常说的模块化开发.并且主要提到的就是ES6里常用的import.没什么好说的. 5.6 小结吐槽: 同一个函数概念在5.5这一个小节里,居然换着花样蹦出了三个名字!一会叫模块构造器!一会叫模块函数!以及最后的包装函数!每变化一次,都得想一遍它指的是啥!真的是无力吐槽了!!!! 闭包:当函数可以记住并访问所在的词法作用域，并且函数是在当前词法作用域之外执行，这时 就产生了闭包。 模块有两个主要特征: (1)为创建内部作用域而调用了一个包装函数(模块构造器的实例化,不想对频繁换名字吐槽了); (2)包装函数的返回值(也就是模块)必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。 第二部分第一章 关于this1.1 为什么要用this因为this 提供了一种更优雅的方式来隐式“传递”一个对象(即上下文对象)引用，因此可以将 API 设计得更加简洁并且易于复用。 1.2 误解下面两种常见的对于 this 的解释都是错误的(看看就好,就不过多解读了,以免增加了对错误的印象)。 1.2.1 指向自身人们很容易把 this 理解成指向函数自身. 具名函数，可以在它内部可以使用函数名来引用自身进行递归,添加属性等。(这个知识点其实在第三章提过,既然这里又提了一遍,我也再说一遍.)例如:123function foo() &#123; foo.count = 4; // foo 指向它自身&#125; 匿名函数如果想要调用自身则,需要使用arguments.callee不过这个属性在ES5严格模式下已经禁止了,也不建议使用.详情可以查看MDN的说明. 1.2.2 它的作用域切记: this 在任何情况下都不指向函数的词法作用域。你不能使用 this 来引用一个词法作用域内部的东西。 这部分只需记住这一段话就行. 终极疑问: JavaScript里的作用域到底是对象吗?这小节最令我在意的是里面这句话”在 JavaScript 内部，作用域确实和对象类似，可见的标识符都是它的属性。但是作用域“对象”无法通过 JavaScript代码访问，它存在于JavaScript 引擎内部。”它让我想起了最开始学JS的一个疑问,JavaScript里的作用域到底是对象吗.虽然”在JS里万物皆对象”.但是作用域给人的感觉却不像是一个对象.更像是一个范围,由函数的{}围城的范围,限制了其中变量的访问.但直觉告诉我它和对象还是应该有点联系的.直到读到书中的这段话,更加印证了我的感觉.在JavaScript里,作用域其实是一个比较特殊的对象,作用域里所有可见的标识符都是它的属性.只是作用域对象并不能通过JavaScript代码被我们访问,它只存在于JavaScript引擎内部.所以作用域作为一个”对象”是经常被我们忽略. 1.3 this到底是什么this 是在运行时(runtime)进行绑定的，并不是在编写时绑定，它的上下文(对象)取决于函数调用时的各种条件。this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。 当一个函数被调用时，会创建一个活动记录(有时候也称为执行上下文)。这个记录会包含函数在哪里被调用(调用栈)、函数的调用方法、传入的参数等信息。this 就是记录的其中一个属性，会在函数执行的过程中用到。(PS:所以this并不等价于执行上下文) 1.4 小结 学习 this 的第一步是明白 this 既不指向函数自身也不指向函数的词法作用域 this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用(关于this你必须记住的话)。 第二章 this全面解析2.1 调用位置通过上节我们知道,this的绑定与函数的调用位置有关.那调用位置是什么.调用位置就是函数在代码中被调用的位置(而不是声明的位置)。 要寻找调用位置,最重要的是要分析调用栈(就是为了到达当前执行位置所调用的所有函数)。我们关心的调用位置就在当前正在执行的函数的前一个调用中。PS:调用栈其实是一个解释起来有点复杂的概念.这里我就不过多解释,这里推荐一篇文章,解释得不错. 这节书里的例子解释得不错,这里就不复制代码了.其实分析调用栈只是为了在运行时找到我们关心的函数到底在哪里和被谁调用了. 但是实际别写代码时,其实并不会分析得这么清楚的,我们还是只需记住this的指向就是我们调用该函数的上下文对象.意思就是我们在哪里调用该函数,this就指向哪里.并且查看调用栈还可以通过浏览器的开发者工具,只需在疑惑的代码上一行加上debugger即可.浏览器在调试模式时,我们就可以在调用列表里查看调用栈.我们一般也仅在查找bug时,会使用该方法. 2.2 绑定规则在找到调用位置后,则需要判定代码属于下面四种绑定规则中的哪一种.然后才能对this进行绑定.注意: this绑定的是上下文对象,并不是函数自身也不是函数的词法作用域 2.2.1 默认绑定什么是独立函数调用:对函数直接使用而不带任何修饰的函数引用进行调用.简单点一个函数直接是func()这样调用,前面什么都没有.不同于通过对象属性调用例如obj.func(),也没有通过new关键字new Function();也没有通过apply,bind,call强制改变this指向.默认绑定: 当被用作独立函数调用时（不论这个函数在哪被调用,不管全局还是其他函数内），this默认指向到window；注意: 如果使用严格模式(strict mode)，那么全局对象将无法使用默认绑定，因此 this 会绑定到 undefined. 2.2.2 隐式绑定隐式绑定: 函数被某个对象拥有或者包含.也就是函数被作为对象的属性所引用.例如obj.func().此时this会绑定到该对象上.隐式丢失: 不管是通过函数别名或是将函数作为入参造成的隐式丢失.只需找到它真正的调用位置,并且函数前没有任何修饰也没有显式绑定(下节会讲到)(非严格模式下).那么this则会进行默认绑定,指向window.注意: 实际工作中,大部分this使用错误都是由对隐式丢失的不理解造成的.记住函数调用前没有任何修饰和显式绑定(其实就是call、apply、bind),this就指向window 2.2.3 显式绑定在分析隐式绑定时，我们必须在一个对象内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把 this 间接(隐式)绑定到这个对象上。如果我们不想在对象内部包含函数引用，而想在某个对象上强制调用函数，此时则需要显式绑定.显式绑定: 可以直接指定 this 的绑定对象，被称之为显式绑定。基本上就是我们常使用的call、apply、bind方法都是显式绑定.(如果这三个方法不能熟练使用的,建议找度娘或者谷娘学习后,再看这节.)注意:如果你传入了一个原始值(字符串类型、布尔类型或者数字类型)来当作 this 的绑定对 象，这个原始值会被转换成它的对象形式(也就是new String(..)、new Boolean(..)或者 new Number(..))。这通常被称为“装箱”。 硬绑定: 使用call、apply、bind方法强制显式地将this进行绑定,称之为硬绑定。硬绑定的典型应用场景就是创建一个包裹函数(其实就是常说的封装函数)，传入所有的参数并返回接收到的所有值.在封装函数中,我们常使用apply.一方面是因为它可以手动绑定this,更重要的是因为可以用apply的第二个参数,方便地注入所有传入的参数.例如之前提到的modules[name]=impl.apply(impl,deps).因为我们不知道传入的参数有多少个,但我们可以方便地使用一个deps将其全部注入.另一个常用的是foo.apply( null,argue)当我们将apply的第一个参数设置为null时,此时this就会默认绑定到window.切记使用这种用法时确保函数foo内没有使用this. 否则很可能会造成全局污染.如果是第三方库的函数就建议不要使用了,因为你不知道别人的函数是否使用了this(关于这部分内容,下节会继续提到).还有一种常用就是foo.call( this).这样foo里的this都会指向当前调用的上下文环境. API调用的“上下文”: 第三方库的许多函数，以及 JavaScript 语言和宿主环境中许多新的内置函数，都提供了一个可选的参数，通常被称为“上下文”(context)，其作用和 bind(..) 一样，确保你的回调函数使用指定的 this。 2.2.4 new绑定JavaScript 中 new 的机制实际上和面向类的语言完全不同。在 JavaScript 中，构造函数只是一些 使用 new 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上， 它们甚至都不能说是一种特殊的函数类型，它们只是被 new 操作符调用的普通函数而已。实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”。 使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。 1,创建(或者说构造)一个全新的对象。 2,这个新对象会被执行[[原型]]连接。 3,这个新对象会绑定到函数调用的this。 4,如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。 示例:12345function foo(a) &#123; this.a = a;&#125;var bar = new foo(2); console.log( bar.a ); // 2 使用 new 来调用 foo(..) 时，我们会构造一个新对象并把它绑定到 foo(..) 调用中的 this 上。说明:对于上面这句话进行解释下,如果在一个函数前面带上 new 关键字来调用， 那么背地里将会创建一个连接到该函数的 prototype 的新对象，this就指向这个新对象； 2.3 优先级直接上结论:new绑定=显示绑定&gt;隐式绑定&gt;默认绑定说明: new绑定与显示绑定是不能直接进行测试比较,但通过分析发现new绑定内部其实是使用了硬绑定(显示绑定的一种),所以new绑定和显示绑定优先级应该差不多.但话说回来,一般实际使用时,不会这种复杂的交错绑定.所以只需记住下面的判定即可. 判断this:现在我们可以根据优先级来判断函数在某个调用位置应用的是哪条规则。可以按照下面的顺序来进行判断: 1,函数是否在new中调用(new绑定)?如果是的话this绑定的是新创建的对象。 var bar = new foo() 2,函数是否通过call、apply(显式绑定)或者硬绑定调用?如果是的话，this绑定的是 指定的对象。var bar = foo.call(obj2) 3,函数是否在某个上下文对象中调用(隐式绑定)?如果是的话，this 绑定的是那个上 下文对象。var bar = obj1.foo() 4,如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到 全局对象。var bar = foo()就是这样。对于正常的函数调用来说，理解了这些知识你就可以明白 this 的绑定原理了。 2.4 绑定例外2.4.1 被忽略的this如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值在调用时会被忽略，实际应用的是默认绑定规则,this会绑定到window上.使用情景:一种非常常见的做法是使用 apply(..) 来“展开”一个数组(也可以用来方便地参数注入)，并当作参数传入一个函数。类似地，bind(..) 可以对参数进行柯里化(预先设置一些参数).通过自带bind方法实现柯里化是很方便的,比自己写要简化好多. 注意: 在 ES6 中，可以用 … 操作符代替 apply(..) 来“展 开”数组，foo(…[1,2]) 和 foo(1,2)是一样的，这样可以避免不必要的 this 绑定。可惜，在 ES6 中没有柯里化的相关语法，因此还是需要使用 bind(..)。 当使用null或者undefined进行绑定时,要确保该函数内没有使用this,否则此时很容易对全局变量造成破坏!尤其是使用第三方库的方法! 更安全的this如果函数内使用了this,直接使用null则可能会对全局造成破坏.因此我们可以通过创建一个“DMZ”(demilitarized zone，非军事区)对象——它就是一个空的非委托的对象(委托在第 5 章和第 6 章介绍)。让this绑定到这个”DMZ上.这样就不会对全局造成破坏.怎么创建DMZ呢.就是通过Object.create(null) 创建一个空对象.这种方法和 {} 很像，但是并不会创建 Object.prototype 这个委托，所以它比 {}“更空”更加安全. PS:实际使用一般不会遇到这种情况(也可能是我太菜,没遇到),如果函数内有this,那肯定是有需要调用的变量或函数,直接把它绑定到一个空对象上.那什么都取不到,还有什么意义?所以函数没有this就传入null.如果有this就把它绑定到真正需要它的对象上,而不是一个空对象上.这些是我自己的见解,如果有不妥的,欢迎留言指正. 2.4.2 间接引用12345678function foo() &#123; console.log( this.a );&#125;var a = 2;var o = &#123; a: 3, foo: foo &#125;; var p = &#123; a: 4 &#125;;o.foo(); // 3(p.foo = o.foo)(); // 2 其实就是foo() 此时this默认绑定到window 例子中的间接引用其实是对函数的理解不深造成的.其实(p.foo = o.foo)()就是(foo)(),这样就是全局调用foo()所以this默认就绑定到了window上.注意:对于默认绑定来说，决定 this 绑定对象的并不是调用位置是否处于严格模式，而是 函数体是否处于严格模式。如果函数体处于严格模式，this 会被绑定到 undefined，否则 this 会被绑定到全局对象。(对于这段话其实在2.2.1节就应该说了!) 2.4.3 软绑定硬绑定会大大降低函数的灵活性，使用硬绑定之后就无法使用隐式绑定或者显式绑定来修改 this。这时候则需要使用软绑定.Tips: 这里给的软绑定方法还是挺好的.但是建议还是在自己的代码里使用,并注释清除.以免别人使用,对this错误的判断. 2.5 this词法 ES6 中介绍了一种无法使用上面四条规则的特殊函数类型:箭头函数。 箭头函数不使用 this 的四种标准规则，而是根据外层(函数或者全局)作用域来决定 this。(而传统的this与函数作用域没有任何关系,它只与调用位置的上下文对象有关.这点在本章开头就已经反复强调了.) 重要: 箭头函数最常用于回调函数中，例如事件处理器或者定时器. 箭头函数可以像 bind(..) 一样确保函数的 this 被绑定到指定对象 箭头函数用更常见的词法作用域取代了传统的 this 机制。 注意: 这种情况:1234567891011function module() &#123; return this.x;&#125;var foo = &#123; x: 99, bar:module.bind(this) //此时bind绑定的this为window. &#125;var x="window"console.log(foo.bar())//window 在 ES6 之前我们就已经在使用一种几乎和箭头函数完全一样的模式:12345678910function foo() &#123;var self = this; // lexical capture of this setTimeout( function()&#123; console.log( self.a ); &#125;, 100 ); &#125;var obj = &#123; a: 2&#125;;foo.call( obj ); // 2 虽然 self = this 和箭头函数看起来都可以取代 bind(..)，但是从本质上来说，它们想替代的是 this 机制。(的确是这样,我一般会用me替代self.因为少两个单词=.=) 关于this的编码规范建议: 只使用词法作用域并完全抛弃错误this风格的代码; 完全采用 this 风格，在必要时使用 bind(..)，尽量避免使用 self = this 和箭头函数。 在自己实际工作中,其实是两种混用的,绝大部分情况下都会使用词法作用域风格.因为有时候你真的很难做到完全统一.我现在的习惯是,在写任何函数时,开头第一个就是var me =this;这样在看到函数第一眼,就知道:哦,这个函数是用词法作用域风格的.尤其函数内涉及到回调.这样就避免了写着写着发现this绑定到其他地方去了,一个函数里面this不统一的情况. 2.6 小结(这里总结得很好,我就全部copy了)如果要判断一个运行中函数的 this 绑定，就需要找到这个函数的直接调用位置。找到之后就可以顺序应用下面这四条规则来判断 this 的绑定对象。 由new调用?绑定到新创建的对象。 由call或者apply(或者bind)调用?绑定到指定的对象。 由上下文对象调用?绑定到那个上下文对象。 默认:在严格模式下绑定到undefined，否则绑定到全局对象。 一定要注意，有些调用可能在无意中使用默认绑定规则。如果想“更安全”地忽略 this 绑定，你可以使用一个 DMZ 对象，比如 ø = Object.create(null)，以保护全局对象。 ES6 中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定 this，具体来说，箭头函数会继承外层函数调用的 this 绑定(无论 this 绑定到什么)。这其实和 ES6 之前代码中的 self = this 机制一样。 特别注意: 其中最需要注意的就是当你使用jquery或vue时,此时this是被动态绑定了的.大多数 jQuery 方法将 this 设置为已选择的 dom 元素。使用 Vue.js时，则方法和计算函数通常将 this 设置为 Vue 组件实例。vue文档中所有的生命周期钩子自动绑定 this 上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着你不能使用箭头函数来定义一个生命周期方法 (例如 created: () =&gt; this.fetchTodos())。这是因为箭头函数绑定了父上下文，因此 this 与你期待的 Vue 实例不同，this.fetchTodos 的行为未定义。 也包括使用第三方ajax时,例如axios.解决方法也很简单,要么使用传统的function或者使用let _this=this进行接管.其实当你使用vue时,你默认的思想就是this指的就是vue实例.所以除了钩子函数和axios里会有点影响外,其余还好. PS 这里再补充说明上下文(对象)与函数作用域的区别于联系: 上下文： 可以理解为一个对象，所有的变量都储存在里面.上下文环境是在函数被调用并被引擎执行时创建的.如果你没调用,那么就没有上下文. 作用域： 除了全局作用域，只有函数和ES6新增的let,const才能创建作用域.创建一个函数就创建了一个作用域，无论你调用不调用，函数只要创建了，它就有独立的作用域.作用域控制着被调用函数中的变量访问. 两者: 作用域是基于函数的，而上下文是基于对象的。作用域涉及到所被调用函数中的变量访问，并且不同的调用场景是不一样的。上下文始终是this关键字有关， 它控制着this的引用。一个作用域下可能包含多个上下文。有可能从来没有过上下文（函数没有被调用）；有可能有过，现在函数被调用完毕后，上下文环境被销毁了(垃圾回收)；有可能同时存在一个或多个（闭包）。 第三章 对象3.1 语法对象可以通过两种形式定义:声明(文字)形式(就是常说的对象字面量)和构造形式。 声明形式(对象字面量):1234 var myObj = &#123; key: value // ... &#125;; 构造形式:12var myObj = new Object(); myObj.key = value; 构造形式和文字形式生成的对象是一样的。唯一的区别是，在文字声明中你可以添加多个 键 / 值对，但是在构造形式中你必须逐个添加属性。PS:其实我们绝大部分情况下都是使用对象字面量形式创建对象. 3.2 类型在JavaScript中一共有6中主要类型(术语是”语言类型”) string number boolean null undefined object 简单数据类型:其中string、boolean、number、null 和 undefined属于简单基本类型,并不属于对象.null 有时会被当作一种对象类型，但是这其实只是语言本身的一个 bug，即对 null 执行typeof null 时会返回字符串 “object”。实际上，null 本身是基本类型。PS: 原因是这样的，不同的对象在底层都表示为二进制，在 JavaScript 中二进制前三位都为 0 的话会被判 断为 object 类型，null 的二进制表示是全 0，自然前三位也是 0，所以执行 typeof 时会返回“object”。 对象:对象除了我们自己手动创建的,JavaScript其实内置了很多对象,也可以说是对象的一个子类型.内置对象: String Number Boolean Object Function Array Date RegExp Error 在 JavaScript 中，这些内置对象实际上只是一些内置函数。这些内置函数可以当作构造函数(由 new 产生的函数调用——参见第 2 章)来使用.几点说明: 函数就是对象的一个子类型(从技术角度来说就是“可调用的对象”)。JavaScript 中的函数是“一等公民”，因为它们本质上和普通的对象一样(只是可以调用)，所以可以像操作其他对象一样操作函数(比如当作另一个函数的参数)。 通过字面量形式创建字符串,数字,布尔时,引擎会自动把字面量转换成 String 对象,Number对象,Boolean对象，所以它们是可以访对应对象内置的问属性和方法。 null 和 undefined 没有对应的构造形式，它们只有文字形式。相反，Date 只有构造，没有文字形式。 对于 Object、Array、Function 和 RegExp(正则表达式)来说，无论使用文字形式还是构造形式，它们都是对象，不是字面量(这是肯定的,因为不管哪种形式一创建出来就是对象类型,不可能是其他类型,实际上是不存在字面量这一说的)。但是使用构造形式可以提供一些额外选项(内置)。 Error 对象很少在代码中显式创建，一般是在抛出异常时被自动创建。也可以使用 new Error(..) 这种构造形式来创建，不过一般来说用不着。 3.3 内容对象属性:由一些存储在特定命名位置的(任意类型的)值.属性名:存储在对象容器内部的属性的名称.属性值并不会存在对象内.而是通过属性名(就像指针,从技术角度来说就是引用)来指向这些值真正的存储位置(就像房门号一样).属性名的两种形式: 使用.操作符.也是我们最常用的形式.它通常被称为”属性访问”. . 操作符会要求属性名满足标识符的命名规范. 使用[&quot;..&quot;]语法进行访问.这个通常被称为”键访问”.[&quot;..&quot;]语法可以接受任意UTF-8/Unicode 字符串作为属性名。并且[&quot;..&quot;]语法使用字符串来访问属性,如果你的属性名是一个变量,则可以使用书中的例子myObject[idx]形式进行访问.这也是最常使用”键访问”的情况.但如果idx是属性名则还是需写成myObject[&quot;idx&quot;]字符串形式. 注意: 在对象中，属性名永远都是字符串。如果你使用 string(字面量)以外的其他值作为属性 名，那它首先会被转换为一个字符串。即使是数字也不例外，虽然在数组下标中使用的的 确是数字，但是在对象属性名中数字会被转换成字符串 . 补充: 这里我在书中的例子基础上进行了修改,得到这个例子:123456789var myObject = &#123; a:2, idx:111&#125;;var idx="a";console.log( myObject[idx] ); //2console.log( myObject["idx"] ); //111console.log( myObject[this.idx] ); // 2 此时this是指向window.[]里的this同样符合上一章所讲的规则//结果是否和你所想得一样呢? 3.3.1 可计算属性名ES6 增加了可计算属性名，可以在文字形式中使用 [] 包裹一个表达式来当作属性名:12345678var prefix = "foo";var myObject = &#123; [prefix + "bar"]:"hello", [prefix + "baz"]: "world"&#125;;myObject["foobar"]; // hellomyObject["foobaz"]; // world 3.3.2 属性与方法 我们经常把对象内部引用的函数称为“方法”(的确如此). 实际上函数并不属于该对象,它不过是对函数的引用罢了.对象属性访问返回的函数和其他函数没有任何区别(除了可能发生的隐式绑定this到该对象)。 即使你在对象的文字形式中声明一个函数表达式，这个函数也不会“属于”这个对象—— 它们只是对于相同函数对象的多个引用。 3.3.3 数组 数组支持[]形式访问储存的值,其中[]内的值默认形式为数值下标(为从0开始的整数,也就是常说的索引).例如myArray[0] 数组也是对象，所以虽然每个下标都是整数，你仍然可以给数组添加属性.例如myArray.baz = &quot;baz&quot;.注意:添加新属性后,虽然可以访问,但数组的 length 值不会改变. 数组可以通过myArray[1]=11;myArray[&quot;2&quot;]=22;这种形式对数组内容进行修改,添加. 虽然数组也可以和对象一样通过键/值 对 形式来使用.但JS已经对数组的行为和用途进行了优化.所以还是建议使用默认的下标/值 对 形式来使用. 3.3.4 复制对象 复制分为浅拷贝和深拷贝.浅拷贝会对对象中的基本数据类型进行复制(在内存中开辟新的区域),对于对象则是继续引用.而不是重新创建一个”一样的”对象.深拷贝则是对其中的所有内(容包括对象)进行深层次的复制. 一般情况下我们可以通过JSON来复制对象.var newObj = JSON.parse( JSON.stringify( someObj ) );.但需要指出的是这种方法对于包含function函数或者Date类型的对象则不管用! ES6 定义了 Object.assign(..) 方法来实现浅复制。具体用法在这就不赘述了. 3.3.5 属性描述符从 ES5 开始，所有的属性都具备了属性描述符。 查看属性描述符: 可以使用Object.getOwnPropertyDescriptor( myObject, “a” );方法查看myObject对象里属性a的属性描述符. 配置属性描述符: 可以使用Object.defineProperty(..)方法对属性的属性描述符就像配置.举个例子:123456789 var myObject = &#123;&#125;;Object.defineProperty( myObject, "a", &#123; value: 2, writable: true, configurable: true, enumerable: true &#125; );myObject.a; // 2//该方法可以配置四个属性描述符 注意: 书中关于属性描述符也被称为“数据描述符”其实是不够准确的.对象里目前存在的属性描述符有两种主要形式：数据描述符和存取描述符。数据描述符是一个具有值的属性，该值可能是可写的，也可能不是可写的。存取描述符是由getter和setter函数对描述的属性。描述符必须是这两种形式之一；不能同时是两者。(getter和setter是后面马上要讲到的两个描述符)它们的关系如下:(详情可以查看MDN的解释) configurable enumerable value writable get set 数据描述符 Yes Yes Yes Yes No No 存取描述符 Yes Yes No No Yes Yes 如果一个描述符不具有value,writable,get 和 set 任意一个关键字，那么它将被认为是一个数据描述符。如果一个描述符同时有(value或writable)和(get或set)关键字，将会产生一个异常。 value就是该属性对应的值。默认为 undefined。下面分别介绍剩下的三个属性描述符键值: 1. Writable 决定是否可以修改属性的值。当被设置为false后,再对属性值进行修改,则会静默失败(silently failed,修改不成功,也不报错)了。如果在严格模式下，则会报出TypeError错误. 2. Configurable 决定属性描述符是否可配置.如果为true,就可以使用 defineProperty(..) 方法来修改属性描述符.注意:不管是不是处于严格模式，修改一个不可配置的属性描述符都会出错。并且把 configurable 修改成 false 是单向操作，无法撤销! 但是有个例外即便属性是 configurable:false，我们还是可以 把 writable 的状态由 true 改为 false，但是无法由 false 改为 true。除了无法修改，configurable:false 还会禁止删除这个属性. 3. Enumerable 决定该属性是否会出现在对象的属性枚举中.比如说 for..in 循环。如果把 enumerable 设置成 false，这个属性就不会出现在枚举中，虽然仍然可以正常访问它。相对地，设置成 true 就会让它出现在枚举中。 3.3.6 不变性除了上面提到的Object.defineProperty(..),ES5还可以通过很多种方法来实现属性或者对象的不可变.注意: 这些所有方法都是只能浅不变,如果目标对象引用了其他对象(数组、对象、函数，等)，其他对象的内容不受影响，仍然是可变的.类似于浅拷贝. 说明: 在 JavaScript 程序中很少需要深不可变性。 有些特殊情况可能需要这样做，但是根据通用的设计模式，如果你发现需要密封或者冻结所有的对象，那你或许应当退一步，重新思考一下程序的设计，让它能更好地应对对象值的改变。 方法: 1. 对象常量(不可改) 结合 writable:false 和 configurable:false 就可以创建一个真正的常量属性(不可修改、重定义或者删除) 2. 禁止扩展(不可增) 使用 Object.prevent Extensions(myObject),可以禁止一个对象添加新属性并且保留已有属性.在非严格模式下，创建属性 b 会静默失败。在严格模式下，将会抛出 TypeError 错误。 3. 密封(不可配置,但可修改) 使用Object.seal(..) 会创建一个“密封”的对象，这个方法实际上会在一个现有对象上调用Object.preventExtensions(..) 并把所有现有属性标记为 configurable:false。密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性(虽然可以修改属性的值)。 4. 冻结(不可配置,也不可修改) Object.freeze(..) 会创建一个冻结对象，这个方法实际上会在一个现有对象上调用 Object.seal(..) 并把所有“数据访问”属性标记为 writable:false，这样就无法修改它们的值。这个方法是你可以应用在对象上的级别最高的不可变性，它会禁止对于对象本身及其任意直接属性的修改(不过就像我们之前说过的，这个对象引用的其他对象是不受影响的)。 注意: 你可以“深度冻结”一个对象(连引用的对象也冻结)，具体方法为，首先在这个对象上调用 Object.freeze(..)， 然后遍历它引用的所有对象并在这些对象上调用 Object.freeze(..)。但是一定要谨慎!因为你引用的对象可能会在其他地发也被引用. 说明: 在 JavaScript 程序中很少需要深不可变性。有些特殊情况可能需要这样做， 但是根据通用的设计模式，如果你发现需要密封或者冻结所有的对象，那你或许应当退一步，重新思考一下程序的设计，让它能更好地应对对象值的改变。 3.3.7 [[Get]]1234var myObject = &#123; a: 2&#125;;myObject.a; // 2 myObject.a是怎么取到值2的?myObject.a 通过对象默认内置的[[Get]] 操作(有点像函数调用:[Get]).首先它会在对象中查找是否有名称相同的属性， 如果找到就会返回这个属性的值。如果没有找到名称相同的属性，按照 [[Get]] 算法的定义会执行另外一种非常重要的行为。其实就是遍历可能存在的 [[Prototype]] 链，也就是在原型链上寻找该属性。如果仍然都没有找到名称相同的属性，那 [[Get]] 操作会返回值 undefined. 注意: 如果你引用了一个当前词法作用域中不存在的变量，并不会像对象属性一样返回 undefined，而是会抛出一个 ReferenceError 异常. 3.3.8 [[Put]]既然有可以获取属性值的 [[Get]] 操作，就一定有对应的 [[Put]] 来设置或者创建属性. [[Put]] 被触发时的操作分为两个情况:1. 对象中已经存在这个属性 2. 对象中不存在这个属性. 如果对象中已经存在这个属性,[[Put]] 算法大致会检查下面这些内容: 属性是否是访问描述符(参见下一节)?如果是并且存在setter就调用setter。 属性的数据描述符中writable是否是false?如果是，在非严格模式下静默失败，在严格模式下抛出 TypeError 异常。 如果都不是，将该值设置为属性的值。 如果对象中不存在这个属性，[[Put]] 操作会更加复杂。会在第 5 章讨论 [[Prototype]] 时详细进行介绍。 3.3.9 Getter和Setter对象默认的 [[Put]] 和 [[Get]] 操作分别可以控制属性值的设置和获取。目前我们还无法操作[[Get]] 和 [[Put]]来改写整个对象 ,但是在ES5中可以使用 getter 和 setter 改写部分默认操作,只能应用在单个属性上，无法应用在整个对象上。 注意: 书中后面说的访问描述符就是存取描述符.关于属性描述符,存取描述符及数据描述符可以查看MDN的解释) getter:getter 是一个隐藏函数，会在获取属性值时调用。同时会覆盖该单个属性默认的 [[Get]]操作.当你设置getter时,不能同时再设置value或writable,否则就会产生一个异常.并且当你设置getter或setter时,JavaScript 会忽略它们的 value 和 writable 特性. 语法: {get prop() { ... } }或{get [expression]() { ... } }.其中prop:要设置的属性名. expression:从 ECMAScript 2015 开始可以使用计算属性名.使用方式:123456789101112131415161718192021222324var myObject = &#123; a: 1111, //在后面会发现myObject.a为2,这是因为设置了getter所以忽略了value特性. //方式一:在新对象初始化时定义一个getter get a() &#123; return 2 &#125;&#125;;Object.defineProperty( myObject, // 目标对象 "b", // 属性名 &#123; // 方式二:使用defineProperty在现有对象上定义 getter get: function()&#123; return this.a * 2 &#125;, // 确保 b 会出现在对象的属性列表中 enumerable: true &#125;);myObject.a = 3; //因为设置了getter所以忽略了writable特性.所以这里赋值没成功myObject.a; // 2myObject.b; // 4delete myObject.a;//可以使用delete操作符删除 setter:setter 是一个隐藏函数，会在获取属性值时调用。同时会覆盖该单个属性默认的 [[Put]]操作(也就是赋值操作).当你设置setter时,不能同时再设置value或writable,否则就会产生一个异常.并且当你设置getter或setter时,JavaScript 会忽略它们的 value 和 writable 特性. 语法: {set prop(val) { . . . }}或{set [expression](val) { . . . }}.其中prop:要设置的属性名. val:用于保存尝试分配给prop的值的变量的一个别名。expression:从 ECMAScript 2015 开始可以使用计算属性名.使用方式:1234567891011121314151617181920212223242526272829303132var myObject = &#123; //注意:通常来说 getter 和 setter 是成对出现的(只定义一个的话 通常会产生意料之外的行为): //方式一:在新对象初始化时定义一个setter set a(val) &#123; this._a_ = val * 2 &#125;, get a() &#123; return this._a_ &#125;&#125;;Object.defineProperty( myObject, // 目标对象 "b", // 属性名 &#123; set: function(val)&#123; this._b_ = val * 3 &#125;, // 方式二:使用defineProperty在现有对象上定义 setter get: function()&#123; return this._b_ &#125;, // 确保 b 会出现在对象的属性列表中 enumerable: true &#125;);myObject.a = 2; myObject.b = 3; console.log(myObject.a); //4console.log(myObject.b);//9console.log(myObject._a_);//4console.log(myObject._b_);//9delete myObject.a;//可以使用delete操作符删除 3.3.10 存在性属性存在性:如何判断一个对象是否存在某个属性(准确来说是检查这个属性名是否存在),这时就需要用到: in操作符in 操作符会检查属性是否在对象及其 [[Prototype]] 原型链中(参见第 5 章)。 hasOwnProperty(..)hasOwnProperty(..) 只会检查属性是否在 myObject 对象中，不会检查 [[Prototype]] 链。 注意: 1.如果有的对象可能没有连接到 Object.prototype( 通过Object. create(null) 来创建——参见第 5 章)。在这种情况下，形如myObejct.hasOwnProperty(..) 就会失败。这时可以使用一种更加强硬的方法来进行判断:Object.prototype.hasOwnProperty. call(myObject,”a”)，它借用基础的 hasOwnProperty(..) 方法并把它显式绑定(参见第2章)到 myObject 上。 2.对于数组来说,不要使用in操作符,因为它检查的是属性名,在数组中属性名就是索引,它并不是我们所关注的重点.对于数组我们更关注的是它所存的值,所以对于数组检查某个值是否存在还是采用indexOf方法. 属性可枚举性:如果一个属性存在,且它的enumerable 属性描述符为true时.则它是可枚举的.并且可以被for..in 循环.一个属性不仅仅需要存在,还需要它的enumerable 为true才是可枚举的,才能被for…in遍历到.注意: for…in不适合对数组进行遍历,对数组的遍历还是使用传统的for循环. 对属性的可枚举性判断,则需要用到以下几种方法: propertyIsEnumerable(..) 会检查给定的属性名是否直接存在于对象中(而不是在原型链上)并且满足 enumerable:true。 Object.keys(..) 会返回一个数组，包含所有可枚举属性. Object.getOwnPropertyNames(..)会返回一个数组，包含所有属性，无论它们是否可枚举。 3.4 遍历关于这节我觉得还是以理清for..in和for..of为主.后面延伸的@@iterator及Symbol.iterator的使用,没必要过于深究.注意书中123页第二行done 是一个布尔值，表示是否还有可以遍历的值。有个错误,应该改成done 是一个布尔值，表示遍历是否结束。否则你在看后面它的说明时会感觉到自相矛盾.这里我也是以for..in和for..of为主进行说明,也更贴近我们实际使用. for..in for..in 循环可以用来遍历对象的可枚举属性列表(包括 [[Prototype]] 链)。 实际上for..in遍历的并不是属性值,而是属性名(即键名 key).所以你想获取属性值还是需要手动使用obj[key]来获取. 一般在遍历对象时,推荐使用for..in.当然数组也是可以使用for..in的.在遍历数组时,推荐还是使用for..of. for..of ES6 增加了一种用来遍历数组的 for..of 循环语法(如果对象本身定义了迭代器的话也可以遍历对象) for..of与for..in最大的不同点是,它循环的是属性值,而不是属性名.不过它只循环数组里存放的值,不会涉及到对象里的key.(关于这个我后面的例子里会说具体对比明的) for..of 循环首先会向被访问对象请求一个迭代器对象，然后通过调用迭代器对象的next() 方法来遍历所有返回值。数组有内置的 @@iterator，(对象没有,所以不能使用for..of,除非我们自己定义一个)因此 for..of 可以直接应用在数组上。 例子比较1234567891011let arr = ['shotCat',111,&#123;a:'1',b:'2'&#125;]arr.say="IG niu pi!"//使用for..in循环for(let index in arr)&#123; console.log(arr[index]);//shotCat 111 &#123;a:'1',b:'2'&#125; IG niu pi!&#125;//使用for..of循环for(var value of arr)&#123; console.log(value);//shotCat 111 &#123;a:'1',b:'2'&#125;&#125;//注意 for..of并没有遍历得到` IG niu pi!`.原因我前面说过`它只循环数组里存放的值,不会涉及到对象里的key.`更不用说 [[Prototype]] 链.(for..in则会) 如何让对象也能使用for..of ?你可以选择使用书中的自己通过Object.defineProperty()定义一个Symbol.iterator属性来实现.这里我就不赘述了.也是最接近原生使用感受的.不过我这里要介绍一个稍微简单点的方法来实现.就是使用上节讲到的Object.keys()搭配使用.举个例子:12345678910111213var shotCat=&#123; name:'shotCat', age:'forever18', info:&#123; sex:'true man', city:'wuhan', girlFriend:'新垣结衣!' &#125;&#125;for(var key of Object.keys(shotCat))&#123; //使用Object.keys()方法获取对象key的数组 console.log(key+": "+shotCat[key]);&#125; 3.5 小结书中小结总结得挺全的,这里我就搬运下 JavaScript 中的对象有字面形式(比如 var a = { .. })和构造形式(比如 var a = new Array(..))。字面形式更常用，不过有时候构造形式可以提供更多选项。 对象是 6 个(或者是 7 个，取决于你的观点)基础类型之一。对象有包括 function 在内的子类型，不同子类型具有不同的行为，比如内部标签 [object Array] 表示这是对象的子类型数组。 对象就是键 / 值对的集合。可以通过 .propName 或者 [“propName”] 语法来获取属性值。访问属性时，引擎实际上会调用内部的默认 [[Get]] 操作(在设置属性值时是 [[Put]])， [[Get]] 操作会检查对象本身是否包含这个属性，如果没找到的话它还会查找 [[Prototype]] 链(参见第 5 章)。 属性的特性可以通过属性描述符来控制，比如 writable 和 configurable。此外，可以使用 Object.preventExtensions(..)、Object.seal(..) 和 Object.freeze(..) 来设置对象(及其属性)的不可变性级别。 属性不一定包含值——它们可能是具备 getter/setter 的“访问描述符”。此外，属性可以是可枚举或者不可枚举的，这决定了它们是否会出现在 for..in 循环中。 可以使用 ES6 的 for..of 语法来遍历数据结构(数组、对象，等等)中的值，for..of 会寻找内置或者自定义的 @@iterator 对象并调用它的 next() 方法来遍历数据值。 第四章 混合对象”类”注意: 正如书中提示的那样,整章一半以上几乎都是讲面向对象和类的概念.会读得人云里雾里,给人哦,也许大概就是这样子的感觉.后面我还是会对那些抽象的概念找到在JavaScript里对应的”立足点”,不至于对这些概念太”飘”. 4.1 类理论说明: 类其是描述了一种代码的组织结构形式. 在js中类常见的就是构造函数,也可以是通过ES6提供的class关键字;继承就是函数;实例化就是对象,常见的就是通过new构造函数实现的. 注意: Javascript语言不支持“类”，所谓的”类”也是模拟出的“类”。即使是ES6引入的”类”实质上也是 JavaScript 现有的基于原型的继承的语法糖。 4.1.1 “类”设计模式一句话:类其实也是一种设计模式! 类并不是必须的编程基础,而是一种可选的代码抽象. 有些语言(比如 Java)并不会给你选择的机会，类并不是可选的——万物皆是类。 其他语言(比如 C/C++ 或者 PHP)会提供过程化和面向类这两种语法，开发者可以选择其中一种风格或者混用两种风格。 4.1.2 JavaScript中的“类”JavaScript 只有一些近似类的语法元素 (比如 new 和 instanceof)，不过在后来的 ES6 中新增了一些元素，比如 class 关键字,其实质上也是 JavaScript 现有的基于原型的继承的语法糖。也不是真正的类. 4.2 类的机制这部分书中的描述,我理解起来也比较费劲,主要是它提到的栈,堆与我理解中内存里的栈,堆相冲突了.这里简单说下我的理解,如有误,感激指正. stack类其实是一种数据结构.它可以储存数据,并提供一些公用的方法(这和上面提到的类很相似).但是stack类其实只是一个抽象的表示,你想对它进行操作,就需要先对它进行实例化. 4.2.1 建造这节主要就是说明”类”和”实例”的关系.在JavaScript里”类”主要是构造函数,”实例”就是对象. 一个类就像一张蓝图。为了获得真正可以交互的对象，我们必须按照类来实例化一个东西，这个东西(对象)通常被称为实例，有需要的话，我们可以直接在实例上调用方法并访问其所有公有数据属性。 总而言之:类通过实例化得到实例对象. 4.2.2 构造函数 类实例是由一个特殊的类方法构造的，这个方法名通常和类名相同，被称为构造函数。 实例就是由构造函数实例化的: new 构造函数. 构造函数大多需要用 new 来调，这样语言引擎才知道你想要构造一个新的类实例。 构造函数会返回一个对象,这个对象就是实例.这个对象可以调用类的方法. 4.3 类的继承在面向类的语言中，你可以先定义一个类，然后定义一个继承前者的类。后者通常被称为“子类”，前者通常被称为“父类”。子类可以继承父类的行为,并且可以根据自己的需求,修改继承的行为(一般并不会修改父类的行为).注意:我们讨论的父类和子类并不是实例,在JavaScript里类一般都是构造函数。 4.3.1 多态大概你看了它的”解释”,对多态还是懵懵懂懂.这里我再解释下:什么是多态?同一个操作，作用于不同的对象，会产生不同的结果。发出一个相同的指令后，不同的对象会对这个指令有不同的反应，故称为多态。说明: 书中例子中的inherited其实就是相当于super.并且注意书中的这些例子都是伪代码! 并不是真的在JavaScript里就是这样实现的.补充:这里是关于super的mdn链接. 多态: 相对性: 其实相对性就是子类相对于父类的引用(例如使用super实现引用),并且子类对父类的引用并不会对父类的行为造成任何影响(并不会对父类自身的行为进行重新定义),例如书中例子子类对drive()的引用. 可重复定义: 子类继承父类的某个方法,并可以对这个方法进行再次定义,例如书中子类对drive()中的output进行修改.当调用方法时会自动选择合适的定义,这句话怎么理解,当子类实例化后,执行drive()方法时,它并不会直接去执行父类的drive().而是子类上的drive().简单来说就是实例来源于那个类,它就使用那个类的方法. 说明: 在 JavaScript 中“类”是属于构造函数的(类似 Foo.prototype… 这样的类型引用)。由于 JavaScript中父类和子类的关系只存在于两者构造函数对应的 .prototype 对象中，因此它们的构造函数之间并不存在直接联系，从而无法简单地实现两者的相对引用(在 ES6 的类中可以通过 super来“解决”这个问题，参见附录 A)。 多态并不表示子类和父类有关联，子类得到的只是父类的一份副本。类的继承其实就是复制。 其实这里讨论的这些概念其实在我们实际工作中,已经使用了无数次,只是现在你需要理解”原来你是叫这个名字啊!” 4.3.2 多重继承多重继承: 一个子类可以继承来自多个父类的方法.多重继承引发的问题: 多重继承可能会出现,多个父类中方法名冲突的问题,这样子类到底引用哪个方法?多重继承与JavaScript: JavaScript本身并没有提供多重继承功能.但它可以通过其他方法来达到多重继承的效果. 4.4 混入JavaScript 中只有对象，并不存在可以被实例化的“类”。一个对象并不会被复制到其他对象，它们会被关联起来(参见第 5 章)(其实就是引用,所以它的多态是”相对”的)。由于在其他语言中类表现出来的都是复制行为，因此 JavaScript 开发者也想出了一个方法来模拟类的复制行为，这个方法就是混入(就是通过混入来模拟实现类的多重继承)。 4.4.1 显式混入郑重提醒: 书中这里的类都是对象形式的.例子里的sourceObj, targetObj,这就可能造成一个”误导”,在JavaScript里是没有真正的类,所谓的类也不过是我们模拟出来的”类”,不过是一种语法糖(包括ES6里的class).在JavaScript里”所谓的类”经常是一个构造函数,你并不能这样进行遍历,只能对它的实例对象进行这种操作.不要被书中例子带进去了,不要混淆,毕竟我们最终使用的是JavaScript(而不是其他面向对象的语言.),它里面的类常常并不是一个对象! 显式混入: 书中没有给出明确的显式混入的定义,但是读完整章.基本就知道什么是显式混入了.显式混入就是通过类似mixin()方法,显式地将父对象属性逐一复制,或者有选择地复制(即例子中的存在性检查)到子对象上. 显式混入常用方法: 就是书中的例子, 首先有子对象,并对其进行特殊化(定义自己的属性或方法).然后再通过mixin()方法将父对象有选择地复制(即存在性检查,过滤子对象已有的属性,避免冲突)到子对象上. 显式混入注意点:显式混入时,切记一点你要避免父对象的属性与子对象特殊化的属性冲突.这就是为什么例子中要进行存在性检查,以及后面要说的混合复制,可能存在的重写风险. 1. 再说多态(其实说的就是js里的多态)显式多态: 将父对象里的方法通过显式绑定到子对象上.就是显式多态.例如书中的例子:Vehicle.drive.call( this )。显式多态也是为了JS来模拟实现多重继承的!说明: 在ES6之前是没有相对多态的机制。所以就使用call这种进行显式绑定实现显式动态.注意JavaScript里实现多态的方法也被称为”伪多态”.所以不要对后面突然冒出的伪多态概念而一脸懵逼(其实整本书经常做这样的事) 显式多态(伪多态)的缺陷: 因为在JavaScript 中存在屏蔽(实际是函数引用的上下文不同),所以在引用的时候就需要使用显式伪多态的方法创建一个函数关联. 这些都会增加代码的复杂度和维护难度(过多的this绑定,真的会让代码很难读)。 2. 混合复制(显式混入另一种不常用方法)前面的显式混入的方法是先有子对象并进行特殊化,然后再有选择地复制父对象属性.这个不常用的方法则是反过来的,结合书中例子,它先用一个空对象完全复制父对象的属性,然后该对象复制特殊化对象的属性,最后得到子对象.这种方法明显是比第一种麻烦的,并且在复制特殊化对象时,可能会对之前重名的属性(即复制得到的父对象属性)进行重写覆盖.所以这种方法是存在风险,且效率低下的. 显式混入的缺陷: 无法做到真正的复制: 如果复制的对象中存在对函数的引用,那么子对象得到的是和父对象一样的,对同一个函数的引用.如果某个子对象对函数进行了修改,那么父对象及其他子对象都会受到影响.很明显这是不安全的.原因是JavaScript 中的函数无法进行真正地复制，你只能复制对共享函数对象的引用. 函数名和属性名同名: 如果混入多个对象,则可能会出现这种情况.目前现在仍没有比较好的方式来处理函数和属性的同名问题(提问:这种情况下谁的优先级更高?滑稽脸)。 3. 寄生继承显式混入模式的一种变体被称为“寄生继承”，它既是显式的又是隐式的.首先会复制一份父类(对象)的定义，然后混入子类(对象)的定义(如果需要的话保留到父类的特殊引用)，然后用这个复合对象构建实例。说明: 寄生继承与混合复制是很相似的,最大的区别是寄生继承是通过实例化构造函数(JS中的”类”)来实现复制的. 4.4.2 隐式混入隐式混入: 它与显示混入最大的区别,就是它没有明显的对父类(对象)属性进行复制的过程.它是通过在构造函数调用或者方法调用中使用显式绑定例如: Something.cool.call( this)来实现混入(多重继承).其本质就是通过改变this指向来实现混入. 4.5 小结整章的重点其实就是让你理解什么叫类.除了最后一小节的混入和JavaScript有那么一点点关系.其余的小结和JavaScript都没什么关系.重要的是理解类这种思想和设计模式.重点: 1.类意味着复制! 传统的类被实例化时，它的行为会被复制到实例中。类被继承时，行为也会被复制到子类中。 多态(在继承链的不同层次名称相同但是功能不同的函数)看起来似乎是从子类引用父类，但是本质上引用的其实是复制的结果。 JavaScript 并不会(像类那样)自动创建对象的副本。(你只能自己手动复制,而且复制的还不彻底!) 混入模式(无论显式还是隐式)可以用来模拟类的复制行为，但是通常会产生丑陋并且脆弱的语法，比如显式伪多态(OtherObj.methodName.call(this, …))，这会让代码更加难 懂并且难以维护。 显式混入实际上无法完全模拟类的复制行为，因为对象(和函数!别忘了函数也是对象)只能复制引用，无法复制被引用的对象或者函数本身。忽视这一点会导致许多问题。 在 JavaScript 中模拟类是得不偿失的，虽然能解决当前的问题，但是可能会埋下更多的隐患。(但实际,我们用得却很多) 第五章 原型注意:本章的前提是你已经比较熟悉原型及原型链.不太熟或者不知道的可以,通过这篇文章熟悉下. 5.1 [[Prototype]]JavaScript 中的对象有一个特殊的 [[Prototype]] 内置属性，其实就是对于其他对象的引用(一般就是其构造函数prototype属性的引用)。几乎所有的对象在创建时 [[Prototype]] 属性都会被赋予一个非空的值。吐槽: 书中有这样一句话 “注意:很快我们就可以看到，对象的 [[Prototype]] 链接可以为空，虽然很少见。”我前前后后看了三遍都没找到它所说的对象的 [[Prototype]] 链接可以为空.的情况!应该是作者写忘记了.ok,这里我来说下对象的 [[Prototype]] 链接可以为空的情况.就是通过Object.create(null)得到的对象.它的 [[Prototype]] 是为空的.应该说它的所有都是空的.为什么?因为null是原型链的顶端.它是没有[[Prototype]]的.对应的可以对比下console.log(Object.create({}))和console.log(Object.create(null)) [[Prototype]]有什么用?我原以为作者会说可以作为存放实例对象的公共属性,然后像类一样讲得更深刻点.不过这次只是说了它表明的作用. 作用: 就是存放哪些不在对象自身的属性. 当我们访问一个对象的属性时,此时对象的内部默认操作[[Get]],首先会检查对象本身是否有这个属性，如果有的话就使用它。如果没有的话,[[Get]] 就会继续访问对象的 [[Prototype]] 链.([[Prototype]]其实就是其构造函数的prototype属性.也是一个对象.)如果找到,就返回该属性值.如果没有就继续寻找下一个[[Prototype]]链.直到找完整条[[Prototype]]链.还是没有的话,[[Get]] 就会返回undefined. 补充: 使用 for..in 遍历对象时 任何可以通过原型链访问到 (并且是 enumerable:true)的属性都会被枚举。(其实这个在第三章里我说过) 使用 in 操作符 同样会查找对象的整条原型链(无论属性是否可枚举) 5.1.1 Object.prototype所有普通的 [[Prototype]] 链最终都会指向内置的 Object.prototype。(Object.prototype的[[Prototype]] 最终会指向null.null就是最后的终点).这个 Object.prototype 对象，包含了 JavaScript 中许多通用的功能,例如:toString() , valueOf(), hasOwnProperty(..)和 isPrototypeOf(..)。 5.1.2 属性设置和屏蔽说明: 看完本节时,切记不要对myObject.foo = &quot;bar&quot;这种简单的对象属性赋值产生顾虑和疑惑.这种赋值绝对不会对原型链产生任何影响!基本也不会出现赋值不成功的情况.如果有人敢在团队项目里修改对象的属性描述符,早就被拖出去打死了!!! 这部分可以看做补充知识,知道有这些奇葩设定就行.其实这节更应该关注的是myObject.foo的返回值.注意: 书中提到的动词屏蔽其实指的就是在对象上创建同名属性(原型链上已有该属性).注意不要被绕晕了.还有++就相当于myObject.a=myObject.a+1,注意分解就行,不存在什么特别需要当心的. 5.2 “类” JavaScript里只有对象,没有类! JavaScript不需要通过类来抽象对象.而是自己直接创建对象,并定义对象的行为. 5.2.1 “类”函数吐槽:模仿类竟然被说成奇怪的无耻滥用!?不这样做,js那些高级用法怎么实现?怎么会有现在前端的百花齐放(轮子满地跑)?这也是冒得办法的办法啊!毕竟当时js只是小众,不指望它有多大能耐.毕竟只是一个人用7天”借鉴”出来的东西. “类”函数: JavaScript用来模仿类的函数就被称为类函数,其实就是我们常说的构造函数. “类”函数模拟类的关键: 所有的函数默认都会拥有一个名为 prototype 的公有并且不可枚举(参见第 3 章)的属性，它会指向另一个对象.当我们通过new 函数(构造函数)来得到实例对象时,此时new会给实例对象一个内部的 [[Prototype]]属性，实例对象内部的[[Prototype]]属性与构造函数的prototype属性都指向同一个对象.那JS的这个特性怎么模拟类呢?首先类的本质就是复制!.明白这点后,我们就需要实现伪复制.我们可以将类里的属性,放在函数的prototype属性里.这样该函数的实例对象就可以通过[Prototype]访问这些属性.我们也经常把这种行为称为原型继承(作者后面会疯狂吐槽这个称呼,我后面再解释为什么吐槽).这样就实现了伪”复制”. 可以达到和类相似的效果. 注意: 虽然说所有的函数默认都会拥有一个名为 prototype属性.但也有特殊的时候.就不是默认的情况.就是通过bind()硬绑定时.所返回的绑定函数,它是没有prototype属性的! 图解真正的类与JS的模拟类: 关于原型继承这个名字的疯狂吐槽: 作者的吐槽主要集中在”继承”两个字,原因是在面向类的语言中,”继承”意味着复制,但在JavaScript里原型继承却根本不是这个意思,它并没有复制,而是用原型链来实现.所以疯狂吐槽其误导. 什么是差异继承? 我根本没听过这个术语,初次看作者所谓的解释,这是啥?他想说啥?后来读了好多遍,终于大概理解了.如果你也看不懂作者想在表达什么,就pass这部分.没必要理解.反而会把你看得更迷惑.好了,我来解释下什么叫差异继承.差异继承就是原型继承的一个不常用的别名.我们知道对象可以通过原型链继承一部分属性,但我们仍可以给对象设置其他有差异不同的属性.这也就可以称为差异继承. 5.2.2 “构造函数”构造函数之所以是构造函数,是因为它被new调用,如果没被new调用,它就是一个普通函数.实际上,new会劫持所有普通函数并用构造对象的形式来调用它,并且无论如何都会构造返回一个对象. 5.2.3 技术关于两种“面向类”的技巧,我这就不说明了,理解了这部分第一第二章关于this的使用,就很简单了. prototype.constructor:为了正确理解constructor.我特意在标题上加上prototype.是想强调:一个对象访问constructor时,会默认访问其原型对象上的constructor属性. 注意:12345678910111213function Foo() &#123; /* .. */ &#125;Foo.prototype = &#123; /* .. */ &#125;; // 有时候我们会需要创建一个新原型对象,因此也不会有默认的constructor属性指向构造函数// 需要在 Foo.prototype 上“修复”丢失的 .constructor 属性// 关于 defineProperty(..)，参见第 3 章 Object.defineProperty( Foo.prototype, "constructor" , &#123; enumerable: false,//不可枚举 writable: true, configurable: true, value: Foo // 让 .constructor 指向 Foo&#125; );//上面这种方法是比较严谨,也比较麻烦的.并且使用Object.defineProperty()风险是很大的.//所以我们实际是这样修改的Foo.prototype.constructor=Foo; //直接将其赋值Foo 唯一要注意的是此时constructor是可枚举的.会被实例对象的for..in..遍历到. 5.3 (原型)继承原型对象到原型对象的继承:例如:Bar.prototype 到 Foo.prototype 的委托关系，正确的JavaScript中“原型风格”:1234567891011121314151617181920212223function Foo(name) &#123; this.name = name;&#125;Foo.prototype.myName = function() &#123; return this.name;&#125;;function Bar(name,label) &#123; Foo.call( this, name ); this.label = label;&#125;// 我们创建了一个新的 Bar.prototype 对象,并且它的[[Prototype]] 关联Foo.prototype Bar.prototype = Object.create( Foo.prototype );// 注意!Object.create()是返回一个新的对象,所以现在没有 Bar.prototype.constructor 了 // 如果你需要这个属性的话可能需要手动修复一下它Bar.prototype.myLabel = function() &#123; return this.label;&#125;;var a = new Bar( "a", "obj a" );a.myName(); // "a"a.myLabel(); // "obj a" 错误用法: 1, Bar.prototype = Foo.prototype; 此时并不会创建一个关联到 Bar.prototype 的新对象，它只是让 Bar.prototype 直接引用 Foo.prototype 对象。 因此当你执行类似 Bar.prototype. myLabel = … 的赋值语句时会直接修改 Foo.prototype 对象本身。 2, Bar.prototype = new Foo(); 它使用 了 Foo(..) 的“构造函数调用”，如果函数 Foo 有一些其他操作的话,尤其是与this有关的的话，就会影响到 Bar() 的“后代”，后果不堪设想。 结论: 要创建一个合适的关联对象，我们需使用 Object.create(..) 而不是使用具有副作用的 Foo(..)。这样做唯一的缺点就是需要创建一个新对象然后把旧对象抛弃掉(主要是需要手动设置constructor)，不能直接修改已有的默认对象。 检查”类”关系 instanceof 操作符: 验证左边的普通对象的整条[[prototype]]链是否有指向右边函数的prototype,例如:a instanceof Foo。 isPrototypeOf(..) 方法: 验证在对象 a 的整条 [[Prototype]] 链中是否出现过 原型对象b.例如:b.isPrototypeOf( a ); 注意: 如果使用内置的 .bind(..) 函数来生成一个硬绑定函数(参见第 2 章)的话， 该函数是没有 .prototype 属性的。如果硬绑定函数instanceof 的话,则其bind的 目标函数的prototype会成为硬绑定函数的prototype. 关于proto:我们知道函数可以直接通过prototype属性直接访问原型对象.那对象怎么访问呢?我们知道是通过[[prototype]]链.怎么访问呢?在ES5之中的标准方法:通过Object.getPrototypeOf( )方法来获取对象原型.Object.getPrototypeOf( a ) === Foo.prototype; // true,另一种方法:在 ES6 之前并不是标准,但却被绝大多数浏览器支持的一种方法,可以访问内部[[prototype]]对象.那就是__proto__.例如:a.__proto__ === Foo.prototype; // true.你甚至可以通过.__proto__.__ptoto__...来访问整个原型链. .__proto__实际上并不存在于你正在使用的对象中.并且它看起来很像一个属性，但是实际上它更像一个 getter/setter(见第三章). 5.4 对象关联[[Prototype]] 机制就是存在于对象中的一个内部链接，它会引用其他对象。 这个链接的作用是:如果在对象上没有找到需要的属性或者方法引用，引擎就会继续在 [[Prototype]] 关联的对象上进行查找。同理，如果在后者中也没有找到需要的 引用就会继续查找它的 [[Prototype]]，以此类推。这一系列对象的链接被称为原型链。 5.4.1 创建关联问:“我们已经明白了为什么 JavaScript 的 [[Prototype]] 机制和类不一样，也明白了它如何建立对象间的关联。”答: 类的机制是复制,JavaScript里原型链的机制是引用. 问:“那 [[Prototype]] 机制的意义是什么呢?为什么 JavaScript 开发者费这么大的力气(模拟类)在代码中创建这些关联呢?”答: 意义就是模拟类,JavaScript不需要复制(我觉得这不是个优点)而通过原型链实现”实例”对”类”的”继承(其实就是引用)”.这样就达到了实例对象对某些属性(即原型对象里的属性)的复用. Object.create(..)这个方法其实我们在前面已经使用过很多次.”Object.create(..) 会创建一个新对象(bar)并把它关联到我们指定的对象(foo)，这样我们就可以充分发挥 [[Prototype]] 机制的威力(委托)并且避免不必要的麻烦(比如使用 new 的构造函数调用会生成 .prototype 和 .constructor 引用)。”实际上这个方法就是创建返回一个新对象,这个新对象的原型([[Prototype]])会绑定为我们输入的参数对象foo.并且由于不是通过构造函数的形式,所以不需要为函数单独设置prototype.虽然Object.create(..)很好,但实际我们使用的更多的还是构造函数形式.注意: Object.create(..) 的第二个参数指定了需要添加到新对象中的属性名以及这些属性的属性描述符(参见第 3 章)。 Object.create(null)这个方法其实我们在前面也讲解过几次.”Object.create(null) 会创建一个拥有空(或者说null)[[Prototype]] 链接的对象，这个对象无法进行委托。由于这个对象没有原型链，所以 instanceof 操作符(之前解释过)无法进行判断，因此总是会返回 false。 这些特殊的空 [[Prototype]] 对象通常被称作“字典”，它们完全不会受到原型链的干扰，因此非常适合用来存储数据。“ “Object.create()的polyfill代码.”这部分我就不做解读了,因为现在都8102年,es6早就普及了,你几乎不可能再用到es5之前的语法了.所以这部分大家了解下即可. 5.4.2 关联关系是备用[[Prototype]] 的本质作用: 书中提到了一个观点”处理“缺失”属性或者方法时的一种备用选项。”(即备用设计模式).但随后进行了否定”但是这在 JavaScript 中并不是很常见。所以如果你使用的是这种模式，那或许应当退后一步并重新思考一下这种模式是否合适。” 作者给出的观点是:”进行委托设计模式,即例子中的内部委托(就是在对象里套了个壳再引用了一遍,为的是将委托进行隐藏).这样可以使我们的API设计得更加清晰.”文中的清晰是指,当我们需要引用原型对象的属性方法时,我们在对象内部设置对应专门的属性(例子中的doCool),进行内部委托(其实就是套个壳进行隐藏).这样我们对象的属性就是”完整”的. 在实际工作中,我们常常就是把原型对象作为存放对象的公共属性方法的地方.对于一般比较重要的操作才会在对象里进行内部委托(隐藏委托)! 5.5 小结总结得很好很全面,这里我还是直接摘抄了,不是偷懒哦! 如果要访问对象中并不存在的一个属性，[[Get]] 操作(参见第 3 章)就会查找对象内部[[Prototype]] 关联的对象。 这个关联关系实际上定义了一条“原型链”(有点像嵌套的作用域链)，在查找属性时会对它进行遍历。 所有普通对象都有内置的 Object.prototype， 指向原型链的顶端(比如说全局作用域)，如 果在原型链中找不到指定的属性就会停止。toString()、valueOf() 和其他一些通用的功能 都存在于 Object.prototype 对象上，因此语言中所有的对象都可以使用它们。 关联两个对象最常用的方法是使用 new 关键词进行函数调用，在调用的 4 个步骤(第 2 章)中会创建一个关联其他对象的新对象。 使用 new 调用函数时会把新对象的 .prototype 属性关联到“其他对象”(就是构造函数prototype所指的对象)。带 new 的函数调用 通常被称为“构造函数调用”，尽管它们实际上和传统面向类语言中的类构造函数不一样。 JavaScript 中的机制有一个核心区别，那就是不会进行复制，对象之间是通过内部的 [[Prototype]] 链关联的。 “委托”是一个更合适的术语，因为对象之间的关系不是复制而是委托。(意思就是原先继承应该改为原先委托?) 第六章 行为委托第 5 章的结论:[[Prototype]] 机制就是指对象中的一个内部链接引用另一个对象。换句话说，JavaScript 中这个机制的本质就是对象之间的关联关系。在第六章又被称为委托.PS:前面在讲原型的时候我就习惯用父对象指代原型对象(类似”父类”),用子对象指代其实例对象(类似”子类”).本章也将采用这种称呼,故下面不再说明.(其实我觉得用父对象和子对象称呼更形象) 6.1 面向委托的设计一句话:[[Prototype]]机制是面向委托的设计,是不同于面向类的设计. 下面将分别介绍类理论和委托理论. 6.1.1 类理论类理论设计方法: 首先定义一个通用父(基)类，在 父类类中定义所有任务都有(通用)的行为。接着定义子类 ，它们都继承自 父类并且会添加一些特殊的行为来处理对应的任务,并且在继承时子类可以使用方法重写(和多态)父类的行为. 类理论中许多行为可以先“抽象”到父类然后再用子类进行特殊化(重写)。ps:这部分了解即可,着重理解下面JavaScript用到的委托. 6.1.2 委托理论类理论设计方法: 首先你会定义一个”父”对象(相当于上节中的父类)，它会包含所有任务都可以使用(委托)的具体行为。接着，对于每个任务你都可以定义一个对象(“子”对象)来存储对应的数据和行为。你可以把特定的任务对象都关联到父对象上，让它们在需要的时候可以进行委托。 (其实我们一般都是用父对象来定义通用的方法,子对象进行委托.然后子对象自身个性的属性方法就写在子对象本身,并避免与父对象的属性名冲突) ps: 这节书中这段话但是我们并不需要把这些行为放在一起，**通过类的复制**，我们可以把它们分别放在各自独立 的对象中，需要时可以允许 XYZ 对象委托给 Task。有个错误.”通过类的复制”应该改为”通过”[[Prototype]]机制”.这里应该是作者的手误.在 JavaScript 中，[[Prototype]] 机制会把对象关联到其他对象。无论你多么努力地说服自 己，JavaScript 中就是没有类似“类”的抽象机制。(其实主要原因还是是JavaScript没有完整的复制机制) 委托理论的使用建议:PS:书中这里写了3条,其实只有2条,第三条不过是对第一条的说明,这里我进行了合并. 通常来说，在 [[Prototype]] 委托中最好把状态保存在委托者(子对象)而不是委托目标(父对象)上。那怎么实现呢,就是通过”this 的隐式绑定”.在委托目标(父对象)上的函数里通过this定义保存状态.当委托者(子对象)引用该函数方法时,此时的this就自动绑定到委托者上了. 在委托中我们会尽量避免在 [[Prototype]] 链的不同级别中使用相同的命名，否则就需要使用笨拙并且脆弱的语法来消除引用歧义(参见第 4 章)。 补充: 3. 在 API 接口的设计中，委托最好在内部实现，不要直接暴露出去。 这么做更多的是出于安全和接口稳定的考虑.建议子对象将所有引用父对象的方法都套个函数隐藏起来,并取一个语义化的属性名. 委托理论的使用注意: 禁止两个对象互相委托:当你将第二个对象反向委托给前一个对象时,就会报错. 调试: 这个了解下就行.知道不同浏览器和工具对委托的解析结果并不一定相同.(吐槽:看了半天到后面出现实际上，在编写本书时，这个行为被认定是 Chrome 的一个 bug， 当你读到此书时，它可能已经被修复了。我只想说WTF! 好吧,我知道chrome以前可能出现过这个”bug”了=.=) 6.1.3 比较思维模型这节主要是比较了”通过构造函数(模拟类)实现原型继承”与”通过对象关联(委托形式,Object.create( … ))实现原型继承”两种方式的区别. 结论: 通过对象关联,委托形式,更加简洁,更加清晰易懂. PS:这里我原本自己对例子画出原型示意图.但是发现是真的复杂,并且和书中简洁后的示意图是差不多的,所以这里就不展示了,免得让读者看得更头大.这里建议,读者自己在草稿纸上画出原型示意图. 6.2 类与对象其实这节讲得还是”通过构造函数(模拟类)实现原型继承”与”通过对象关联(委托形式,Object.create( … ))实现原型继承”两种方式的区别.不过这次主要是以前端实际使用场景进行讲解. 6.2.1 控件“类”这里我就不以书中的例子进行讲解了,而是直接站在更高的角度对这种”类”风格的代码进行讲解.最大特点: 1是通过构造函数进行模拟类,2是通过显式伪多态(硬绑定函数)关联两个函数.注意: 不管是类还是对象.这两种形式一般都需要定义两种数据.第一种就是实例对象要用到的”初始保存的数据”;第二种就是通用行为的定义,包括对实例对象数据的增删改查. 下面提到的显式伪多态(详见第四章),其实指的就是使用call()方法这种硬绑定. 注意ES6 class模拟类的写法我就没具体列出了.实际上class 仍然是通过 [[Prototype]] 机制实现的,不过是个表面简洁的语法糖. 虽然书中对显式伪多态称为”丑陋的”,还用了一个语气动词”呸!”.虽然这样不好,但有时用call真的很方便,所以用得也很多. 6.2.2 委托控件对象最大特点: 通过对象载体来模拟父子,并通过Object,create(…)来对两个对象进行关联.并通过委托的形式进行引用.与上节中提到的类形式还有一个区别:对象foo构建后,需要手动调用setUp方法进行初始化.故对象的构建与初始化是分开的.而构造函数形式则是在new 构造函数时, 同时进行了对象构建与初始化.(关于这点我下面还会再说明的) 关于书中这句使用类构造函数的话，你需要(并不是硬性要求，但是强烈建议)在同一个步骤中实现构造和初始化。然而，在许多情况下把这两步分开(就像对象关联代码一样)更灵活。的理解:使用类构造函数形式,当我们使用new 构造函数时,其实是在一步实现对象的构建和对象数据的初始化(通过构造函数里的call) ;使用这种委托形式,我们是分别通过Object.create( ... );构建对象和foo.setUp( ...);来初始化的.即我们是分两步实现的.这样分开的话其实是更加灵活,也更符合编程中的关注分离原则. 6.3 更简洁的设计这节也是一样通过两者的对比来突显委托设计模式的各种优点.这里我就不再对书中的例子进行解读.如果你真正理解了类和委托的话,其实是很简单的.如果觉得复杂的话,可以在纸上理一下函数和对象之间的关系,下面我就只总结下这里提到委托设计模式的优点,当然核心是更简洁. 简洁体现在: 1, 委托重点在于只需要两个实体(两个对象相互关联)，而之前的”类”模式需要三个(父”类”,子”类”,实例对象)其实可以这么理解:委托模式将”子类”和”实例对象”合为一个对象了。 2, 不需要基类(父类)来”共享”两个实体之间的行为.不需要实例化类,也不需要合成.其实这第二条就是对第一条这种结果的说明. 额外补充强调:在使用构造函数模拟类时,子类通常会对父类的行为进行重写(属性名相同);但委托模式则不会,它会重新取个属性名,再引用父对象上的行为. 6.4 更好的语法这节主要是介绍ES6提供的2个简洁写法与其中的隐患. 语法: 在 ES6 中我们可以在任意对象的字面形式中使用简洁方法声明，例如: 123 var Foo = &#123; bar() &#123; /*..*/ &#125;,//字面形式声明&#125;; 在 ES6 中我们可以用 Object. setPrototypeOf(..) 来修改对象的 [[Prototype]],具体用法可以查看MDN例如: 12345678910111213// 使用更好的对象字面形式语法和简洁方法 var AuthController = &#123; errors: [], checkAuth() &#123; // ... &#125;, server(url,data) &#123; // ... &#125; // ... &#125;;// 现在把 AuthController 关联到 LoginController Object.setPrototypeOf( AuthController, LoginController ); 弊端: 对象字面形式语法:实际上就是一个匿名函数表达式.匿名函数会导致3个缺点:1. 调试栈更难追踪;2. 自我引用(递归、事件(解除)绑定，等等)更难; 3. 代码(稍微)更难理解。(其实我觉得这3个缺点还好,影响不是那么大).但是这种简洁语法很特殊，会给对应的函数对象设置一个内部的 name 属性，这样理论上可以用在追 踪栈中。所以实际上唯一的弊端就只剩第2条了.终极建议就是:如果你需要自我引用的话，那最好使用传统的具名函数表达式来定义对应的函数，不要使用简洁方法。 Object. setPrototypeOf(..) 这个是书中没有提的,我觉得有必要进行补充下.首先,Object. setPrototypeOf(..)可能会带来性能问题,如果关心性能,则应该使用Object.create()替代.Object. setPrototypeOf(..)与Object.create()的主要区别: Object. setPrototypeOf(..)会直接修改现有对象的[[prototype]],Object.create()则是返回一个新对象.所以你需要手动设置一下丢失的的constructor属性(如果你需要的话).而使用setPrototypeOf(..)则不需要. 6.5 内省吐槽: 纵观整本书,作者关于JavaScript中模拟类和继承”的批评,说它们具有很大误导性!更是嗤之以鼻!就差爆粗口了,JavaScript就像一个异教徒,应该绑在十字架上被烧死!但是他这样的观点,都是站在其他语言的角度来看待时,产生的.我想更多的读者可能是只接触过JavaScript.那么他其实是没有这些疑惑的!!!你反而给他们讲这一大堆其他语言的”正确”含义,有时候会时得其反!让读者更加困惑,如果是理解不透彻的,反而会怀疑自己本来写的是对的代码!所以读者应该做一个可以理解作者意图,并且拥有自我见解和观点立场! 什么是内省(自省)?首先,本节需要弄懂一个问题,什么是内省,或者是自省。书中的解释是自省就是检查实例的类型。类实例的自省主要目的是通过创建方式来判断对象的结构和功能。我这里再更通俗地解释下:当我们构建得到一个实例对象时,有时候我们是不太清除它的属性和方法的.尤其是第三方库.有时候贸然使用会导致很多错误(例如调用的方法不存在,或者报错等).这个时候我们就需要通过自省.其实就是通过一系列操作,来确认实例是不是我们想要的那个,实例的方法是不是我们想要的(存在且可用). 内省的方法: 1.通过 instanceof 语法:123456789101112function Foo() &#123; // ...&#125;Foo.prototype.something = function()&#123; // ... &#125;var a1 = new Foo();// 假设我们不知道上面的过程,只知道得到实例对象a1//我们想知道a1是不是我所希望的函数Foo所构建的if (a1 instanceof Foo) &#123; a1.something();&#125; 例子中我们有一个实例对象a1,但是我们不知道a1是不是我们所希望的函数Foo所构造的,此时就可以通过instanceof进行判断. instanceof比较适合判断实例对象和构造函数之间的关系.缺陷: 但是如果我们想判断函数A是不是函数B的”子类”时,则会稍微麻烦点,我们需要像这样A.prototype instanceof B进行判断.并且也不能直接判断两个对象是否关联. 2.通过 “鸭子类型”: 为什么会叫这个名字?看了作者的解释,还是不太能接受.不太理解外国人的脑回路.你在国内和别人说”鸭子类型”,估计也是一脸懵逼.其实很简单,所谓的”鸭子类型”其实也是我们实际工作中常用的:1234//如果a1的something存在的话,则我们可以进行调用if ( a1.something) &#123; a1.something();&#125; 其实这种方法是非常常用的,排除了在不知道存在性情况下,贸然调用的风险.缺陷: 关于书中提到的缺点,四个字概括就是”以偏概全” .书中关于Promise的例子,就是以偏概全的例子.所以我们在使用时,在if判断a1.something存在时,才会在后面使用something方法.不要直接使用anotherthing,这种没确认过的方法. 3.如果使用对象关联时: 则可以比较简单的使用Object.getPrototypeOf(..)进行判断.例如Object.getPrototypeOf(a)===A其中a,A都是对象.如果为true,则说明a的原型链上含有对象A. 6.6 小结 除了类和继承设计模式,行为委托其实是更强大,更值得推广的模式(本观点仅代表作者的观点!) 行为委托认为对象之间是兄弟关系，互相委托，而不是父类和子类的关系。JavaScript 的 [[Prototype]] 机制本质上就是行为委托机制。(我觉得还是父子对象关系.我的解说里也都是父子相称) 当你只用对象来设计代码时，不仅可以让语法更加简洁，而且可以让代码结构更加清晰。 对象关联(对象之前互相关联)是一种编码风格，它倡导的是直接创建和关联对象，不把它们抽象成类。对象关联可以用基于 [[Prototype]] 的行为委托非常自然地实现 后续更新后面关于&lt;你不知道的JavaScript&gt;中和下.还在写作当中,手头上还有一篇webpack完全指北的文章,目前写了一半2w字,也都是面向新手,真正的全面地由浅入深.最近,空降一个新项目组,开发到测试只有一个月,还要带新人,更新会很慢.不过我会争取年前全部放出.如果大家喜欢的话,可以关注我一下,文章首发还是在掘金的. 最后求一个内推,目前笔者在一家软件国企(半养老型).年底或者明年初就会考虑离职.希望进入一家比较好的互联网企业.如果有小伙伴有好的机会可以发我邮箱:bupabuku@foxmail.com.谢谢!目前暂时优先考虑武汉(房子,盆友,东西都在这边,去外地太不方便了-.-)]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端基础1]]></title>
    <url>%2F2018%2F12%2F01%2F%E9%9D%A2%E8%AF%95%2FFrontPrevew%2F</url>
    <content type="text"><![CDATA[HTML/CSS 浏览器内核？ IE/Trident FireFox / gecko Chrome / webKit-&gt;Blink Safari / WebKit Opera / 之前是presto -&gt; Blink Doctype? 在标签之前 告知浏览器使用那种文档 Quirks 模式是什么？Standards模式区别 如果有条件采用CSS之后更好的模式，如果没有写，兼容之前的布局方式 区别 ：1234盒模型 / 标准下内容宽高；Quirks下IE的包括padding border设置行内元素宽高 / 标准下设置不会生效；quriks 下会设置宽高设置百分比的高度 / 标准下高度是内容决定的，如果父元素没有设置百分比高度，字元素设置百分比是无效的；quirks下设置生效margin：0 auto / 标准下可以元素居中，quirks下不能居中 div+css 布局和table布局有什么区别 改版方便 页面加载快 结构化清晰，页面显示简洁 表现与数据结构分离 易于优化，搜索引擎更友好。 img alt 和title的区别 strong和em的区别 alt 用在显示不出来图片的时候占位文字 title 是鼠标悬浮img时的说明文字 IE下当没有设置title会把alt作为title提示 strong 强调 加粗，重要性 en 斜体 强调 渐进增强/优雅降级 Progressive Enhancement针对低版本保证最基本功能，再适配低版本 进行效果交互能用户体验 Graceful Degradation 一开始完整功能，再针对低版本浏览器进行兼容 区别： 优雅降级往回看，向低版本兼容。渐进增强向前看，兼容最新的的功能。 为什么利用多个域名来存储网站资源会更有效 CDN 缓存更方便 突破浏览器并发限制 节约cookie带宽 节约主域名的连接数，优化页面相应速度 防止不必要的安全问题 网页标准和标准制定机构重要性的理解 Cookie SessionStorage LocalStorage 区别 SessionStorage session中的数据 这些数据 只有在同一个会话中的页面才能访问，并当会话结束随之销毁，会话级别的存储。 LocalStorage 持久化的本地存储 除非主动删除数据，否则永远不会过期 Cookie 大小受限制，并且每次请求新页面Cookie都会被发送过去，这样无形中浪费带宽，还需要制定作用域，不可以跨域。 WebStorage 是作为本地存储用的，有API setItem getItem removeItem clear 等。 Cookie 作用是与服务器进行交互，作为HTTP规范的一部分存在。 src 和 href 的区别 src source &lt;script&gt; 中指向的资源替换当前元素，会加载编译资源之后再向下进行 href 网络资源位置，和 配合使用，指向的一个地址，会并行加载，编译当前文档之后再编辑指向的资源位置 网页制作的图片格式 PNG-8/PNG-24/JPEG/GIF/SVG Webp 谷歌的图片格式，是JPEG的60%，节省空间和网络资源 微格式？ 是一种让机器可读的语义话词汇的集合，是结构化数据的开放标准，是特殊应用而制定的特殊格式。 优点：将只能数据添加到网页上，让网站内容再搜索引擎结果界面可以显示额外的提示， 从用户刷新网页开始，一次JS请求一般情况那些缓存？ DNS缓存 CDN缓存 浏览器缓存 服务器缓存 大型电商网站大量的图片，加载很慢，有哪些方法优化？ 能用font字体替代一些icon图片 使用精灵图 取代小而多的一类图片 图片懒加载，先加载显露出来的，上拉加载的时候再加载 如果有幻灯片，只加载第一张和后一张，点击之后再加载后面的 CSS图片，使用CSSsprite SVGsprite Iconfont Base64等技术 如果图片过大，使用特殊编码压缩图片 有限加载缩略图，再加载高清图片 所需小图，优先服务器压缩后的小图。 HTML结构的语义化 丢掉CSS样式后也能显示页面结构 有默认的CSS 搜索引擎注重语义标记 W3C 有标准，减少差异化东西，方便开发和维护，提高开发效率，实现模块开发 做好SEO考虑？ 合理标签的使用 Meta标签优化，title Description Keywords Author Category Language DOM 设置它的CSS样式 内部样式/内联样式/外部样式 | 标签内部/&lt;style&gt;标签内 / 引入的外部样式 CSS哪些选择器 派生选择器(标签选择器) 权重1 id选择器 ID权重100 类属性选择器 class权重10 属性选择器 ::hover 后代选择器 div .text .span 空格隔开 权重相加(1+10+10) 群组选择器 p,div,#a{} 或的关系，是多个目标一起设置 使一个元素不显示？ CSS里可以用哪些属性定义 display:none visibility:hidden 这只宽高为0 ; z-index:-100 ; 透明度设置为0 超链接访问过后hover样式就不出现了，问题？ 如何让解决？ LVHA(link;visted;hover;active) 什么是CSS Hack 针对不同的浏览器写不能的CSS 1234_background-color:white; /*ie6*/+background-color:white; /*ie7*/background-color:white\9;/*ie9*/background-color:white; /*剩下的就是IE8 */ rgba() 和opacity 的透明效果有什么不同？ | 元素内的所有的内容的透明度 CSS让文字在垂直和水平方向上的重叠的两个属性是什么？ 垂直方向line-height 水平方向letter-spacing letter-spacting 可以消除 inline-block的换行符空格间隙问题 垂直居中一个浮动元素 12345678910111213141516171819202122232425 /* 垂直居中一个浮动元素 方法一:已知元素的高宽 */.div1&#123; position: absolute; width: 100px; height: 100px; left: 50%; top: 50%; margin-left: -50px; margin-top: -50px;&#125; /* 垂直居中一个浮动元素 方法二:未知元素的高宽 */.div2&#123; position: absolute; top: 0px; bottom: 0px; left: 0px; bottom: 0px; &#125; /* 垂直居中一个&lt;img&gt;? */.imageContainer &#123; display: table-cell; text-align: center; vertical-align: middle;&#125; px 和 em的区别 px 是固定值，em值不是固定的，并且会继承父级元素的大小 浏览器的默认字体是16px = 1em . 12px = 0.75em 描述一个reset的CSS文件如何使用？ normalize.css? 不同之处？ 重置样式，恢复默认样式 不同的浏览器有不同的默认样式，先进行初始化统一样式 normalize.css 没有充值所有的样式，仅提供了一套合理的默认样式。 Sass Less 是什么？ 为什么使用？ 是CSS预处理 是CSS的一种抽象 是一种特殊的语法语言编译成CSS less是一种动态样式 变量继承运算函数等。 结构清晰，便于扩展; 可以封装对浏览器差异的重复处理; 轻松实现多继承; 完全兼容CSS代码向下兼容 dispaly:none 和 visibility:hidden的区别是什么？ display 隐藏空间不占位置 visibility 隐藏，保留空间位置 CSS的 和@import 的区别 link 是html标签;import 是CSS提供 页面加载时候，link 会异步同时加载，@import 引入的CSS会在页面加载完成才引入CSS @import只有在IE5之上才会被识别，link不存在浏览器兼容性问题 Link 优先级权重大于@import 盒子模型 content /padding/border/margin 为什么初始化样式？ 由于浏览器兼容问题，不同的浏览器对标签默认样式不同，会造成不同浏览器之间的差异化显示 但是初始化CSS会对搜索引擎优化造成小影响 BFC是什么？(块级格式化上下文) 一个创建了新的BFC盒子是独立布局的，盒子内元素的布局不会影响盒子外面的元素，在同一个BFC的两个相邻的盒子在垂直方向发生margin 重叠的问题 BFC是值浏览器中创建了一个独立的渲染区域，该区域所有的元素布局不会影响到区域外元素的布局，这个渲染区域只对块级元素起作用 IE的双边距bug，解决：加入dispaly:inline html常见的兼容性问题 双边距问题 使用dispaly 3像素问题 display:inline -3px 超链接hover点击失效 LVHA IE z-index 问题 父级 display:relative PNG透明 使用JS修改 Min-height最小高度 !important select 在ie6下遮盖 使用iframe 为什么没有办法定义1px的宽度问题 (IE6默认行高造成的， over:hidden;zoom:0.08;line-height:1px) IE5-8 不支持opacity 12345.opacity&#123;opacity: 0.4;filter: alpha(opacity = 60); /*IE5-7*/-ms-filter: "progid:DXImageTransform.Microsoft.Alpha(Opacity=60)"; /*IE8*/ &#125; IE6 不支持PNG透明背景 IE6 下使用Gif 图片 浏览器的内核分别是什么，经常遇到的浏览器兼容性哪些？原因，解决方法？常用hack技巧 PNG 24图片显示出现背景，做成PNG8 个浏览器不同的margin padding 加全局的*{padding,magging:0} IE6双边距的问题 display的值和各自的作用，position的值；relative absolute 定位原点是什么 block/inline-block/grid/table/table-cell absolute/relative/fixed/static/inherit inherit 规定从父元素继承position属性的值 absolute的containing block 计算方式跟正常流有什么区别 若此元素为inline元素 则containing block 为能都包含这个元素生成的第一个和最后一个inline box 的padding bxo position 和 display/ margin collapse /overflow / float 这些特性相互叠加会怎样？ JS基础 typeof 返回值是？ Object/number/function/boolen/undefine/string 举例3种强制转换 2种隐式转换 强制转换 perseInt Number() parseFloat 隐式转换 == ; 121 == '1' //truenull == undefine // true splite() 和 join() 的区别 | 字符串分割为数组 数组合并为字符串 pop() push() unshift() shift() | 尾部添加 微不删除 头部添加 头部删除 事件绑定和普通事件的区别？ 事件绑定 是把事件注册到具体的元素上；普通事件指的是可以用来注册的事件 div1.onclick如果给同一个元素绑定了两次或者多次相同的类型的事件,之前绑定的事件会被覆盖;不支持DOM事件流 IE9之后 addEventListener 绑定了多次，所有的都会触发 ；支持DOM事件流 ；绑定的函数名参数不带on IE9 之前是 attachEvent/detachEvent 这种方式只支持事件冒泡不支持事件捕获 IE和DOM 事件流的区别 执行顺序不一样/参数不一样/事件加不加on/this指向问题 IE9之前 attachEvent(‘onclick’,function(){}) IE9之后 addEventListener(‘click’,function(){}) IE和标准下有哪些兼容性写法123var ev = ev || window.eventdocument.documentElement.clienWidth || document.body.clientWidthvar target = ev.srcElement || ev.target call 和 apply 的区别 都是用了一个本不属于一个对象的方法，让这个对象去执行 toString.call([],1,2,3) toString.apply([],[1,2,3]) Object.call(this,obj1,obj2,obj3) Object.apply(this,arguments) call 参数传分散可以多个，apply 传一个参数的集合 B继承A的方法 构造函数继承;原型链继承;以上两种方式的组合 事件委托是什么？ 复合W3C标准的事件绑定，利用事件冒泡的原理，让自己所触发的事件，让他的父元素代替执行，delegate 闭包是什么，有什么特性，对页面有什么影响 闭包就是能够读取其他函数内部变量的函数，(匿名函数就是闭包?) 缺点：滥用闭包会引起内存泄漏，因为闭包引入的外部的变量都永远不会被释放，所有应该再必要的时候，释放这个闭包函数 如何阻止事件冒泡和默认事件 eve.stopPropagation || event.cancelBubble = true(IE9之前) 阻止默认事件：在点击事件内return false || eve.preventDefault 添加 删除 替换 插入某个节点的方法 eleme.appendChild(). //追加 eleme.removeChild()。// 删除 eleme.replaceChild() // 替换 eleme.insertBefore() // 在之前插入 原声JS不提供insertAfter() javascript的本地对象，内置对象 宿主对象 本地对象 Array Obj regep 等可以使用 new 实例化 内置对象为gload Math等不可以实例化的 宿主为浏览器自带的document window 等 document load 和 document ready 的区别 document.onload 是结构样式加载完成之后才执行 window.onload 是结构样式加载之后，还要执行完所有的样式 图片等资源文件全部加载完之后才会调用 window.onload ‘==’ 和 ‘===’ 的区别 == 会隐式转换 === 会先判断左右两边的数据类型 如果数据类型不一致直接return false ，之后才进行值的比较 javascript的同源策略 同一源:主机名 协议 端口号的组合。 麻烦：Ajax 不在0:http协议的默认端口；同域名下请求无法实现 可以通过jsonp 来解决 编写一个数组去重的方法 for循环判断 利用set去重特性 JS是一门什么样的语言，有哪些特点？ 面向对象/动态语言/ 运行环境在浏览器中运行 JS的数据类型？ 基本数据类型:String|Boolen|Number|undefine|Null|Object 引用数据类型:Array|Date|Function|RegExp 如何判断数据类型1234567891011121判断是否有数组的性质。splice() ；不能确定保证2instanceof 在某些低版本中不适用3isArray() 保证兼容性是最好的方法toString.call(18) // [object Number]toString.call('') // [object String]toString.call(/[0-9][10]/) // [object RegExp] if(typeof Array.isArray === 'undefine')&#123; Array.isArray = function(agr) &#123; return Object.prototype.toString.call(arg) === '[object Array]' &#125;&#125; 希望获取页面所有的checkbox怎么做 123456789var domlist = document.getElementsByTagName('input')var checkArr = []var len = domlist.lengthwhile效率会比for循环更高？while(len--)&#123; if(domlict[len].type === 'checkbox')&#123; checkArr.push(domlict[len]) &#125;&#125; 设置一个ID为‘ttt’ 的div 内容为’xxxxxx’,背景色为‘#234’ 123var divDom = document.getElementById('ttt')divDom.innerHtml = 'xxxxxxx'divDom.style.color = '#234' 点击一个DOM的时候，希望执行一个函数，如何做？ 1.直接在DOM里绑定事件 &lt;div onclik=&#39;test()&#39; &gt;&lt;/div&gt; 2.在JS里面绑定 divDom.onclick = test 3.通过事件添加绑定addEventListener(&#39;click&#39;,test) JS的事件流模型 事件冒泡 内而外 目标阶段 事件捕捉 外向里 undefined 会在以下三种情况下产生 变量定义了还没有被复制 想要获取一个对象不存在属性和方法 一个数组中没有被赋值的元素 typeof null 返回的是Object 类型转换的判断相等 1234567891011121314undefined == null // true1 == true // true0 == false // true0 == '' // trueNaN == Nan // false[] == false // true[] != ![] // true对于0 空字符串判断 建议用 === var foo = '11' + 2 - '1'console.log(foo)console.log(typeof foo)112 -1 = 111 类型是Number 引用类型指针拷贝 一个值修改，其他引用的值都做改变 已知有字符串 foo=”get-element-by-id”,写一个 function 将其转化成驼峰表示法” getElementById”。 | splice(‘-‘) ;charAt(0).toUpperCase() 输出今天的日期 以YYYY-MM-DD的方式 1234567891011var d = new Date();// 获取年，getFullYear()返回 4 位的数字var year = d.getFullYear();// 获取月，月份比较特殊，0 是 1 月，11 是 12 月var month = d.getMonth() + 1;// 变成两位month = month &lt; 10 ? '0' + month : month;// 获取日var day = d.getDate();day = day &lt; 10 ? '0' + day : day;alert(year + '-' + month + '-' + day); 将字符串”{$id}{$name}”中的{$id}替换 成 10，{$name}替换成 Tony (使用正则表达式) 1"&lt;tr&gt;&lt;td&gt;&#123;$id&#125;&lt;/td&gt;&lt;td&gt;&#123;$id&#125;_&#123;$name&#125;&lt;/td&gt;&lt;/tr&gt;".replace(/&#123;\$id&#125;/g, '10').replace(/&#123;\$name&#125;/g, 'Tony'); foo = foo || bar 是什么意思？ 短路表达式 swift 给默认值 变量声明提升 &gt; 函数声明与变量声明会被 JavaScript 引擎隐式地提升到当前作用域的顶部，但是只提升名 称不会提升赋值部分。 12345678910111213var foo = 1;function()&#123; console.log(foo); var foo = 2; console.log(foo);&#125;// 输出 undefine 和 2 代码相当于:var foo = 1;function()&#123; var foo; console.log(foo); //undefined foo = 2; console.log(foo); // 2;&#125; JS 实现随机选取10-100 的数据，存到一个数组，并排序 1234567891011// 用 js 实现随机选取 10–100 之间的 10 个数字，存入一个数组，并排序function random(start,end) &#123; var ichose = end - start + 1 return Math.floor(Math.random() * ichose + start)&#125;var iArry = []for (let i = 0; i &lt; 10; i++) &#123; var tem1 = random(10,100) iArry.push(tem1)&#125;iArry.sort() 把两个数组合并，并删除第二个元素。 12345// 把两个数组合并，并删除第二个元素。var arr1 = [1,2,3,4,5]var arr2 = [1,2,3,4,5]var arr3 = arr1.concat(arr2) // 合并之后返回一个新值arr3.splice(1,1) // 在原值的基础上做操作 怎样添加、移除、移动、复制、创建和查找节点(原生JS) 创建新节点 creatDocumentFragement | creatElement | creatTextNode 添加移除替换插入 appendChild() removeChild() replaceChild() inserBefor() 查找 getElementsByTagName() | getElementByName | getElementById() 从网址‘http://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e’取出参数返回一个json结构 1234567891011121314var urls = 'http://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e' var urlStr = urls.splice('?')[0] var mapS = urls.splice('?')[1].splice('&amp;') // 'a=1','b=2','c=','d=xxx','e=' var result = [] for (let i = 0; i &lt; mapS.length; i++) &#123; const aelement = array[i]; var akey = aelement.splice('=')[0] var avalue = aelement.splice('=')[1] var tempEle = &#123; akey:avalue &#125; result.push(tempEle) &#125; return result; 正则表达式构造函数 var reg = new RegExp(&#39;xxx&#39;) 与字面量var reg = // 有什么不同。匹配邮箱的正则表达式？ 当适用RegExp() 构造函数的时候，不仅需要转义引号(‘\’表示) 而且是需要双反斜杠‘\’使用正则表达式字面亮效率更高 1var regMail = /^[a-zA-Z0-9_-]+@([a-zA-Z0-9_-])+((.[a-zA-Z0-9_-]&#123;2,3&#125;)&#123;1,2&#125;)$/ js事件处理器在线程空闲之前不会运行？如何让让下面代码输出1，2，3 12345678910111213141516for (let i = 1; i &lt;= 3; i++) &#123; setTimeout(() =&gt; &#123; console.log(i) &#125;, 1000);&#125;// 加入异步队列是遍历的时候，执行异步队列的时候，是for循环结束之后再执行setTimeout `输出 3 3 3` // 如果要输出 1 2 3 需要修改成立即执行函数for (let i = 1; i &lt;= 3; i++) &#123; // setTimeout(() =&gt; &#123; // console.log(i) // &#125;, 1000); setTimeout((function (a) &#123; console.log(a) &#125;)(i),0);&#125; 写一个函数，清除字符串前后的空格 trim() 12345678910function trimString()&#123; if (!String.prototype.trim) &#123; String.prototype.trim = function ()&#123; return this.replace(/^\s+/,'').replace(/\s+$/,'') &#125; //\s 匹配空白字符:回车、换行、制表符 tab 空格 &#125;&#125;var testfunc = '\t djhfg djkf d 'console.log(testfunc.trim()) js中的callee 和caller的区别 斐波那契数列 生兔子 caller 返回了一个函数的调用，该函数调用了当前函数 calle 是返回正在被执行的function 函数，也就是指定的function 对象的正文 1234567891011121314151617181920// caller calee 的区别 function test3()&#123; //典型的斐波那契数列 var result=[]; function fn(n)&#123; if(n==1)&#123; return 1; &#125;else if(n==2)&#123; return 1; &#125;else&#123; if(result[n])&#123; return result[n]; &#125;else&#123; //argument.callee()表示 fn() result[n]=arguments.callee(n-1)+arguments.callee(n-2) return result[n]; &#125; &#125; &#125; &#125; JS的一个 ++a和a++ 123456789 function test4()&#123; var a=10, b=20 , c=30; ++a; // a:11 a++; // a:12 e=++a+(++b)+(c++)+a++; // a:13 + 21 + 30 + 13 = 77 // 结束之后 a:14 alert(e);&#125; 写一个函数，返回今天的日期 12345678 function test5()&#123; var d, s="今天日期是:"; d = new Date(); s += d.getMonth() + "/"; //(month:0-11 +1?) s += d.getDate() + "/"; s += d.getFullYear(); return s;&#125; 数组reverse()运用 reverse 方法颠倒数组中元素的位置，并返回该数组的引用 1234567function test6()&#123; var arr1 = [1,3,5] // 0,1,2 arr1[4]= 'z' // arr1: [1,3,5,undefine,'z'] var arr2 = arr1.reverse() // arr2:['z',undefine,5,3,1] arr1:['z',undefine,5,3,1] var arr3 = arr1.concat(arr2) console.log(arr3) // arr3 ['z',,5,3,1,'z',,5,3,1]&#125; 补充按钮事件的函数，确认用户是否退出当前页面，确认之后关闭窗口： 123456789&lt;input type="button" value="关闭窗口" onclick="closeWin()" /&gt;&lt;script type="text/javascript"&gt;function closeWin()&#123; if(confirm("确认要退出吗"))&#123; window.close() &#125;&#125;&lt;/script&gt; 写出简单描述 html 标签(不带属性的开始标签和结束标签)的正则表达式 / 并将以下字符串中的 html 标签去除掉 123var str = “&lt;div&gt;这里是 div&lt;p&gt;里面的段落&lt;/p&gt;&lt;/div&gt;”;var reg = /&lt;\/?\w+\/?&gt;/gistr.replace(reg,''); 根据下拉列表的选项变化，更新图片的显示 123456789101112131415&lt;body&gt; &lt;img id="pic" src="img.jpg" width="200" height="200"&gt; &lt;select id='sel'&gt; &lt;option value="img1"&gt;xxxx&lt;/option&gt; &lt;option value="img2"&gt;xxxx&lt;/option&gt; &lt;option value="img3"&gt;xxx&lt;/option&gt; &lt;option value="img4"&gt;xxx&lt;/option&gt; &lt;/select&gt;&lt;body/&gt;&lt;script&gt; function showImg(oSel)&#123; var str = oSle.value document.getElementById("pic").src = str + '.jpg' &#125;&lt;/script&gt; BOM 常用的4个对象 并列举window对象的常用方法至少5个？ window document location screen history navigator Alert() confirm() prompt() open() close() JS 如何实现继承 原型链继承 借用构造函数继承 组合继承 寄生式继承 寄生组合继承 JS对象创建的几种方式 工厂模式 构造函数模式 原型模式 混合构造函数原型模式 动态原型方式 iframe的优缺点 优点：解决加载缓慢的第三方内容图标和广告等的加载问题 Security sandBox 并行加载脚本 缺点：iframe会阻塞主页面的unload事件 | 即时内容为空，加载也需要时间 | 没有语义 Cookie 的弊端 长度限制 每个doming 最多20条cookie ；每个cookie 长度不能超过4K 安全性 有可能被拦截，原样转发cookie 就可以达到目的 有些状态不可能保留在客户端，需要计算的属性存储在服务器端 JS延迟加载的方式有哪些 defer/async 区别？ 动态加载DOM方式(创建script，插入到DOM中，加载完毕后callBack) 按需异步加载JS 哪些操作会造成内存泄漏 内存泄漏是对象释放后，内存地址还是占用着 垃圾回收机制，引用计数为0的时候，]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试基本分析1]]></title>
    <url>%2F2018%2F12%2F01%2F%E9%9D%A2%E8%AF%95%2Fpreview%2F</url>
    <content type="text"><![CDATA[流程 模拟一面 面试技巧 页面布局类 CSS盒模型 DOM事件类 HTTP协议类 原型链类 面向对象类 通信类 前端安全类 前端算法类 模拟二面 面试技巧 渲染机制类 JS运行机制类 页面性能 错误监控 模拟三面 面试技巧 业务能力 团队协作能力 带人能力 模拟终面 面试技巧 职业竞争力 职业规划 公司招聘 职位描述分析 京东 负责PC端和移动端相关的前端开发工作 负责APP H5 开发，完成界面和后端交互开发 与后端工程师协作 调试数据接口 负责前端组件库的建立 负责对现有系统的优化与重构 精通HTML5 特性，了解最新的HTML5最新规范，能用HTML5特性构建移动WebAPP 熟悉当前流行的JavaScript 类库，熟悉 JavaScript面向对象编程方法 熟悉Web标准 对表现与数据分离 HTML 至少熟悉一种前端MVC框架 并有实战经验 具有前端架构分析与设计能力，习惯于OOP开发方式 熟悉Web前沿技术和新技术调研 了解CSS预编译语言 sass less等 熟悉web构建工具 Grunt Glub 能够自己搭建前端构建环境 有服务端开发者经验者优先 查看公司网站 所包含技术点 &lt;meta&gt; 标签 &lt;link&gt; dns-prefetch 图片/静态资源预解析 &lt;script&gt; async src 异步加载Js文件 Font 字体文件 前端技术栈 jQuery Vue React Node.js Anguarl Sass less Grunt Gulp npm webpack browserify 简历阶段 概况 描述 简洁明了 技能 专业技能，技能点全面 5-10条 经历 公司 - 项目 - 技能点 - 所做贡献 - 成长收获 一面 页面布局 请写出三栏布局 两边宽度100px 中间自适应 5种解决方案： (浮动/绝对定位/table/flex/grid) 各自优缺点 三栏 上中下如何布局 两栏 上下，左右如何布局（固定一个部分） Html标签语义化，页面布局，CSS基础，思维灵活多找哪个解决方案，代码规范 CSS盒模型 DOM事件 HTTP协议 面向对象 原型链 通信 安全 算法 三栏布局技术实现 1.浮动 左右浮动固定宽度，中间自适应 缺点：高度不固定会溢出边界 2.绝对定位 左中右三个模块都绝对定位，中间这只距左右的距离 。自适应 3.flexBox布局 设置父试图 display:flex .左右设置固定宽度 中间设置flex:1 4.表格布局 父控件100% display:table .左中右子空间设置dispaly:table-cell ；之后左右设置固定宽度。中间自适应拉伸 5.grid布局 父识图设置100%； display:grid; grid-template-rows:100px;grid-template-columns:300px auto 300px CSS盒模型 基本概念 标准模型| IE模型 ；区别：宽度计算 1IE模型 width = contentW + paddding + boder CSS如何设置两种模型 1box-sizing:content-box | border-box; JS如何获取盒模型对应的宽和高 12345678dom.style.width/height //只取行间样式设置 可以set设置dom.currentStyle.width/height //ALl可取 IE下 未设置取默认值dom.getComputedStyle(dom).width/height // All可取dom.getBoundingClientRect().widht/heightdom.getComputedStyle是一个可以获取当前元素所有最终使用的CSS属性值。`var style = window.getComputedStyle("元素", "伪类");``getBoundingClientRect`用于获得页面中某个元素的左，上，右和下分别相对浏览器视窗的位置 可以用来判断是否在屏幕上显示 根据盒模型解释边距重叠 垂直边距 正正/负负值 取绝对值大的(20,10) =&gt; 20 一正一负取两个值的绝对值相加(20,-10) =&gt; 30 BFC解决方案 123设置父试图的overflow:overflow:hidden | autoBFC 内子元素即使是float 也会参与高度计算 DOM 事件类 12345- DOM事件模型- DOM事件流- 描述DOM事件捕获的具体流程- Event对象的常见应用- 自定义事件 DOM 事件模型 123DOM0 element.onclick=function()&#123;&#125;DOM2 element.addEventListener('click',function()&#123;&#125;)DOM3 element.addeventListener('keyup',function()&#123;&#125;) DOM事件流 分三个阶段：捕获阶段，目标阶段，事件冒泡阶段 事件冒泡：点击了一个button 向所有的父级一层一层上去传递，为事件冒泡 事件捕获：发生和冒泡顺序相反，window -&gt; doucument -&gt; body -&gt; sectionOne -&gt; button window点击事件更改为使用事件捕获模式。(addEventListener最后一个参数，为true则代表使用事件捕获模式，false则表示使用事件冒泡模式。 123 window.addEventListener('click', function() &#123; console.log('4. You click window');&#125;, true); 事件冒泡阶段是可以被阻止的：stopPropagation 123456 button.addEventListener('click', function(event) &#123; // event为事件对象 console.log('1. You click Button'); event.stopPropagation(); console.log('Stop Propagation!');&#125;, false); Event对象常见的应用 12345event.preventDefault() // 阻止事件的默认动作event.stopPropagation() // 阻止冒泡 阻止后续的监听event.stopImmediatePropagation() // 阻止冒泡 包括本身event.currentTarget // 监听事件者event.target // 事件的真正发出者 自定义事件 new Event(‘eventName’) abutton.addEventListener(‘’,function(){}) abuton.dispatchEvent(aevent) 12345var eve = new Event('aeventName')adiv.addEventListener('aeventName',function()&#123; console.log('test cuntomerEvent')&#125;)adiv.dispatchEvent(eve) HTTP协议类 特点：简单快速|灵活|无连接|无状态 报文的组成部分 (请求行 请求头 空行 请求体) | (状态行 相应头 空行 响应体) HTTP方法 ： GET获取资源/POST传输资源/PUT更新资源/DELETE删除资源/HEAD获得报文首部 GET/POST的区别 回退 get返回不刷新界面 / post会重新请求 URL收藏 get可以被收藏 / post不可以 主动缓存 get可以被缓存 / post要主动手动设置缓存 编码 get 只支持URL编码 / post支持多种 浏览记录参数 get完整保留 / post参数不会被保留 长度限制 get参数长度是限制的 / post没有限制 参数数据类型 get只接受ASCII字符 / post无限制 安全性 get不安全参数暴露 不能传递敏感信息 参数位置 get参数在URL / post在body里 HTTP状态码 1XX：指示信息 - 表示请求已接收，继续处理 2XX：成功 - 表示请求已被成功接收 3XX：重定向 - 要完成请求必须进行更近一步的操作 4XX：客户端错误 - 请求右语法错误或请求无法实现 5XX：服务器错误 - 服务器未能实现合法的请求 持久链接 Keep-Alive。 HTTP协议采用请求-应答模式，普通模式每个应答 客户端和服务器都要新建一个链接，完成之后立即断开链接 实用Keep-Alive模式时 客户端-服务端的连接持续有效，当有对服务器其他请求，避免新建或重新建立连接 管线化 管线化机制是通过持久化连接完成，仅Http 1.1 支持 只有GET/HEAD请求可以进行管线化，POST有所限制 初次建立连接不启动管线机制，因为服务器不一定支持http1.1的协议 管线化不影响应到来的顺序，请求1，请求2，请求3，响应1，响应2，响应3 Http1.1 要求服务器支持管线化，不是要求服务器端对相应进行管线化的处理，只是要求 管线化的请求 不处理失败。就是支持处理管线化的请求，不要求对相应消息管线化 开启管线化可能并不会带来大幅度的性能提升，而且很多服务器和代理程序对管线化支持并不好，因此Chrome/Firefox 默认不开启管线化支持 原型链 原型 构造函数 实例 原型链 的关系 instanceof 的原理 new运算符原理 代码类似如下 类的声明-实例 | 类的继承(如何实现，继承的几种方式) 借助构造函数实现继承 12345678910111213function Parent1()&#123; this.name = 'parent1'&#125;Parent1.prototype.say = function () &#123; console.log('test say')&#125;function Child1()&#123; Parent1.call(this); // apply this.type = 'child1'&#125;问题：只继承了父类的属性，没有继承父类的原型属性和方法 2:借助原型链实现继承 12345678function Parent2()&#123; this.name = 'parent2'&#125;function Child2()&#123; this.type = 'child2'&#125;Child2.prototype = Parent2.prototype缺点：继承了原型，但是实例属性没有继承 3:(1/2)组合方式 123456789function Parent3()&#123; this.name = 'parent3'&#125;function Child3()&#123; Parent3.call(this) this.type = 'child3'&#125; Child3.prototype = Parent3.prototype构造器是父类的构造器 4组合方式优化： 123456789function Parent4()&#123; this.name = 'parent4'&#125;function Child4()&#123; Parent3.call(this) this.type = 'child4'&#125; Child4.prototype = Object.create(Parent4.prototype)Child4.prototype.constructor = Child4 同源策略及限制 前后端如何通信 同源策略限制从一个源加载的文档或脚本如何与另一个源的资源进行交互；是用于隔离潜在恶意文件中国呢的关键的安全机制 Cookie LocalStorage IndexDB无法读取；DOM无法获得；AJAX请求不能发送 通过：Ajax;WebScoket;CORS; 如何创建Ajax XMLHttpRequest 对象的工作流程 兼容性处理 事件的触发条件 事件的触发顺序 跨域通信的几种方式 jsonp hash postmessage webScoket CORS 安全类 CSRF 跨站请求伪造 cross-site-request-forgery 引诱点击 XSS 跨域脚本攻击 cross-site-scripting (攻击原理 防御措施) CSRF的防御措施 Token验证| Referer 验证 | 隐藏令牌 算法类 排序(快速排序/选择排序/希尔排序) 堆栈/队列/链表 递归 波兰式和逆波兰式 渲染机制/运行机制/页面性能/错误监控 渲染机制 DOCTYPE-&gt;浏览器渲染过程-&gt;重排Reflow-&gt;重绘Repaint-&gt;布局Layout JS运行机制 单线程 / 任务队列 / EventLoop 打印A，死循环不会输出B，单线程 编译主文档之后才会走异步队列 输入4 个 4 JS异步任务 setTimeout 和 setInterval | DOM事件 | ES6的Promise 理解哪些语句会放入异步任务队列 理解语句放入异步任务队列的时机 页面性能类 提升性能的 方法有哪些 资源压缩合并 减少HTT请求 非核心资源异步加载|异步加载的方式 | 异步加载的区别 使用CDN 预解析DNS 异步加载的方式： 动态脚本加载|defer| async defer会在HTML解析完成之后才会执行 如果多个按加载的顺序执行 async 加载完成之后立即执行 如果是多个执行顺序和加载顺序无关。加载完成时间 看async的资源多少 缓存的分类 强缓存|协商缓存 强缓存 (Expiree Cache-Control) 协商缓存(Last-modified if-Moldified-Since Etag if-None-Match) 错误监控类(错误的分类|错误的捕获方式|上报错误的基本原理) 错误的分类分两种：即时运行错误代码错误 资源加载错误 运行错误的捕获方式：try catch | window.onerror 资源加载错误的捕获方式object.onerror | peformance.getEntries() | Error时间捕获 跨域JS运行错误的捕获处理? 错误信息Script error 处理：1.在script标签中增加crossorigin 2设置JS资源响应头Access-Control-Allow-Origin 上报错误的基本原理：采用Ajax通信的方式上报 2采用Image 对象上报 其他总结： 业务能力 团对协作能力 事务推动能力 待人能力 其他能力]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数式编程-链式编程]]></title>
    <url>%2F2017%2F06%2F13%2F2017b%2F%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-%E9%93%BE%E5%BC%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1 函数式编程，链式编程定义 准备工作：自定义一个基类重写description 打印model 的时候能打印所有的属性 OC 中应用函数式编程，方法后面拼接()要能继续执行下去，所有要有返回值，使用block，返回值式自己。 方法的实现： 直接返回return，简写如下： 2 Swift是适合函数式编程 ，方法后面带有(),如果需要执行下去，加上返回值是自己的就可以链式编程下去。 形式 实现 3 响应式编程RAC - 集成注意点 选择框架 纯 swift 项目，继续使用 ReactiveCocoa 。但是 RAC 依赖于 ReactiveSwift ，等于你引入了两个库。 纯 OC 项目，需要使用 ReactiveObjC 。这个库里面包含原来 RAC 2的全部代码。 项目是 swift 和 OC 混编，需要同时引用 ReactiveCocoa 和 ReactiveObjCBridge 。但是 ReactiveObjCBridge 依赖于 ReactiveObjC ，所以你就等于引入了 4 个库。 集成环境配置 如果项目不是纯OC项目，那么编辑Podfile文件添加了pod ‘ReactiveCocoa’, ‘~&gt; 5.0.3’以后一定别忘了添加一行use_frameworks!用于生成动态链接库。 Xcode8导入时因为Swift2.3与Swift3.0的关系，导入后，无法成功编译程序，工程会弹出一个选择框，最好选第一个later，跳过swift编译。之后修改pod项目的Bulid Settings里搜swift_version之后把Swift Language Version变成3.0在使用command+shift+k进行clear下项目就OK了。 4 RAC应用 iOS中的事件 目标（方法），代理，通知，KVO，时钟，网络 rac_signalForControlEvents target rac_signalForSelector 代理 rac_addObserverForName 通知 rac_valuesAndChangesForKeyPath KVO 创建信号RACSignal createSignal 信号， RACSignal 状态： 热信号：有订阅者，一旦订阅信息，就会执行 冷信号 只是定义，没有订阅，只是信号对象，不会工作 5 订阅者： 视图控制器需要知道加载数据的情况 订阅三种类型，next ID类型，error：出错处理，completion表示信号完成 加载过后订阅 6 RAC系统学习 ReactiveCocoa常见类有哪些？ RACSignal:表示有数据传递的时候 RACDisposable:取消订阅信号 RACSubscriber:订阅者,发送数据]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>runloop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[runTime]]></title>
    <url>%2F2017%2F02%2F13%2F2017b%2FrunTime%2F</url>
    <content type="text"><![CDATA[1. runTime 方法 class_copyPropertyList 获取类属性列表使用class_copyPropertyList()方法 C语言函数，copy之后需要free() 使用字典转模型 获得self的属性列表，遍历字典，如果key 值在数组中，进行KVC赋值， cz_objectProperties方法会调用很多变，需要进行关联缓存处理 从关联对象中获取对象属性，如果有，直接返回 获取之后的数组，objc_setAssociatedObject 添加关联对象 2.方法交换 load 方法中交换， 在类被加载到运行时的时候，就会被执行 method_exchangeImplementations() 执行之后，交换2个方法 调用setImage：相当于调用cz_setImage： 调用cz_setImage：相当于调用setImage：]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>runTime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[runloop解决Cell上主线程卡顿]]></title>
    <url>%2F2017%2F02%2F12%2F2017b%2Frunloop%E8%A7%A3%E5%86%B3Cell%E4%B8%8A%E4%B8%BB%E7%BA%BF%E7%A8%8B%E5%8D%A1%E9%A1%BF%2F</url>
    <content type="text"><![CDATA[1解决cell上的主线程加载卡顿问题 通过添加runloop 观察者，卡顿等待的时候进行处理 视频地址 http://v.youku.com/v_show/id_XODgxODkzODI0.html RunLoopMode 5 种mode 使用 C 创建观察者 获取当前的runloop: CFRunLoopRef runloop = CFRunLoopGetCurrent(); 创建观察者 参数1：分配者，NUll 或者Defaul ,参数2:活动标志，等待前处理，参数3:重复，参数4:从0开始，参数5：监听到的回调函数地址，参数6:观察者上下文，结构体指针 上面参数callout,需要传入函数的地址，观察者，活动状态，本文背景是等待的情况下，传入的info 添加观察者 在回调中回去self，获取不到，需要用上下文中的info参数传递， 在上面回调中处理cell中添加的任务 cell中的任务加载block中，将代码块添加到数组中,延迟执行 将任务加入到任务数组中 callback 方法中，执行任务，执行之后删除任务]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>runloop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片打码(系统自带 VS openCV)]]></title>
    <url>%2F2017%2F02%2F10%2F2017b%2F%E5%9B%BE%E7%89%87%E6%89%93%E7%A0%81(%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%B8%A6%20VS%20openVC)%2F</url>
    <content type="text"><![CDATA[1.实用系统自带的API进行图片打码 原图片进行打码，没有头像检测，全部打码 获取图像上下文， 获取宽高 获取颜色空间 创建图像内容上下文 根据上下文绘制图片 获取上下文绘制的图片空间，内存地址 根据内存中地址，运用C函数，自己定义算法进行打码处理，（可以局部打码） 根据像素点处理好的图片内存，获取图片数据集合， 输出图片 释放内存]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>openVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片转化为视频]]></title>
    <url>%2F2017%2F02%2F03%2F2017b%2F%E5%9B%BE%E7%89%87%E8%BD%AC%E5%8C%96%E4%B8%BA%E8%A7%86%E9%A2%91%2F</url>
    <content type="text"><![CDATA[图片转为视频流 使用 AVAssetWriter. AVAssetWriterInputPixelBufferAdaptor 处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// 图片转为视频频- (void) testchangeImageToVideo&#123; NSArray *imageArr = [NSArray arrayWithObjects:[[UIImage imageNamed:@"114.png"] CGImage],[[UIImage imageNamed:@"114.png"] CGImage],[[UIImage imageNamed:@"placeholderImage.png"] CGImage],[[UIImage imageNamed:@"dfd.png"] CGImage],[[UIImage imageNamed:@"viewbg.png"] CGImage], nil]; CGSize size = CGSizeMake(480, 320); NSString *betaCompressionDirectory = [NSHomeDirectory() stringByAppendingPathComponent:@"Documents/Movie.m4v"]; NSError *error = nil; unlink([betaCompressionDirectory UTF8String]); AVAssetWriter *videoWriter = [[AVAssetWriter alloc] initWithURL:[NSURL fileURLWithPath:betaCompressionDirectory] fileType:AVFileTypeQuickTimeMovie error:&amp;error]; NSParameterAssert(videoWriter); if(error) NSLog(@"error = %@", [error localizedDescription]); NSDictionary *videoSettings = [NSDictionary dictionaryWithObjectsAndKeys:AVVideoCodecH264, AVVideoCodecKey, [NSNumber numberWithInt:size.width], AVVideoWidthKey, [NSNumber numberWithInt:size.height], AVVideoHeightKey, nil]; AVAssetWriterInput *writerInput = [AVAssetWriterInput assetWriterInputWithMediaType:AVMediaTypeVideo outputSettings:videoSettings]; NSDictionary *sourcePixelBufferAttributesDictionary = [NSDictionary dictionaryWithObjectsAndKeys: [NSNumber numberWithInt:kCVPixelFormatType_32ARGB], kCVPixelBufferPixelFormatTypeKey, nil]; AVAssetWriterInputPixelBufferAdaptor *adaptor = [AVAssetWriterInputPixelBufferAdaptor assetWriterInputPixelBufferAdaptorWithAssetWriterInput:writerInput sourcePixelBufferAttributes:sourcePixelBufferAttributesDictionary]; NSParameterAssert(writerInput); NSParameterAssert([videoWriter canAddInput:writerInput]); if ([videoWriter canAddInput:writerInput]) NSLog(@"I can add this input"); else NSLog(@"i can't add this input"); [videoWriter addInput:writerInput]; [videoWriter startWriting]; [videoWriter startSessionAtSourceTime:kCMTimeZero]; // insert demo debugging code to write the same image repeated as a movie CGImageRef theImage = [[UIImage imageNamed:@"114.png"] CGImage]; dispatch_queue_t dispatchQueue = dispatch_queue_create("mediaInputQueue", NULL); int __block frame = 0; [writerInput requestMediaDataWhenReadyOnQueue:dispatchQueue usingBlock:^&#123; while ([writerInput isReadyForMoreMediaData])&#123; if(++frame &gt;= imageArr.count * 40)&#123; [writerInput markAsFinished]; [videoWriter finishWriting]; break; &#125; int idx = frame/40; CVPixelBufferRef buffer = (CVPixelBufferRef)[self pixelBufferFromCGImage:(__bridge CGImageRef)([imageArr objectAtIndex:idx]) size:size]; if (buffer)&#123; if(![adaptor appendPixelBuffer:buffer withPresentationTime:CMTimeMake(frame, 20)]) NSLog(@"FAIL"); else NSLog(@"Success:%d", frame); CFRelease(buffer); &#125; &#125; &#125;];NSLog(@"outside for loop");&#125;- (CVPixelBufferRef )pixelBufferFromCGImage:(CGImageRef)image size:(CGSize)size&#123; NSDictionary *options = [NSDictionary dictionaryWithObjectsAndKeys: [NSNumber numberWithBool:YES], kCVPixelBufferCGImageCompatibilityKey, [NSNumber numberWithBool:YES], kCVPixelBufferCGBitmapContextCompatibilityKey, nil]; CVPixelBufferRef pxbuffer = NULL;CVReturn status = CVPixelBufferCreate(kCFAllocatorDefault, size.width, size.height, kCVPixelFormatType_32ARGB, (__bridge CFDictionaryRef) options, &amp;pxbuffer); // CVReturn status = CVPixelBufferPoolCreatePixelBuffer(NULL, adaptor.pixelBufferPool, &amp;pxbuffer); NSParameterAssert(status == kCVReturnSuccess &amp;&amp; pxbuffer != NULL); CVPixelBufferLockBaseAddress(pxbuffer, 0); void *pxdata = CVPixelBufferGetBaseAddress(pxbuffer); NSParameterAssert(pxdata != NULL); CGColorSpaceRef rgbColorSpace = CGColorSpaceCreateDeviceRGB(); CGContextRef context = CGBitmapContextCreate(pxdata, size.width, size.height, 8, 4*size.width, rgbColorSpace, kCGImageAlphaPremultipliedFirst); NSParameterAssert(context); CGContextDrawImage(context, CGRectMake(0, 0, CGImageGetWidth(image), CGImageGetHeight(image)), image); CGColorSpaceRelease(rgbColorSpace); CGContextRelease(context); CVPixelBufferUnlockBaseAddress(pxbuffer, 0); return pxbuffer; &#125;]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>实用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swiftSQLite]]></title>
    <url>%2F2016%2F09%2F28%2F2016b%2FswiftSQLite%2F</url>
    <content type="text"><![CDATA[使用FMDB 存储本地数据，增删改查 创建管理类 使用当前用户的ID， 返回需要的字典数组 回滚的处理 从本地加载数据，和网络请求数据的参数一样，方便处理，在viewModel中，内部处理VC不关心是从本地还是从网络数据 ViewModel 中，不改变控制器代码，增加本地数据读取 加载完成网络数据时，把数据存入本地数据库中， 仿SDWebImage 固定时间清楚缓存 SDWebImage 的监听系统时间， 在程序中，没有通过sql 指定字段的值，就使用default 的值替代 清楚缓存 如果超过了7天之后，把日期小于7天前的日期数据删除]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Swift学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>SQLite</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift泛型]]></title>
    <url>%2F2016%2F09%2F27%2F2016b%2Fswift%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[1.类型约束 你可以在一个类型参数名后面放置一个类名或者协议名，并用冒号进行分隔，来定义类型约束，它们将成为类型参数列表的一部分。对泛型函数添加类型约束的基本语法如下所示（作用于泛型类型时的语法与之相同）： 下面展示了 findIndex(ofString:in:) 函数的泛型版本 findIndex(ofString:in:)。请注意这个函数返回值的类型仍然是 Int?，这是因为函数返回的是一个可选的索引数，而不是从数组中得到的一个可选值。需要提醒的是，这个函数无法通过编译，原因会在例子后面说明： 上面所写的函数无法通过编译。问题出在相等性检查上，即 if value == valueToFind。不是所有的 Swift 类型都可以用等式符（==）进行比较。比如说，如果你创建一个自定义的类或结构体来表示一个复杂的数据模型，那么 Swift 无法猜到对于这个类或结构体而言“相等”意味着什么。 Swift 标准库中定义了一个 Equatable 协议，该协议要求任何遵循该协议的类型必须实现等式符（==）及不等符(!=) ,所有的 Swift 标准类型自动支持 Equatable 协议 findIndex(of:in:) 唯一的类型参数写做 T: Equatable，也就意味着“任何符合 Equatable 协议的类型 T 2.关联类型 定义一个协议时，有的时候声明一个或多个关联类型作为协议定义的一部分将会非常有用。关联类型为协议中的某个类型提供了一个占位名（或者说别名），其代表的实际类型在协议被采纳时才会被指定。你可以通过 associatedtype 关键字来指定关联类型。 协议没有指定容器中元素的类型，只指定了遵守协议，必须实现的方法，同时声明了associatedtype 的ItemType 关联类型。这个协议无法定义 ItemType 是什么类型的别名，这个信息将留给遵从协议的类型来提供 intStack 遵守Container 协议，需要实现协议的方法，指定关联类型的真是类型。 由于swift中的类型推导，不用写typealias ItemType = Int ,省略这一句，会推导append(item:) 方法，传的是什么类型， Stack 遵守Container协议，stack 是范型，具体的类型，有外部就决定 append(item:) 传入的是范型的类型：代码如下 3.范型where 语句 为关联类型定义约束也是非常有用的，可以在参数列表中通过where语句，为关联类型定义约束。 where 使用场景 可以通过where 语句，要求关联类型遵守特定的协议，以及某个参数的类型必须和关联类型的类型相同， 可以通过where语句，紧跟参数列表后面来定义where语句，where子句后面跟一个或者多个针对关联类型的约束，以及一个或者多个参数类型和关联类型的相等关系。 可以在函数体或类型大括号之前添加where语句 例子检验2个容器是不是相同，其中元素个数，顺序，顺序上的值是否都相同？ 这个函数接受 someContainer 和 anotherContainer 两个参数。参数 someContainer 的类型为 C1，参数 anotherContainer 的类型为 C2。C1 和 C2 是容器的两个占位类型参数，函数被调用时才能确定它们的具体类型 C1 必须符合 Container 协议（写作 C1: Container）。 C2 必须符合 Container 协议（写作 C2: Container）。 C1 的 ItemType 必须和 C2 的 ItemType类型相同 ，C1 的 ItemType 必须符合 Equatable 协议，第三个和第四个要求被定义为一个 where 子句，写在关键字 where 后面，它们也是泛型函数类型参数列表的一部分 someContainer和 anotherContainer可以通过!= 操作其中的元素]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Swift学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>swift泛型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift协议]]></title>
    <url>%2F2016%2F09%2F26%2F2016b%2Fswift%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[1.协议 协议的语法： 定义协议 遵守协议：在类型名称后面，加上协议名称，用: 隔开，协议之间用,隔开 继承父类的子类的时候，应该把父类写在协议前面， 12protocol SomeProtocol &#123;&#125;class SomeClass: SomeSuperClass, FirstProtocol, AnotherProtocol &#123;&#125; 属性要求 协议中定义了属性，遵守该协议的实例或类型，必须有这个属性 协议的中定义属性，只指定属性的名称和类型，还指定属性的可读性，可写性， 方法要求 和普通方法一样，但不需要{} 和方法体，方法的参数列表也不支持默认值 Mutating 方法要求 如果你在协议中定义了一个实例方法，该方法会改变遵循该协议的类型的实例，那么在定义协议时需要在方法前加 mutating 关键字。这使得结构体和枚举能够遵循此协议并满足此方法要求。 构造器要求 协议可以要求遵循协议的类型实现指定的构造器。你可以像编写普通构造器那样，在协议的定义里写下构造器的声明，但不需要写花括号和构造器的实体 实现的时候，遵守代理的构造器方法需要加上关键字required 如果一个类是定义了final,不需要在写required，因为不会有子类，final是为了防止重写 如果子类重写了父类的指定构造器，并且指定构造器遵循了某个协议，该方法同时需要写关键字required和overri 协议作为类型 1234567891011class Dice &#123; let sides: Int let generator: RandomNumberGenerator init(sides: Int, generator: RandomNumberGenerator) &#123; self.sides = sides self.generator = generator &#125; func roll() -&gt; Int &#123; return Int(generator.random() * Double(sides)) + 1 &#125;&#125; Dice 类提供了一个名为 roll 的实例方法，用来模拟骰子的面值。它先调用 generator 的 random() 方法来生成一个 [0.0,1.0) 区间内的随机数，然后使用这个随机数生成正确的骰子面值。因为 generator 遵循了 RandomNumberGenerator 协议，可以确保它有个 random() 方法可供调用 2.委托（代理）模式 protocol - delegate 3.通过扩展添加协议一致性，通过扩展遵循协议 当一个类型已经符合了某个协议中的所有要求，却还没有声明遵循该协议时，可以通过空扩展体的扩展来遵循该协议： 4.协议类型的集合，协议的继承 协议能够继承一个或多个其他协议，可以在继承的协议的基础上增加新的要求 例子中定义了一个新的协议 PrettyTextRepresentable，它继承自 TextRepresentable 协议。任何遵循 PrettyTextRepresentable 协议的类型在满足该协议的要求时，也必须满足 TextRepresentable 协议的要求 5.类类型专属协议 只适用一某种类型 6.协议合成 有时候需要同时遵循多个协议，你可以将多个协议采用 SomeProtocol &amp; AnotherProtocol 这样的格式进行组合，称为 协议合成（protocol composition）。你可以罗列任意多个你想要遵循的协议，以与符号(&amp;)分隔。 7.检查协议一致性 Circle，Country，遵守了HasArea协议，协议中有只读的area属性 Animal 没有遵守HasArea协议 上面三个各自实例，判断是不是符合某个协议的，使用as?, 返回可选值，进行可选值绑定 8.可选的协议要求 可选的时候使用optional 关键字 可选要求用在你需要和 Objective-C 打交道的代码中。协议和可选要求都必须带上@objc属性 1234@objc protocol CounterDataSource &#123; optional func incrementForCount(count: Int) -&gt; Int optional var fixedIncrement: Int &#123; get &#125;&#125; 8.协议扩展 协议可以通过扩展来为遵循协议的类型提供属性、方法以及下标的实现。通过这种方式，你可以基于协议本身来实现这些功能，而无需在每个遵循协议的类型中都重复同样的实现，也无需使用全局函数 扩展RandomNumberGenerator协议,增加randomBool() 方法 12345extension RandomNumberGenerator &#123; func randomBool() -&gt; Bool &#123; return random() &gt; 0.5 &#125;&#125; 提供默认实现 为协议扩展添加限制条件 在扩展协议的时候，可以指定一些限制条件，只有遵循协议的类型满足这些限制条件时，才能获得协议扩展提供的默认实现。这些限制条件写在协议名之后，使用 where 子句来描述 textualDescription返回整个集合的文本描述，讲文本描述用，拼接起来，包括在【】中 Hamster 结构体符合TextRepresentable协议，放在一个数组中，array 符合CollectionType协议， 可以进行textualDescription方法， 如果多个协议扩展都为同一个协议要求提供了默认实现，而遵循协议的类型又同时满足这些协议扩展的限制条件，那么将会使用限制条件最多的那个协议扩展提供的默认实现]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Swift学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>protocol</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift扩展Extensions]]></title>
    <url>%2F2016%2F09%2F25%2F2016b%2Fswift%E6%89%A9%E5%B1%95Extensions%2F</url>
    <content type="text"><![CDATA[1.Extension 扩展 就是为一个已有的类、结构体、枚举类型或者协议类型添加新功能 语法：extension SomeType { } 可以使用的功能： 添加计算行属性，计算类型属性 定义实例方法和类型方法 提供新的构造器 定义下标 定义和使用新的嵌套类型 使用已有类型符合某个协议。 计算型属性 为一个类增加计算属性 构造器 扩展能为类添加新的便利构造器，但是它们不能为类添加新的指定构造器或析构器。指定构造器和析构器必须总是由原始的类实现来提供 方法 扩展可以为已有类型添加新的实例方法和类型方法 使用: 3.repetitions({ print(“Hello!”)}) 可变实例方法： 结构体和枚举中，修改self或其属性方法，必须加上mutating 下标 扩展可以为已有类型添加新下标。这个例子为 Swift 内建类型 Int 添加了一个整型下标。该下标 [n] 返回十进制数字从右向左数的第 n 个数字 嵌套类型 为Int添加了嵌套枚举，用来表示是正数，负数，0]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Swift学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>extension</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift错误处理]]></title>
    <url>%2F2016%2F09%2F24%2F2016b%2Fswift%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[1.表示并抛出错误 在 Swift 中，错误用符合Error协议的类型的值来表示 12345enum VendingMachineError: Error &#123; case invalidSelection //选择无效 case insufficientFunds(coinsNeeded: Int) //金额不足 case outOfStock //缺货&#125; swift 枚举，创建一组错误状态，枚举关联值，可以提供错误状态额外信息，遇见错误的时候，可以抛出异常，使用throw throw VendingMachineError. insufficientFunds(coinsNeeded: 5) 2.处理错误 swift 中有4中错误处理方法： 可以讲函数抛出的异常，传递给调用函数的代码 使用do-cantch 语句处理错误 讲错误当作可选项处理 断言此处不会出现错误 3.用 throwing 函数传递错误 在函数声明参数列表之后加上throw，在箭头（-&gt;） 前面 func canThrowErrors() throws -&gt; String 因为vend(itemNamed:)方法能抛出错误，所以在调用的它时候在它前面加了try关键字。 4.用 Do-Catch 处理错误 如果在do子句中的代码抛出了一个错误，这个错误会与catch子句做匹配，从而决定哪条子句能处理它。 5.将错误转换成可选值 try? 如果someThrowingFunction()抛出一个错误，x和y的值是nil。否则x和y的值就是该函数的返回值 6.禁用错误传递 有时你知道某个throwing函数实际上在运行时是不会抛出错误的，在这种情况下，你可以在表达式前面写try! 7.指定清理操作 可以使用defer语句在即将离开当前代码块时执行一系列语句。该语句让你能执行一些必要的清理工作，不管是以何种方式离开当前代码块的——无论是由于抛出错误而离开，还是由于诸如return或者break的语句 上面的代码使用一条defer语句来确保open(:)函数有一个相应的对close(:)函数的调用。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Swift学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义刷新控件]]></title>
    <url>%2F2016%2F09%2F24%2F2016b%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%B7%E6%96%B0%E6%8E%A7%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[1.自定义刷新控件 -控制逻辑 创建JYRefreshControl 基于UIControl 控制逻辑判断 2.自定义刷新控件视图 -控制界面显示或者动画 创建XIB实现UI view布局，通过control 得到父视图高度控制view的变化 3. JYRefreshControl 初始化init方法，创建UI，此时没有设置高度，没有frame 创建scrollview 记录父视图 创建refreshView负责视图展示 12345678init()&#123; super.init(frame: CGRect()) setupUI()&#125;required init?(coder aDecoder: NSCoder) &#123; super.init(coder: aDecoder); setupUI()&#125; 设置刷新状态的枚举 重写父类的方法willMove toSuperView 上记录父视图，添加观察者 重写父类的移除视图的时候移除观察者 实现KVO 方法，根据监听到的父视图的滑动，设置view的frame，把高度传到refreshView中 根据滑动的高度，设置frame 在拖拽的时候进行状态判断 不在拖拽的时候，状态是拖拽了，松手刷新，状态设置为刷新，执行beginRefreshing beginRefreshing() 方法 endRefreshing() 方法 4.JYNomalRefreshView init 方法 加载loadnib 方法 nibName 可以是子类，通过nibName 的改变切换不同的显示内容，在View 的拖出来的视图，是可选的，子类不一定有 在state的didset方法中设置UI ios 中旋转动画默认是 1.顺时针的旋转， 2.就近原则 实现同方向旋转，减少一个极小的值 如果旋转360，使用CABaseAnimation动画 5.刷新动画 awakeFromNib() 进行动画的执行 通过2张图片合成，实现1张GIF效果 使用CABasicAnimation 动画实现无限旋转 实现CGAffineTransform缩放动画，设置layer的锚点，先设置center，或者frame，再设置锚点，]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Swift学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图文混排]]></title>
    <url>%2F2016%2F09%2F24%2F2016b%2F%E5%9B%BE%E6%96%87%E6%B7%B7%E6%8E%92%2F</url>
    <content type="text"><![CDATA[1.NSTextAttachment 实现图文混排 图片附件 lineHeight 大致和字体的大小相等 bounds ,x,y 决定内部子控件相对远点的位置 图片属性文本 12345678910111213141516func textTextKit()&#123; let attchment = NSTextAttachment() // 图片附件 attchment.image = UIImage(named: "hehheheh"); // lineHeight 大致和字体的大小相等 let height = lable.font.lineHeight // frame x,y 决定当前控件，相对父控件的位置 // bounds ,x,y 决定内部子控件相对远点的位置 attchment.bounds = CGRect(x: 0, y: -4, width: height, height: height) //图片属性文本 let attst1 = NSAttributedString(attachment: attchment) let attrStrM = NSMutableAttributedString(string: "我") attrStrM.append(attst1) attrStrM.append(NSAttributedString(string: "99999")) lable.attributedText = attrStrM &#125; {% asset_img 图文混排1.png 400 %} 2.TextKit 重绘实现图文混排 NSTextStorage 管理NSLayoutManager 对象，字符或者属性变化的时候，通知LayoutManager重新布局并显示文本 NSLayoutManager 负责协调布局，显示NSTextStorage对象中保存的字符，将字形设置为一系列NSTextContainer 对象，然后以系列文本视图对象显示 NStextContainer 也可以定义一个排除路径，定义一下矩形区域，在layoutSubviews中更新调用 12345678// 属性文本存储 是 NSMutableAttributedString子类private lazy var textStore = NSTextStorage()// 负责文本“字形”布局private lazy var layoutManager = NSLayoutManager()// 设定文本绘制的的范围private lazy var textContainer = NSTextContainer () 代码实现 在init方法中设置prepareTextSystem 1.准备文本 2.设置对象关系 3.在layoutSubviews指定区域 4.重写drawText 方法，重新绘制 绘制类似油画，后绘制的内容，会把之前绘制的内容覆盖 定义只读属性urlRanges:[NSRange]? 字符串中的网址range 在touchesBegan 中判断点击的index 在不在urlRanges 中，如果在，显示点击变色 获取点击的索引 判断点击的字符 indx 是不是再urlRanges范围内，如果在就高亮 需要重绘，调用setNeedsDisplay函数，但是不是drawrect 3.UITextView 的XIB处理 进制滚动 拖拽回收键盘 4.切换键盘 自定义view 点击切换，如果是nil显示，如果不是nil,隐藏 刷新键盘 reloadInputViews 5. UITextView 的常用的三个方法 是否为空 hasText() -&gt; Bool 插入字符串 insertText(_ text: String ) 向前删除 deleteBackward() 插入字符串 textVIew.replace(&lt;#T##range: UITextRange##UITextRange#&gt;, withText: &lt;#T##String#&gt;) 6.监听键盘的方法 监听键盘通知， 获取键盘高度和键盘动画 设置底部约束高度 更新约束 执行动画 12// 监听键盘通知，NotificationCenter.default.addObserver(self, selector: #selector(keybordChanged), name: NSNotification.Name.UIKeyboardWillChangeFrame, object: nil); 123deinit &#123; NotificationCenter.default.removeObserver(self)&#125; 12345678910111213guard let rect = (noti.userInfo?[UIKeyboardFrameEndUserInfoKey] as? NSValue)?.cgRectValue, let duration = (noti.userInfo?[UIKeyboardAnimationDurationUserInfoKey] as? NSNumber)?.doubleValue else&#123; return &#125;// 设置底部约束高度let offsite = view.bounds.height - rect.origin.y// 更新约束viewToButtonH.constant = offsite// 执行动画UIView.animate(withDuration: duration) &#123; self.view.layoutIfNeeded()&#125; 7.图文混排，图片插入文字中 获取表情中的图像属性文本 使用attemnet 设置当前的textview的属性文本，可变的 将图像的属性文本插入到当前的光标位置 记录光标位置 重新设置文本 回复光标位置 1234567891011121314151617181920// 获取表情中的图像属性文本 使用attemnetlet imageText = NSAttributedString(string: "ceshi", attributes: [NSFontAttributeName:UIFont.systemFont(ofSize: 12)])// 设置当前的textview的属性文本，可变的let attrStrM = NSMutableAttributedString(attributedString: textVIew.attributedText)// 将图像的属性文本插入到当前的光标位置attrStrM.replaceCharacters(in: textVIew.selectedRange, with: imageText)// 记录光标位置let range = textVIew.selectedRange// 重新设置文本textVIew.attributedText = attrStrM// 回复光标位置textVIew.selectedRange = NSRange(location: range.location + 1, length: 0) 8. 变量可变字符串寻找图片附件 字典中包含 NSAttachment key 说明是图片，否则是文本 12345678let aAttr = NSAttributedString(string: "ceshi", attributes: [NSFontAttributeName:UIFont.systemFont(ofSize: 12)])aAttr.enumerateAttributes(in: NSRange(location: 0, length: aAttr.length), options: []) &#123; (dic, range, _) in // 字典中包含 NSAttachment key 说明是图片，否则是文本 let arrrment = dic["NSAttachment"] &#125; 9.UIcode编码 uiicode 的编码，展现是啊用UTF8 1-4个字节表示一个字符 实例化字符扫描 从code中 扫描出16进制的数值 使用uint32的数值，生成UTF8 的字符 1234567let code = "0x1f633"let scanner = Scanner(string: code)var result :uint = 0scanner.scanHexInt32(&amp;result)let c = Character(UnicodeScalar(result)!)let emojy = String(c)print("\(emojy)") uibutton 的设置nil 设置图像，如果图像为nil,会清空图像，避免复用 设置标题 10.图片拉伸处理]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Swift学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GCD调度组]]></title>
    <url>%2F2016%2F09%2F24%2F2016b%2FGCD%E8%B0%83%E5%BA%A6%E7%BB%84%2F</url>
    <content type="text"><![CDATA[GCD 调度组-oc 调度组是最重要的一监听一组任务的完成 创建调度组 创建队列 调度组监听队列调度任务 1234567891011121314dispatch_group_t group = dispatch_group_create();dispatch_queue_t que = dispatch_get_global_queue(0, 0);dispatch_async(que, ^&#123; NSLog(@"aaaaa%@",[NSThread currentThread]);&#125;);dispatch_async(que, ^&#123; NSLog(@"bbbbb%@",[NSThread currentThread]);&#125;);dispatch_async(que, ^&#123; NSLog(@"ccccccc%@",[NSThread currentThread]);&#125;);dispatch_group_notify(group, que, ^&#123; NSLog(@"come herer%@",[NSThread currentThread]);&#125;); {% asset_img GCD调度组1.png %} 调度的入组出组 入组，出组，相互对应，不多不少。 1234567891011121314151617181920212223242526dispatch_group_t group = dispatch_group_create();dispatch_queue_t que = dispatch_get_global_queue(0, 0);dispatch_group_enter(group); // 入组dispatch_async(que, ^&#123; NSLog(@"aaaaa%@",[NSThread currentThread]); dispatch_group_leave(group); // 出组&#125;);dispatch_group_enter(group);dispatch_async(que, ^&#123; NSLog(@"bbbbb%@",[NSThread currentThread]); dispatch_group_leave(group);&#125;);dispatch_group_enter(group);dispatch_async(que, ^&#123; NSLog(@"ccccccc%@",[NSThread currentThread]); dispatch_group_leave(group);&#125;);dispatch_group_notify(group, que, ^&#123; NSLog(@"come herer%@",[NSThread currentThread]);&#125;); GCD 调度组-swift 为了监听所有图像缓存，使用DispatchGroup enter 之后跟随block block 中有leave，配对存在 1234567891011121314151617func textGroup()&#123; let group = DispatchGroup() let queue = DispatchQueue.global() group.enter() queue.async &#123; print("aaaaa\(Thread.current)") group.leave() &#125; group.enter() queue.async &#123; print("bbbbb\(Thread.current)") group.leave() &#125; group.notify(queue: DispatchQueue.main) &#123; print("come here is end \(Thread.current)") &#125; &#125;]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Swift学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift自动引用计数]]></title>
    <url>%2F2016%2F09%2F23%2F2016b%2Fswift%E8%87%AA%E5%8A%A8%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.自动引用计数实践 ARC 初始化 12345678910var reference1: Person?var reference2: Person?var reference3: Person?reference1 = Person(name: "John Appleseed")reference2 = reference1reference3 = reference1reference1 = nilreference2 = nil // 此时person对象还没有释放，reference3 = nil // 执行之后，对象进行释放，打印deinit 方法// 打印 “John Appleseed is being deinitialized 2.类实例之间的循环强引用 Person 和Apartment 3.解决实例之间的循环强引用 — 弱引用（weak reference） Swift 提供了两种办法用来解决你在使用类的属性时所遇到的循环强引用问题：弱引用（weakreference）和无主引用（unownedreference ） 4.解决实例之间的循环强引用 — 无主引用（unowned reference ） 在前面加上关键字unowned表示这是一个无主引用 Person和Apartment的例子展示了两个属性的值都允许为nil，并会潜在的产生循环强引用。这种场景最适合用弱引用来解决。 Customer和CreditCard的例子展示了一个属性的值允许为nil，而另一个属性的值不允许为nil，这也可能会产生循环强引用。这种场景最适合通过无主引用来解决。 5.无主引用以及隐式解析可选属性 在这种场景中，两个属性都必须有值，并且初始化完成后永远不会为nil。在这种场景中，需要一个类使用无主属性，而另外一个类使用隐式解析可选属性 Country的构造函数调用了City的构造函数。然而，只有Country的实例完全初始化后，Country的构造函数才能把self传给City的构造函数 为了满足这种需求，通过在类型结尾处加上感叹号（City!）的方式，将Country的capitalCity属性声明为隐式解析可选类型的属性。这意味着像其他可选类型一样，capitalCity属性的默认值为nil，但是不需要展开它的值就能访问它 由于capitalCity默认值为nil，一旦Country的实例在构造函数中给name属性赋值后，整个初始化过程就完成了。这意味着一旦name属性被赋值后，Country的构造函数就能引用并传递隐式的self。Country的构造函数在赋值capitalCity时，就能将self作为参数传递给City的构造函数 6.闭包引起的循环强引用 Swift 提供了一种优雅的方法来解决这个问题，称之为闭包捕获列表（closure capture list） 定义了一个类，一个懒加载属性，懒加载属性是个闭包，内部强引用了类的2个属性 实例化对象 实例和闭包的引用关系如下： 7.解决闭包引起的循环强引用 在定义闭包时同时定义捕获列表作为闭包的一部分，通过这种方式可以解决闭包和类实例之间的循环强引用 捕获列表中的每一项都由一对元素组成，一个元素是weak或unowned关键字，另一个元素是类实例的引用（例如self）或初始化过的变量（如delegate = self.delegate!）。这些项在方括号中用逗号分开 1234lazy var someClosure: (Int, String) -&gt; String = &#123; [unowned self, weak property= self. property!] (index: Int, stringToProcess: String) -&gt; String in // 这里是闭包的函数体&#125; 8.使用弱引用和无主引用 在闭包和捕获的实例总是互相引用并且总是同时销毁时，将闭包内的捕获定义为无主引用。 相反的，在被捕获的引用可能会变为nil时，将闭包内的捕获定义为弱引用。弱引用总是可选类型，并且当引用的实例被销毁后，弱引用的值会自动置为nil。这使我们可以在闭包体内检查它们是否存在。 注意如果被捕获的引用绝对不会变为nil，应该用无主引用，而不是弱引用。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Swift学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDwebImage实现图片下载-圆角]]></title>
    <url>%2F2016%2F09%2F23%2F2016b%2FSDwebImage%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8B%E8%BD%BD-%E5%9C%86%E8%A7%92%2F</url>
    <content type="text"><![CDATA[1.设置UIImageView分类异步处理图片 SDWebImage 的实现远离 downloadImage 是SDWebImage 的核心方法 图像下载完成之后，会自动保存在沙盒中，文件路径是URL的md5 如果沙盒中已经存在缓存的图像，后续使用SD通过URL加载图像，都会加载本地沙盒图像 不会发起网络请求，同时回调方法，同样会调用 方法还是原来的方法，调用还是原来的调用，不过内部不会再次发起网络请求 设置图片的异步设置，并且同一个方法中可以设置圆角半径 12345678910111213func jy_setImage(urlString:String?,placeholerImage:UIImage?,isAvatar:Bool = false)&#123; guard let urlStr = urlString ,let url = URL(string: urlStr) else &#123; image = placeholerImage return &#125; sd_setImage(with: url, placeholderImage: placeholerImage, options: [], progress: nil) &#123;[weak self] ( image, _, _, _) in if isAvatar &#123; self?.image = image?.getRoundedImage(size: (self?.bounds.size)!) &#125; &#125;&#125; 异步下载图片封装，得到Image 1234567static func jy_downImage(urlString:String?,complention:@escaping (UIImage?, Data?, Error?, Bool)-&gt;())-&gt;()&#123; guard let urlStr = urlString ,let url = URL(string: urlStr) else &#123; return &#125; SDWebImageManager.shared().imageDownloader?.downloadImage(with: url, options: [], progress: nil, completed: complention)&#125; 2.修复图片拉伸，压缩影响性能 根据尺寸重新绘图 设置尺寸 开启图像上下文 绘图，指定固定区域 取得结果 关闭上下文 123456let rect = CGRect(origin: CGPoint(), size: size)UIGraphicsBeginImageContextWithOptions(size, true, 0)aimage.draw(in: rect)let result = UIGraphicsGetImageFromCurrentImageContext()UIGraphicsEndImageContext()return result 设置圆角图片 设置区域 开启图像上下文 背景颜色填充，填充整个区域 设置路径，设置裁剪 开始绘图，指定固定区域 设置边线，颜色填充，边线宽度，填充 取得结果 关闭上下文 12345678910111213let rect = CGRect(origin: CGPoint(), size: size)UIGraphicsBeginImageContextWithOptions(size, true, 0)backGroudColor?.setFill()UIRectFill(rect)let path = UIBezierPath(ovalIn: rect)path.addClip()self.draw(in: rect)UIColor.red.setStroke()path.lineWidth = 2 // 默认是1path.stroke()let result = UIGraphicsGetImageFromCurrentImageContext()UIGraphicsEndImageContext()return result]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>实用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现cell处理]]></title>
    <url>%2F2016%2F09%2F22%2F2016b%2F%E5%AE%9E%E7%8E%B0cell%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[实现微博cell处理 单条微博的处理 / 图片高度自适应 1.多张，单张图片高度的处理 单条微博的视图模型 如果没有任何父类，如果希望在开发时调试，输出调试信息，需要 遵守CustomStringConvertible协议 实现desciription 是计算型属性 123var description:String &#123;return status.description&#125; 视图列表模型 中引用视图模型 listViewModel -&gt; aViewModel 1234567891011121314var arrary = [WBStatusViewModel]()// for 循环遍历返回的数组，字典转模型for dict in list ??[ ] &#123; guard let model = WBStatus.yymodel(with:dict) else &#123; continue &#125; // 根据转的model，初始化ViewModel，拼接到数组中 arrary.append(WBStatusViewModel(model:model)) // 如果是上拉刷新，数据拼接末尾，不是上拉刷新，拼接在数组前面 if pullUp &#123; self.statusList +=arrary &#125;else&#123; self.statusList = arrary + self.statusList &#125; &#125; ViewModel中增加储值属性，使用内存换CPU，cell中不用重复计算 增加会员image，认证image，数字字符串，储值属性，在cell中直接赋值 一个xib中拖出来N个View，如果功能独立，可以创建view方便处理 创建view添加到Cell上 2.图片的处理 九宫格的创建，9个UIImageView for循环设置frame 九宫格视图的计算 设置外边距，内边距 根据外边距，内边距，设置view宽度，设置PictureView的宽度，高度（1*1） 根据count计算列数， 根据列数，计算view的高度 1234567891011func calcPictureViewSize(count:Int?)-&gt;CGSize&#123; guard let count = count else&#123; return CGSize() &#125; // 计算配图视图高度 // 外边距 let WBStatusPictureViewOuterMargin = CGFloat(12) /// 内边界 let WBStatusPictureViewInnerMargin = CGFloat(3) /// view视图的W let height = WBStatusPictureViewOuterMargin + CGFloat(row) * pitureWith + CGFloat(row-1)*WBStatusPictureViewInnerMargin return CGSize(width: pictureItmeWidth, height: height)&#125; 3.单图的处理 使用GCD调度组，下载一个图片之后处理单张图片的大小，保存下来 在viewMolde 中增加方法，使用储值属性记录imageSize 在listModel每次下载完成一张图片之后进行调用刷新PictureSize 等调度组完成之后，之后再回调。 当一个图过宽或者过窄的时候需要程序处理 在PictureView 中设置statusMolde 根据model的pictureSize 处理宽高，处理单图，处理无图 4.cell的自动布局，和缓存行高 自动布局 设置tableView预估行高，和rowHeight 是自动计算 有一个从上到下的约束，lable 到下边距是&gt;= 一个数组 123let table = UITableView()table.rowHeight = UITableViewAutomaticDimensiontable.estimatedRowHeight = 300; 缓存行高 取消xib 中&gt;= 约束，设置为=约束 取消table.rowHeight = UITableViewAutomaticDimension 计算cell高度思路 计算文字，转发文字的长度 计算的高度，使用存储属性记录，设置好image更新高度后再计算一边 总结缓存行高 5.选中的某个cell后快速的恢复到选中前的状态 tableView 如何让选中的某个cell后快速的恢复到选中前的状态(选中时的灰色动态消失)?]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>实用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift学习笔记《5》- 实用]]></title>
    <url>%2F2016%2F09%2F21%2F2016b%2Fswift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8A5%E3%80%8B%2F</url>
    <content type="text"><![CDATA[1.setValue:forKeyPath实现原理 setValue:forKeyPath实现原理 先看有没有对应key值的set方法，如果有set方法，就会调用set方法，给对应的属性赋值 如果没有set方法，去查看有没有跟key值相同并且带有下划线的成员属性，如果有的话，就给带有下划线的成员属性赋值， 如果没有跟key 值相同并且带有下划线的成员属性，还会去找没有跟key 值相同的成员属性，如果有直接给它赋值， 如果没有直接报错 2. button 颜色显示系统tineColor的解决办法 button 颜色显示系统tine的解决办法 在Assets 中设置图片的Render为Orignnal Image 使用代码设置 imageWithRenderingMode: 123UIImage *image = [UIImage imageNamed:@"aimage"];UIImage *oriImage = [image imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal]; 3.导航条隐藏 导航条隐藏 导航条或者导航条上的控件设置透明度是没有效果的 self.navigationController.navigationBar.alpha = 0; 如果需要设置透明背景，设置导航条背景，BackgroundImage必须默认模式是UIBarMetricsDefafault 当背景图片设置为nil 的时候，ShadowImage 系统会自动生成一张半透明的图片，设置为导航条背景 4.Transform 使用make 是相对于最原始的位置做的形变 使用CGAffineTransformTranslate 是相对于上一次做形变 5.view 的任意拖拽 在touchMoved a 方法里，计算XY方向的偏移量，设置view的transform， 6.事件传递： 如果父控件不能接收触摸事件，那么子控件就不可能接收到触摸事件， 如何找到最合适的控件来处理事件、 判断自己能否接收触摸事件 触摸点是否在自己身上 从后往前便利子控件，重复前面的2个步骤 如果没有符合条件的子控件 ，那么就自己最适合处理 7.tableView 的缩进处理 取消自动调整滚动视图的间距，- VC+NAV 会自动调整tanleView的contentInset 如果设置了tableview的缩进，记得设置scrollIndictiorInsets; navBar 相融的问题，不显示在底部,从隐藏到显示，控制animated 就是可以的 8.实现图片的，下拉放大，上推隐藏，直至隐藏渐变显示导航条 放大代码实现 下拉，contentOffset 是负值 向上移动的时候，当超过64的时候，不再移动 动态变化设置图片的透明度 根据推的长度，控制显示状态栏是黑色还是白色 如果不设置背景颜色，拖拽手势返回的时候，右上角会有黑色，设置导航栏的背景色是白色 9.实现图片的压缩处理圆角处理(加入线程) 使用CoreGraphisc是耗时操作，讲图片处理放在全局队列中，结果放在主线程中 1-(void)cz_coreImageWithSize:(CGSize)size fillColor:(UIColor*)fillColor complection:(void(^)(UIImage*image))complection; 具体实现如下 10.Xcode 使用 替换已有类名：.h选中要改的类名 —&gt; 菜单栏选中 Edit —&gt; Refactor —&gt; Rename 替换已有类名： Xcode 修改应用的名字找到 TARGETS 中的 Build Setting , 搜索 Product Name－&gt;双击修改]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Swift学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift学习笔记《4》]]></title>
    <url>%2F2016%2F09%2F21%2F2016b%2Fswift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8A4%E3%80%8B%2F</url>
    <content type="text"><![CDATA[1.swift Protocol 设置可选协议方法 需要遵守NSObjectProtocol 协议 协议需要是 @objec 方法是需要@object optional 123@objc protocol CircleDelegate:NSObjectProtocol &#123; @objc optional func cirelcPrint()&#125; 定义delegate 属性 weak var delegate:CircleDelegate? 调用代理方法 delegate?.cirelcPrint?() protocol mutating 关键字 使用mutation 关键字来标记一个会修改结构体的刚发 class 中不需要使用mutating标记，因为类总方法通常可以修改类属性 可以给系统方法增加写extion,遵守代理 2.switchCase case let x where x.hasSuffix(“peper”): print(“li it a spicy”) 可以在case中使用where 进行判断 3.元组 取元组可以根据属性，也可以根据下标取 123let amutule : (min:Int,max:Int,sum:Int) = (2,4,6)print(amutule.sum)print(amutule.2) 4.函数的不确定参数个数 传入一个不确定参数类别，计算和 12345678func sumOfnumbers(numbers:Int...)-&gt;Int&#123; var sum = 0 for numbe in numbers &#123; sum += numbe &#125; return sum&#125;print("\(sumOfnumbers(numbers: 2,3,4,5,5))") 5.函数作为一个参数，传入另一个函数中 一个函数传入一个参数，一个判断条件的函数参数，返回值是bool 在函数内部，传参数1，调用函数参数判断 6.函数作为返回值 函数作为返回值 适用的时候，生产函数类型的变量，调用变量（函数）方法 7.集合map的使用 使用map 批量操作集合内的元素 匹配符合集合的元素批量处理，也可以进行判断，不符合条件的为0 如果一个闭包的类型已知，并且作为回调函数，可以忽略参数类型和返回值，单个闭包语句，会把它语句的值当作返回值返回 可以通过参数所在的位置，替代参数名来引用参数，在非常短的闭包中非常有用 8.setter 和getter 方法 在setter 中新值是newValue 可以在set 后面显示设置一个别名 9.监测API 可用性 监测API 可用性 iOS 10 1234567func textAPI()&#123; if #available(iOS 10, macOS 10.12,*) &#123; // 在iOS 10使用，MacOS 10。12使用 &#125;else&#123; // 使用先前的iOS，macOS的API &#125;&#125; 10.swift 数组 数组的CRUD 123456789101112131415var aArray = Array(repeating: 0.4, count: 3);//aArray.isEmpty//aArray.append(&lt;#T##newElement: Double##Double#&gt;)//aArray.insert(&lt;#T##newElement: Double##Double#&gt;, at: &lt;#T##Int#&gt;)//aArray.remove(at: &lt;#T##Int#&gt;)//aArray.removeLast()for (indx,value) in aArray.enumerated() &#123;print("\(indx)----\(value)")&#125; 11.swift字符串 字符串的CRUD 12345678910111213141516171819202122232425func textString()&#123; var astring = "Guten Tag!" if astring.isEmpty &#123; // 空字符串 &#125; print("\(astring[astring.startIndex])") // G print("\(astring[astring.index(before: astring.endIndex)])") // ! print("\(astring[astring.index(after: astring.startIndex)])") // u // let aindex = astring.index(astring.startIndex, offsetBy: 7); // print("\(astring[aindex])") // a astring.insert("!", at: astring.endIndex) astring.insert(contentsOf: "there".characters, at: astring.index(before: astring.endIndex)) // 前缀 - 后缀 _ = astring.hasPrefix("acutnr") _ = astring.hasSuffix("!")&#125; 12.范型 实用方法： 在尖括号里面写一个名族创建一个范型函数或者类型 定一个函数，传入一个未知类型参数，重复N词，返回数组，数组红元素类型就是传入的类型 使用范型- 重新实现可选类型 定义可选类型的枚举 使用赋值 实现方法，限定参数遵守协议，类型是相同的 比较两个数组中相同的元素，有返回true，没有返回false 可以计算 两个集合中相同的元素返回 在类型名之后使用where 制定类型的需求 比如，限定类型实现某一个协议，限定两个类型是相同的，或者限定某个类必须有一个特定的父类” where T.Iterator.Element: Equatable, T.Iterator.Element == U.Iterator.Element 12345678910func anyCommonElements&lt;T:Sequence,U:Sequence&gt;(_ lhs :T,_ rhs: U)-&gt;Bool where T.Iterator.Element:Equatable,T.Iterator.Element == U.Iterator.Element&#123; for lhsElement in lhs &#123; for rhsElement in rhs &#123; if lhsElement == rhsElement &#123; return true &#125; &#125; &#125; return false&#125; 13.集合操作 a.intersection(b) A和B集合的交集 (A&amp;B) a.symmtriDifference(b) A +B - (A&amp;B) a.union(b) A+B a.subtracting(b) A-(A&amp;B) 14.递归枚举 在枚举成员前面，加上 indirect 关键字，是可以递归的 12345enum ArithmeticExpression &#123; case number(Int) indirect case addition(ArithmeticExpression,ArithmeticExpression) indirect case multiplication(ArithmeticExpression,ArithmeticExpression) &#125; 调用枚举 1234let five = ArithmeticExpression.number(5)let foure = ArithmeticExpression.number(4)let sum = ArithmeticExpression.addition(five, foure)let procuct = ArithmeticExpression.multiplication(sum, .number(2)) 操作能可以递归的枚举，需要可以递归的函数， 如果是纯数字，直接返回该值，如果是加法，或者乘法，计算左右的算法的值，然后相加，乘 12345678910func evaluate(_ expression:ArithmeticExpression) -&gt; Int&#123; switch expression &#123; case let .number(value): return value case let .addition(left, right): return evaluate(left) + evaluate(right) case let .multiplication(left, right): return evaluate(left) * evaluate(right) &#125;&#125; 15.Swift 下标 subscript 写法： 定义下标使用subscript关键字，指定一个或多个输入参数和返回类型 与实例方法不同的是，下标可以设定为读写或只读 1234567891011subscript (index:Int)-&gt;Int&#123; get&#123; //返回一个适当的int 类型的操作 return 0 &#125; set(newValue)&#123; // 执行适当的赋值操作 &#125;&#125; 下标可以接受任意数量的入参，并且这些入参可以是任意类型。下标的返回值也可以是任意类型。下标可以使用变量参数和可变参数，但不能使用输入输出参数，也不能给参数设置默认值 定义了一个Matrix结构体，用于表示一个Double类型的二维矩阵 123456789101112131415161718192021222324struct Matrix &#123; let rows: Int, columns: Int var grid: [Double] init(rows: Int, columns: Int) &#123; self.rows = rows self.columns = columns grid = Array(repeating: 0.0,count: rows * columns) &#125; func indexIsValidForRow(row: Int, column: Int) -&gt; Bool &#123; return row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; column &gt;= 0 &amp;&amp; column &lt; columns &#125; // N 行 * N 列的矩阵 subscript(row: Int, column: Int) -&gt; Double &#123; get &#123; assert(indexIsValidForRow(row: row, column: column), "Index out of range") return grid[(row * columns) + column] &#125; set &#123; assert(indexIsValidForRow(row: row, column: column), "Index out of range") grid[(row * columns) + column] = newValue &#125; &#125;&#125; 使用 16.swift析构过程 析构器用deinit 表示 – 构造器init deinit {} 17.swift访问控制 模块和源文件 使用import 导入另外一个模块 访问级别 五种不同的访问级别 开放访问／公开访问 —–同一模块下的任意文件，任意方法，任意实体 内部访问 —-在模块内访问任何实体，到那时不能从外部导入模块访问 文件私有访问 只能在定义的文件内部访问 私有访问限制 只能在定义的作用域内访问 开放访问权限最高，私有访问最低访问级别 开放访问只作用于类类型和类的成员，和公开访问区别如下 开放访问的类，可以在模块内，模块外继承，公开访问和更严的访问级别的类，只能在他们定义的模块内部被继承 开放访问的类成员，可以在模块内，模块外的子类重写，公开访问只能在定义的模版内部重写。 默认访问级别 interal 级别 单目标程序，是为整个程序服务的，默认interal 即可。 访问控制语法 通过 open,public,internal,filepart,private , 修饰符，声明实体的访问级别： 子类的访问级别不得高于父类的访问级别 函数的访问级别 18.Pch 文件创建 工程 - &gt;TARGETS -&gt; Bulid Settings -&gt;搜索prefix -&gt; LLVM -Language 下的Precompile Prefix Header 设置置为YES，默认是NO。 LLVM -Language 设置下，Prefix Header pch文件路径]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Swift学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift学习笔记《3》-技巧]]></title>
    <url>%2F2016%2F09%2F21%2F2016b%2Fswift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8A3%E3%80%8B%2F</url>
    <content type="text"><![CDATA[1.swift打印 自定义printLog 12345678func printLog&lt;T&gt;(message : T, fileName : String = __FILE__, lineNum : Int = __LINE__) &#123; #if DEBUG // 处理fileName let file = (fileName as NSString).lastPathComponent print("\(file):[\(lineNum)]") #endif&#125; 2.获取命名空间 let nas = Bundle.main.infoDictionary![&quot;CFBundleExecutable&quot;] as! String 3.try 的三种方式 JSONObjectWithData(data: NSData, options opt: NSJSONReadingOptions)函数会抛出异常 throws 需要用try 获取 try 需要用do catch 错误放在catch 中的error中 12345do &#123; let aaa = try JSONObjectWithData()&#125;catch&#123; print(\(error)) &#125; try? 如果没有值，返回nil 返回值是可选类型 try!相当于告诉系统一定没有异常，发生异常会崩溃 4.storyBoard Refrence 方式1 选中需要的控制器 选择导航条的editor 选择下拉菜单 refector to sroryboard 方式2 在控件库中拖入storyboard refrence 新建一个storyboard 点击storyboard refrence 关联到建立的storyboard， 原来的控件中就可以与 storyboard refrence 连线跳转 5.swift封装 AFN 设置网络工具枚举 POST，GET 1234enum RequestMothod:String &#123;case POST = "POST"case GET = "GET"&#125; 封装网络请求单例类 1234567class NetworkTools : AFHTTPSessionManager &#123; static let shareTools : NetworkTools = &#123; let tools = NetworkTools() tools.responseSerializer.acceptableContentTypes?.insert("text/plain") return tools &#125;&#125; AFN 内部方法的封装 封装POST，GET 用一个方法封装 使用关键字 typealias 设置方法的block ，参数是返回值，错误信息，返回值是空(rest:Any,error:Error )-&gt;() 定义方法中的参数，type ,urlstring ,pramas, 上面的回调的block 在方法中定义成功的闭包，失败的闭包，用于传进AFN的方法参数，12345678910111213141516171819202122232425// 内部封装AFN 请求extension AFNNetWorkTool &#123; //typealias callBack = (_ aresult:AnyObject?,_ erro:Error)-&gt;() func afnRequest(methodType:AFNnetRequsetType,urlString:String,parames:[String:AnyObject]?,finished:@escaping (_ result:Any?,_ error:Error?)-&gt;())&#123; // 定义成功的回调 let seccessBlck = &#123; (task:URLSessionDataTask,resuurt:Any?)-&gt;() in finished(resuurt,nil) &#125; // 定义失败的回调 let faitureBlock = &#123; (tast:URLSessionDataTask?,error:Error)-&gt;() in finished (tast,error) &#125; if methodType == .GET &#123; get(urlString, parameters: parames, progress: nil, success: seccessBlck, failure: faitureBlock) &#125;else&#123; post(urlString, parameters: parames, progress: nil, success: seccessBlck, failure: faitureBlock) &#125; &#125;&#125; 6 Alamofire 监测网络 使用alamofire 监测网络状况 123456789101112131415let NetworkManager = NetworkReachabilityManager(host: "www.baidu.com")NetworkManager!.listener = &#123; status in print("") switch status &#123; case .NotReachable: print("") case .Unknown: print("") case .Reachable(.EthernetOrWiFi): print("") case .Reachable(.WWAN): print("") &#125; &#125;NetworkManager!.startListening() 7.UIWebView 自动填充账户密码 每次输入网页需要填充账户名密码十分麻烦，结合safari开模拟查看网页上标签 123let js = "document.getElementById('userId').value = '1606020376@qq.com';" + "document.getElementById('passwd').value = 'haomage';" webView.stringByEvaluatingJavaScriptFromString(js) 8.双击底部tabbarItem刷新数据 判断索引是当前，并且将要点击是当前 让滑倒顶部 刷新数据，延迟加载 清除角标 1234567891011let index = childViewControllers.index(of: viewController)if selectedIndex == 0 &amp;&amp; selectedIndex == index&#123; let nav = childViewControllers[0] as! UINavigationController let vc = nav.childViewControllers[0] as! HomeVC vc.tableView?.setContentOffset(CGPoint(x: 0, y: -64), animated: true) DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 1 , execute: &#123; vc.loadData() &#125;) vc.tabBarItem.badgeValue = nil UIApplication.shared.applicationIconBadgeNumber = 0&#125; 9. 毛玻璃 - 高斯模糊 Vleual Effect View 选择，extra Light 就可以 子视图添加在View上，并且不透明 10.POP 基本概念 支持3种动画类型 弹力动画POPSPringAnimation 衰减动画 POPDelayAnimation 基本动画 POPBasicAnimation 如果需要做延时动画需要如下代码 12// 5秒之后的延迟anim.beginTime = CACurrentMediaTime( ) + CFTimeInterval ( 5) 11.Block 的延时执行，需要的时候再执行 当前方法不能执行，使用属性记录，在需要的时候再执行 123// 定义一个属性，是可选的闭包，// 闭包有参数无返回值 private var comlentionBlock:( (clasName:String? ) -&gt; ( ) )? 当属性引用闭包，闭包右修改了属性，必发生循环引用，在闭包中使用【weak self】 12.单例方法严谨 单例如果调用了init方法，和share方法，得到的是不同的对象， init 用private 修饰，外部只能使用share 方法 1234static let share = CZEmotionManager()private init() &#123; loadPackAges()&#125; 13.加载bundle中的图片素材 通过mainBundle，找到素材bundle 找到素材plist的path，plist转为数组 1234567guard let path = Bundle.main.path(forResource: "HHEmotion.bundle", ofType: nil), let bundle = Bundle(path: path) , let plistpath = bundle.path(forResource: "emotion.plist", ofType: nil), let arry = NSArray(contentsOfFile: plistpath) as? [[String:String]] else &#123; return &#125;print("\(arry)") 14.过滤数组 - 尾随闭包的简单写法 OC 中过滤数组，使用谓词 swift 中，过滤使用filter， P是数组，判断数组中的模型的一个属性的值是不是相等 直接过滤 尾随闭包： 如果是尾随闭包只有一句，并且是返回，闭包格式可以省略，参数省略之后，可以使用0,1….以此替代原有的参数 return 也可以省略 15.测试正则表达式 匹配中间带【】的字符，任何字符都行 字符中 【】() 是正则表达式的关键字，如果参与匹配，需要转义 匹配所有项 for循环所有项，根据所有项所在的range，匹配出字符串 16.图片拉伸处理 根据图片的size，设置拉伸的rect 拉伸图片 1234var image = UIImage(named: "ceshiimage")let size = image?.size ?? CGSize()let inset = UIEdgeInsetsMake(size.height*0.5, size.width*0.5, size.height*0.5, size.width*0.5)image = image?.resizableImage(withCapInsets: inset) 17.UIColor 16进制转RGB 写分类 根据16进制 位运算，有移得出相对应的RGB的数值 生成颜色 1234567891011static func jy_colorWithHex(hex:u_int)-&gt;UIColor&#123; let red = Float((hex &amp; 0xFF0000) &gt;&gt; 16) let green = Float((hex &amp; 0x00FF00) &gt;&gt; 8) let blue = Float(hex &amp; 0x0000FF) return UIColor.init(colorLiteralRed: red/255.0, green: green/255.0, blue: blue/255.0, alpha: 1.0); &#125;]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Swift学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift学习笔记《2》-swift语法]]></title>
    <url>%2F2016%2F09%2F21%2F2016b%2Fswift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8A2%E3%80%8B%2F</url>
    <content type="text"><![CDATA[1.常量变量 let var 2.数据类型 整型，浮点型，对象类型，结构体类型（swift中大部分类改为了结构体） 整型 Int8 有符号8位整型 Int16 有符号16位整型 Int 32 有符号32位整型 Int 64 有符号64位整型 Int 与平台有关，默认相当于OC中NSInteger UInt8 无符号8位整型 UInt16,UInt32,UInt64 浮点型 Float 32位浮点型 Double 64位浮点型 基本运算 相同运算符之间才能参与运算，因为swift中没有隐式转换 3.逻辑分支 if switch 三目运算符 等判断语句 guard运算符(守护) 当条件表达式位true的时候跳过else语句，继续向下执行 当条件表达式为false的时候进入else语句中，break，continue，return，throw等跳出12345guard 条件表达式 else &#123; // 条换语句 break&#125;语句组 switch语句 switch 的case之后不必须加break case不在只是Int，可以是浮点，字符串，区间(0..&lt;10,0…10) 一个case 可以判断多个值，用，隔开 4.循环 for循环 开区间(0..&lt;10)，闭区间(0…10) for循环打印字典时可以使用元组 while，do-while 循环 使用repeat while循环代替do-while循环 i++已经被弃用，使用i=i+1； 5.字符串 String 是结构体，性能比NSString 高 String的长度，astring.characters.count 字符串长度 str1 + str2 两个字符串相加 字符串的格式化输出 1String(format: "%02d:%02d", arguments: [min, second]) 字符串的截取 暂时先转为NSString 进行截取 1234let myStr = "www.520it.com"var subStr = (myStr as NSString).substringFromIndex(4)subStr = (myStr as NSString).substringToIndex(3)subStr = (myStr as NSString).substringWithRange(NSRange(location: 4, length: 5)) 6数组 Array 一个范型数组 数组声明方法 12var stuArray1:Array&lt;String&gt;var stuArray2: [String] 数组的 增- 删- 改- 查 12345678// 添加数据array.append("yz")// 删除元素array.removeFirst()// 修改元素array[0] = "why"// 取值array[1] 数组的合并 同类型的两个数组可以直接相加 12345678910// 数组合并// 注意:只有相同类型的数组才能合并var array = ["why", "lmj","lnj"]var array1 = ["yz", "wsz"]var array2 = array + array1;// 不建议一个数组中存放多种类型的数据var array3 = [2, 3, "why"]var array4 = ["yz", 23]array3 + array4 7.字典 Dictionary 是个范型集合 声明方式 12var dict1: Dictionary&lt;Int, String&gt;var dict2: [Int: String] 字典的增 -删- 改- 查 123456789// 添加数据dict["height"] = 1.88dict["weight"] = 70.0// 删除字段dict.removeValueForKey("height")// 修改字典dict["name"] = "lmj"// 查询字典dict["name"] 字典的遍历 使用元组 字典的合并 1234567// 字典的合并var dict1 = ["name" : "yz", "age" : 20]var dict2 = ["height" : 1.87, "phoneNum" : "+86 110"]// 字典不可以相加合并for (key, value) in dict1 &#123; dict2[key] = value&#125; 8.元组 是swift中特有的定义一组数据，类型可相同可不相同 1234567891011121314151617// 元组:HTTP错误// let array = [404, "Not Found"]// 写法一:let error = (404, "Not Found")print(error.0)print(error.1)// 写法二:let error = (errorCode : 404, errorInfo : "Not Found")print(error.errorCode)print(error.errorInfo)// 写法三:let (errorCode, errorIno) = (404, "Not Found")print(errorCode)print(errorIno) 9.可选类型 可选类型的取值，有值或者是空值 可选类型的使用 使用场景 1234567// 该方式利用类型推导let url = NSURL(string: "www.520it.com")// 通过url来创建request对象:在使用可选类型前要先进行判断是否有值// 该语法成为可选绑定(如果url有值就解包赋值给tempURL,并且执行&#123;&#125;)if let tempUrl = url &#123; let request = NSURLRequest(URL: tempUrl)&#125; 10.函数 函数的格式 123456789func 函数名(参数列表) -&gt; 返回值类型 &#123; 代码块 return 返回值&#125;func 函数名(参数1:参数1类型，参数2：参数2类型) -&gt; 返回值类型 &#123; 代码块 return 返回值&#125; 函数 外部参数和内部参数 变量名前加标签就是外部参数 方法重写 子类重新调用父类方法是重写，override 方法重载 方法名相同但是参数不同，称为方法重载 1234567891011// num1和a是外部参数的名称func ride(num1 num1 : Int, a num2 : Int, b num3 : Int) -&gt; Int &#123; return num1 * num2 * num3&#125;var result1 = ride(num1: 20, a: 4, b: 5)// 方法的重载:方法名称相同,但是参数不同,可以称之为方法的重载(了解)func ride(num1: Int, _ num2 :Int) -&gt; Int &#123; return num1 * num2&#125;var result2 = ride(20, 20) 函数的默认参数 不传的话有个默认值123func makecoffee(type :String = "卡布奇诺") -&gt; String &#123; return "制作一杯\(type)咖啡。"&#125; 可变参数 可以接受不确定数量的输入类型参数，但必须是相同类型，在参数类型后面拼接… 来实现123456789func sum(numbers:Double...) -&gt; Double &#123; var total: Double = 0 for number in numbers &#123; total += number &#125; return total&#125;sum(100.0, 20, 30)sum(30, 80) 函数引用类型-指针传递 默认是值传递，不改变外部变量的值，如果想改变，需要传地址 传入的地址必须是变量 swift提供inout 关键字实现 11.swift中类的使用 定义类的时候可以没有父类，需要父类的话大多可以使用NSObject 作为父类，非OC的NSObject 类的属性 分为 储值属性，算值属性，类属性 储值属性 计算型属性 不存储实际值，提供getter 和可选的setter间接获取或设置其他属性， 一般只提供getter 方法，如果只实现了getter 方法，则为只读属性，可以省略get{},直接return 类属性 所有的类和类的实例都有一份类属性，如果在某一处更新后，该类属性就会被修改 类属性使用static 关键字修改， 监听属性的修改 在oc中使用set 方法监听 在swift中，使用属性观察者监听和相应属性值的变化 使用属性的will set 方法监测新值，在didset中监测旧值 willSet (new){ } didSet(old){} 在didset中生成计算型属性的值 didSet 属性直接赋值不会调用didSet方法，而是在初始化之后再赋值才能调用 12345var expires_in: NSTimeInterval = 0 &#123; didSet &#123; expiresDate = NSDate(timeIntervalSinceNow: expires_in) &#125;&#125; 12.类的构造函数 构造函数的基本使用 类的属性必须有值，如果不是在初始化的时候复制，在构造方法中给类属性赋值，123456789101112class Person: NSObject &#123; var name : String var age : Int // 重写了NSObject(父类)的构造方法 override init() &#123; name = "" age = 0 &#125;&#125;// 创建一个Person对象let p = Person() 初始化的时候给属性赋值 如果在自定义对象的时候给属性赋值，自定义init方法，会覆盖init方法，不会有默认的初始化方法1234567891011class Person: NSObject &#123; var name : String var age : Int // 自定义构造函数,会覆盖init()函数 init(name : String, age : Int) &#123; self.name = name self.age = age &#125;&#125;// 创建一个Person对象let p = Person(name: "why", age: 18) 13 字典转模型 (初始化时传入字典) 字典取值是NSObject 是任意类型 可以通过as转换之后再赋值，不同类型不能直接赋值 12345678910111213class Person: NSObject &#123; var name : String var age : Int // 自定义构造函数,会覆盖init()函数 init(dict : [String : NSObject]) &#123; name = dict["name"] as! String age = dict["age"] as! Int &#125;&#125;// 创建一个Person对象let dict = ["name" : "why", "age" : 18]let p = Person(dict: dict) 14 字典转模型 (KVC 转化) kvc 不能保证全部复制，所以属性要有默认值，基本数据类型默认值是0，对象结构体定义为可选即可1234567891011121314151617class Person: NSObject &#123; // 结构体或者类的类型,必须是可选类型.因为不能保证一定会赋值 var name : String? // 基本数据类型不能是可选类型,否则KVC无法转化 var age : Int = 0 // 自定义构造函数,会覆盖init()函数 init(dict : [String : NSObject]) &#123; // 必须先初始化对象 super.init() // 调用对象的KVC方法字典转模型 setValuesForKeysWithDictionary(dict) &#125;&#125;// 创建一个Person对象let dict = ["name" : "why", "age" : 18]let p = Person(dict: dict) 15闭包的介绍 闭包就是匿名函数 block 的写法 12345678类型：返回值(^block的名称)(block的参数列表)------值：^(参数列表)&#123; // 执行的代码&#125; swift的写法 定义网络请求的类 123func loadRequest(callBack:()-&gt;())&#123; callBack()&#125; 使用闭包 123httpTool.loadRequest( &#123; ( )-&gt;( ) in tableView.reloadData&#125;) 闭包总结 12345678闭包的写法：类型： （型参列表）-&gt;( 返回值 )值：&#123; ( 型参列表 ) -&gt; 返回值类型 in // 执行代码&#125; 尾随闭包 如果闭包没有参数没有返回值，( ) -&gt; ( ) in可以省略 如果闭包是作为函数的最后一个参数，则可以将闭包写在（）后面 如果函数只有一个参数，且最后一个参数是闭包，那么（）也可以不写，直接在方法名后面拼接{} 12345678910111213141516171819省略前httpTool.loadRequest(&#123; ( ) -&gt; ( ) in print(完全不省略)&#125;)省略1httpTool.loadRequest(&#123; print(省略括号 in)&#125;)省略2httpTool.loadRequest( )&#123; print(小括号前置)&#125;省略3httpTool.loadRequest&#123; print(终结版尾随闭包)&#125; 16.闭包的循环引用 deinit{}实现deinit 函数，检测一个对象是否销毁 swift 循环引用的三种方式 使用weak，使用【weak self】，使用unowned 关键字 使用weak 关键字对控制器持有，weakself是可选类型，使用时强行解包，因为一定有值 12345weak var weakSelf = selfhttpTool.loadData &#123; print("加载数据完成,更新界面:", NSThread.currentThread()) weakSelf!.view.backgroundColor = UIColor.redColor()&#125; 使用 【weak self】 【weak self 】写在闭包中，在闭包中使用的self 都是weak的 1234httpTool.loadData &#123;[weak self] () -&gt; () in print("加载数据完成,更新界面:", NSThread.currentThread()) self!.view.backgroundColor = UIColor.redColor()&#125; unowned 类似oc的unretain ,即使原来引用的对象释放了，也会对释放的对象，持有一个无效的引用，不是可选的，不可能指向nil 1234httpTool.loadData &#123;[unowned self] () -&gt; () in print("加载数据完成,更新界面:", NSThread.currentThread()) self.view.backgroundColor = UIColor.redColor()&#125; 17.懒加载 希望所有的对象，只有加载的时候才能加入到内存中， lazy 关键字，是专门修饰懒加载属性的 格式 1lazy var 变量名 = &#123; 创建变量代码 &#125;() 使用 123456// 懒加载的本质是,在第一次使用的时候执行闭包,将闭包的返回值赋值给属性// lazy的作用是只会赋值一次lazy var array : [String] = &#123; () -&gt; [String] in return ["why", "lmj", "lnj"]&#125;() 18.便利构造函数 convenience : 便利,使用convenience修饰的构造函数叫做便利构造函数 便利构造函数通常用在对系统的类进行构造函数的扩充时使用 便利构造函数的特点 便利构造函数，一般写在extension中 便利构造函数，在init前面添加convenience 关键字 在便利构造器中需要明确调用self.init(), 而且是先调用。 在继承中，重写父类的方法中，初始化自己的方法中，先初始化自己的属性，之后调用父类的super.init() 19 #Selector() 事件监听 事件监听本质发送消息.但是发送消息是OC的特性 将方法包装成@SEL –&gt; 类中查找方法列表 –&gt; 根据@SEL找到imp指针(函数指针) –&gt; 执行函数 如果swift中将一个函数声明称private,那么该函数不会被添加到方法列表中 如果在private前面加上@objc,那么该方法依然会被添加到方法列表中 20.类型转换 类型转换在 Swift 中使用is和 as操作符实现 ，你也可以用它来检查一个类型是否实现了某个协议，就像在检验协议的一致性部分讲述的一样。 定一个类MediaItem，name 属性,init(name:) 方法 其2个子类Movie，Song 检查类型 is判断是一个实例，是否属于特定子类 if item is Movie 向下转型 使用子类特有的属性和方法，使用as 转化为子类 as?和as! 21.Any 和 AnyObject 的类型转换 Any 表示任何类型，包括函数类型 AnyObject表示任何类型的实例 123456789101112131415161718192021222324252627282930313233for thing in things &#123; switch thing &#123; case 0 as Int: print("zero as an Int") case 0 as Double: print("zero as a Double") case let someInt as Int: print("an integer value of \(someInt)") case let someDouble as Double where someDouble &gt; 0: print("a positive double value of \(someDouble)") case is Double: print("some other double value that I don't want to print") case let someString as String: print("a string value of \"\(someString)\"") case let (x, y) as (Double, Double): print("an (x, y) point at \(x), \(y)") case let movie as Movie: print("a movie called '\(movie.name)', dir. \(movie.director)") case let stringConverter as String -&gt; String: print(stringConverter("Michael")) default: print("something else") &#125;&#125;// zero as an Int// zero as a Double// an integer value of 42// a positive double value of 3.14159// a string value of "hello"// an (x, y) point at 3.0, 5.0// a movie called 'Ghostbusters', dir. Ivan Reitman// Hello, Michael 22.在一个类型中嵌套另外一个类型 BlackjackCard（二十一点）,结构体中，嵌套Suit,Rank 两个枚举 1234567891011121314151617181920212223242526272829303132333435363738394041struct BlackjackCard &#123; // 嵌套的 Suit 枚举 enum Suit: Character &#123; case Spades = "♠", Hearts = "♡", Diamonds = "♢", Clubs = "♣" &#125; // 嵌套的 Rank 枚举 enum Rank: Int &#123; case Two = 2, Three, Four, Five, Six, Seven, Eight, Nine, Ten case Jack, Queen, King, Ace struct Values &#123; let first: Int, second: Int? &#125; var values: Values &#123; switch self &#123; case .Ace: return Values(first: 1, second: 11) case .Jack, .Queen, .King: return Values(first: 10, second: nil) default: return Values(first: self.rawValue, second: nil) &#125; &#125; &#125; // BlackjackCard 的属性和方法 let rank: Rank, suit: Suit var description: String &#123; var output = "suit is \(suit.rawValue)," output += " value is \(rank.values.first)" if let second = rank.values.second &#123; output += " or \(second)" &#125; return output &#125;&#125; 初始化 let theAceOfSpades = BlackjackCard(rank: .Ace, suit: .Spades) 使用：let heartsSymbol = BlackjackCard.Suit.Hearts.rawValue]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Swift学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift学习笔记《1》]]></title>
    <url>%2F2016%2F09%2F21%2F2016b%2Fswift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8A1%E3%80%8B%2F</url>
    <content type="text"><![CDATA[1.UIButton button 的初始化，点击事件 button 传入参数，和不传入参数市一样的，好像只写方法名 button 的属性 123456view.backgroundColor=UIColor.greenlet btn = UIButton(type: .system)btn.setTitle("button", for: .normal)btn.frame=CGRect(x: 100, y: 100, width: 100, height: 100)btn.addTarget(self, action: #selector(btnClick), for: .touchUpInside)view.addSubview(btn) 123func btnClick(buttt:UIButton) &#123;print(buttt) &#125; 2.UITableView 懒加载 lazy 关键字 + var 属性名 ：[集合中的类型] = { 设置return 类型 } ( ) mark 的标记 // MARK:懒加载 123lazy var dataSoure: [String] = &#123; return ["11","22","33","44","55"]&#125;() tableView的属性 跟OC类似， 1234567class ViewController: UIViewController,UITableViewDelegate,UITableViewDataSource &#123; override func loadView() &#123; let tv = UITableView(frame: UIScreen.main.bounds) tv.dataSource=self tv.delegate=self view=tv &#125; tableView的代理设置 实现代理，是在类后面逗号隔开 tableView的代理方法实现 数据源方法写在extension 中，提高代码的可读性 123456789101112131415161718// extension 想当于 OC中的categoryextension ViewController : UITableViewDelegate, UITableViewDataSource &#123; func numberOfSections(in tableView: UITableView) -&gt; Int &#123; return 1 &#125; func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return 5 &#125; //MARK: -数据源方法 func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; var cell = tableView.dequeueReusableCell(withIdentifier: "cell2") if cell==nil &#123; cell=UITableViewCell(style: .default, reuseIdentifier: "cell2") &#125; cell?.textLabel?.text = dataSoure[indexPath.row] return cell! &#125;&#125; 3.swift - TabBar 结构是tabBar 包括四个navigationController 123456789tabBar.tintColor=UIColor.orangeaddSelfChildViewController(childVC: BillListVC(), title: "账单", imageString: "home_tabbar_zd")addSelfChildViewController(childVC: StatementVC(), title: "报表", imageString: "home_tabbar_bb")addSelfChildViewController(childVC: InvoiceListVC(), title: "发票", imageString: "home_tabbar_fp")addSelfChildViewController(childVC: PartnerVC(), title: "伙伴", imageString: "home_tabbar_hb") 123456789101112131415private func addSelfChildViewController(childVC: UIViewController,title:String,imageString:String) &#123; childVC.tabBarItem.image=UIImage(named: imageString) childVC.tabBarItem.selectedImage=UIImage(named: imageString.appending("_h")) childVC.tabBarItem.title=title childVC.title=title; let nav = UINavigationController(rootViewController: childVC) addChildViewController(nav)&#125; 字符串用appdend ,拼接字符用+号 命名空间 可以被修改 12let nas = Bundle.main.infoDictionary! ["CFBundleExecutable"] as! String 从plist 获取json 进行解析。 从本地加载转化位nsdata, 使用JSONSeriralation 转化为数组，打印数组中的字典 contentsOfFile 方法是可选类型，调用 JSONSerialization.jsonObject 方法是需要强制解包， 打印 数组中的字典是时候，需要 声明数组中的数据类型 123456789101112131415let path = Bundle.main.path(forResource: "home.plist", ofType: nil)if let filePath = path&#123; do &#123; let data = NSData(contentsOfFile: filePath) let diarry:Any = try JSONSerialization.jsonObject(with: data! as Data, options: JSONSerialization.ReadingOptions.mutableContainers) for adic in diarry as! [[String:String]] &#123; print(adic) &#125; print(diarry) &#125; catch &#123; print("读取本地数据出现错误！") &#125;&#125; 4.swift-基类未登录界面 抽取基类，控制器作为子类 判断登录状态，如果登录就加载子类视图，如果没有登录加载未登录界面 设置自定义视图，流出接口方法，进行切换图片和文字 首页转盘图片动画 登录注册的代理方法 app的appearance tabbar,navigaitionBar 上代码 三目运算符 判断登录状态 12345let isHadLoggin :Bool = falselazy var nologvvv : NoLogView = NoLogView.shareNoLogView()override func loadView() &#123; isHadLoggin ? super.loadView(): setNoLogView()&#125; 根据控制器的不同，设置未登录页界面的图片和文字 123456789func setUpNologViewInfo(imageString:String,title:String)&#123; rotationView.isHidden=true iconImageView.image=UIImage(named: imageString) messageLable.text=title&#125; 设置首页转轮动画 1234567891011121314151617func addRotationAnimation()&#123; let animation = CABasicAnimation(keyPath: "transform.rotation.z") animation.fromValue = 0 animation.toValue = M_PI * 2 animation.repeatCount=MAXFLOAT animation.isRemovedOnCompletion = false animation.duration = 10 // 结束一次动画的时长 rotationView.layer.add(animation, forKey: "homeRotation")&#125; 设置代理 继承 NSObjectProtocol 设置代理属性 使用weak 关键字，可选类型 使用不用判断代理 直接使用 12345678protocol NoLogViewDelegate :NSObjectProtocol&#123; func registButtonWillClick() func logginButtonWillClick()&#125;weak var delegate:NoLogViewDelegate?delegate?.registButtonWillClick() 5.自定义转场动画 转场动画 需要两个VC，一个VC，弹出另外一个VC 需要一个Animator 工具类，遵守UIViewControllerTransitioningDelegate 负责处理动画，和告诉谁是处理展现的控制器 需要一个控制器，继承 UIPresentationController， 是Animator 工具类告诉代理，此控制器处理展现View 上代码 创建 HomePopOverAnimator， 12345678private lazy var homeAnimator : HomePopOverAnimator = HomePopOverAnimator()func changeAccoountBook()&#123; let vc = LeftChoseAccountBookVC() vc.modalPresentationStyle = .custom vc.transitioningDelegate = homeAnimator present(vc, animated: true, completion:nil)&#125; HomePopOverAnimator 处理 HomePopOverAnimator 遵守UIViewControllerTransitioningDelegate 协议，实现协议方法 在代理中创建负责展现view的HomeUIPresentationVC ，继承自UIPresentationController HomePopOverAnimator负责处理开始，结束动画，需要遵守UIViewControllerAnimatedTransitioning 协议 1234567891011121314151617181920212223// MARK:- 自定义转场代理的方法extension HomePopOverAnimator : UIViewControllerTransitioningDelegate &#123; // 告诉代理，谁是处理展示的VC public func presentationController(forPresented presented: UIViewController, presenting: UIViewController?, source: UIViewController) -&gt; UIPresentationController?&#123; let homePrentVC = HomeUIPresentationVC(presentedViewController: presented, presenting: presenting) return homePrentVC &#125; // 告诉代理，谁处理开始动画 public func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -&gt; UIViewControllerAnimatedTransitioning?&#123; isPresented = true return self &#125; // 告诉代理，谁处理结束动画 public func animationController(forDismissed dismissed: UIViewController) -&gt;UIViewControllerAnimatedTransitioning?&#123; isPresented = false return self &#125;&#125; UIViewControllerAnimatedTransitioning 代理 弹出和消失动画代理的方法，根据上下文处理动画形式 12345678910111213141516// MARK:- 弹出和消失动画代理的方法extension HomePopOverAnimator:UIViewControllerAnimatedTransitioning&#123; func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -&gt; TimeInterval&#123; return 1 &#125; func animateTransition(using transitionContext: UIViewControllerContextTransitioning)&#123; if isPresented &#123; animationForStartAnimation(ransitionContext: transitionContext) &#125;else&#123; animationForEndAnimation(ransitionContext: transitionContext) &#125; &#125;&#125; 私有方法，开始动画，结束动画，transition 动画 123456789101112131415161718192021222324252627// 开始动画private func animationForStartAnimation(ransitionContext: UIViewControllerContextTransitioning)&#123; // 获取view，将view加到contenterView上，执行动画 let containerView = ransitionContext.containerView let prentedView = ransitionContext.view(forKey: .to) containerView.addSubview(prentedView!) prentedView?.transform = CGAffineTransform.init(translationX: -containerView.bounds.size.width, y: 0) // prentedView?.layer.anchorPoint = CGPoint(x: 0.5, y: 0) UIView.animate(withDuration: transitionDuration(using: ransitionContext), animations: &#123; prentedView?.transform = CGAffineTransform.identity &#125;) &#123; (Bool) in ransitionContext.completeTransition(true) &#125;&#125;// 结束动画private func animationForEndAnimation(ransitionContext: UIViewControllerContextTransitioning)&#123; // 获取view， 执行消失动画 let containerView = ransitionContext.containerView let dismissView = ransitionContext.view(forKey: .from) UIView.animate(withDuration: transitionDuration(using: ransitionContext), animations: &#123; dismissView?.transform = CGAffineTransform.init(translationX: -containerView.bounds.size.width, y: 0) &#125;) &#123; (Bool) in dismissView?.removeFromSuperview() ransitionContext.completeTransition(true) &#125;&#125; HomeUIPresentationVC处理 负责显示的View ，左侧抽屉一半view，下面一层蒙版，能响应点击消失 设置需要展现视图的大小，设置遮盖为button，响应点击事件 12345678// 懒加载控件lazy var coverBGView :UIButton = UIButton()// 重写layoutsubviews 设置弹出视图的大小override func containerViewWillLayoutSubviews()&#123; super.containerViewWillLayoutSubviews() presentedView?.frame = CGRect(x: 0, y: 0, width: UIScreen.main.bounds.size.width*0.6, height: UIScreen.main.bounds.size.height) setCoverbgViews()&#125; 设置遮罩 frame和 响应方法 12345678910111213141516171819202122232425 extension HomeUIPresentationVC &#123; func setCoverbgViews()&#123; // 设置大小，插入到contenderView的最底层 coverBGView.titleLabel?.text="" coverBGView.frame = containerView!.bounds coverBGView.backgroundColor = UIColor.init(white: 0.8, alpha: 0.2) coverBGView.addTarget(self, action: #selector(tapCoverBgView), for: .touchUpInside) containerView?.insertSubview(coverBGView, at: 0) &#125; &#125; extension HomeUIPresentationVC &#123; @objc func tapCoverBgView(tap:UITapGestureRecognizer)&#123; presentedViewController.dismiss(animated: true, completion: nil) &#125; &#125; ``` #### 6.extension 使用类扩展增加方法- swift 中extension 相当于OC中的category 作为类的扩展- 单独创建文件做类的扩展- 在vc 中使用extension 作为 vc 的方法分类 苹果推荐 代理等方法写在extension里。- 上代码 command + N 创建Swift 文件，名字为UIBarBarItem+category- 为 UIBarButtonItem 增加一个类方法， 创建item 的titleLable extension UIBarButtonItem { class func titleLableWithText(title:String)-&gt;UILabel{ let lable = UILabel() lable.clipsToBounds = true lable.frame = CGRect(x: 0, y: 0, width: UIScreen.main.bounds.size.width*0.5, height: 30) lable.font = UIFont.systemFont(ofSize: 16) lable.textColor = UIColor.init(red: 51, green: 51, blue: 51, alpha: 1) lable.text = title return lable } } 123456789101112#### 7.创建二维码- 1.创建滤镜- 2.还原滤镜设置- 3.设置数据存入数据- 4.取出图片- 5.增加中间的头像- 6.设置高清图像&gt; 上代码 如下 - 1.2.3.4 步骤 //1.创建滤镜 let filer = CIFilter.init(name: “CIQRCodeGenerator”) // 2.还原滤镜的设置 filer?.setDefaults() // 3.设置数据 filer?.setValue(astring.data(using: .utf8), forKey: “inputMessage”) // 4.从滤镜中取出图片 CIImage let fileCiImage = filer?.outputImage 1- 增加中间的头像 UIGraphicsBegin // 开启图像上下文 UIGraphicsBeginImageContext(bgImage.size) // 绘制背景大小 bgImage.drawInRect(CGRect(origin: CGPointZero, size: bgImage.size)) // 绘制头像 let width:CGFloat = 50 let height:CGFloat = width let x = (bgImage.size.width - width) 0.5 let y = (bgImage.size.height - height) 0.5 iconImage.drawInRect(CGRect(x: x, y: y, width: width, height: height)) // 取出绘制好的图像 let newImage = UIGraphicsGetImageFromCurrentImageContext() // 关闭上下文 UIGraphicsEndImageContext() // 返回头像 return newImage 1- 绘制高清图像 /* 根据CIImage生成指定大小的高清UIImage :param: image 指定CIImage :param: size 指定大小 :returns: 生成好的图片 / private func createNonInterpolatedUIImageFormCIImage(image: CIImage, size: CGFloat) -&gt; UIImage { let extent: CGRect = CGRectIntegral(image.extent) let scale: CGFloat = min(size/CGRectGetWidth(extent), size/CGRectGetHeight(extent)) // 1.创建bitmap; let width = CGRectGetWidth(extent) * scale let height = CGRectGetHeight(extent) * scale let cs: CGColorSpaceRef = CGColorSpaceCreateDeviceGray()! let bitmapRef = CGBitmapContextCreate(nil, Int(width), Int(height), 8, 0, cs, 0)! let context = CIContext(options: nil) let bitmapImage: CGImageRef = context.createCGImage(image, fromRect: extent) CGContextSetInterpolationQuality(bitmapRef, CGInterpolationQuality.None) CGContextScaleCTM(bitmapRef, scale, scale); CGContextDrawImage(bitmapRef, extent, bitmapImage); // 2.保存bitmap到图片 let scaledImage: CGImageRef = CGBitmapContextCreateImage(bitmapRef)! return UIImage(CGImage: scaledImage) } ` 8.扫描二维码 懒加载会话，输入，输出 判断会话能不能添加输入输出 ， 会话添加输入输出 设置输出数据类型 设置输出对象代理 开始扫描 添加预览图层]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Swift学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift高级运算符-读书笔记]]></title>
    <url>%2F2016%2F09%2F20%2F2016b%2Fswift%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[1.高级运算符 位运算符，移位运算符 ，溢出加法运算符， 2.位运算法 按位 取反 运算符 ～ 按位 与 运算符 &amp; 按位 或 运算符 | 按位 异或 运算符 ^ 按位 左移，右移 运算符 &lt;&lt; 和 &gt;&gt; 取反 ～0b00001111 = 0b11110000 与 0b11111100 &amp; 0b00111111 = 00111100 或 0b10110010 | 0b01011110 = 11111110 异或 0b00010100 ^ 0b00000101 = 00010001 无符号左移右移 逻辑移位 无符号整数的移位运算 对无符号整数进行移位的规则如下： 已经存在的位按指定的位数进行左移和右移 任何因移动而超出整型存储范围的位都会被丢弃 用 0 来填充移位后产生的空白位 颜色值16进制CC6699 转为10进制RGB（204，102，153） 有符号的按位左移右移运算 算术移位 符号为0为正，1为负 它存储的值的绝对值等于 2 的 n 次方减去它的实际值（也就是数值位表示的值），这里的 n 为数值位的比特位数。一个 8 比特位的数有 7 个比特位是数值位，所以是 2 的 7 次方，即 128 对有符号整数的右移有一个额外的规则 当对整数进行按位右移运算时，遵循与无符号整数相同的规则，但是对于移位产生的空白位使用符号位进行填充，而不是用 0 3.溢出运算符 溢出加法（&amp;+）溢出减法（&amp;-），溢出乘法（&amp;*） UInt8.max &amp;+ 1 = 0 UInt8.min &amp;- 1 = 255 在对有符号整型数值进行溢出加法或溢出减法运算时，符号位也需要参与计算 Int8.min &amp;- 1 = 127（-128 - 1 = 127） 对于无符号与有符号整型数值来说，当出现上溢时，它们会从数值所能容纳的最大数变成最小的数。同样地，当发生下溢时，它们会从所能容纳的最小数变成最大的数。 4.运算符函数 类和结构体可以为现有的运算符实现自定义的实现，成为运算符重载 双目中缀运算符的自定义实现 对加号的重载 前缀和后缀运算符（-A）取反 复合运算符 （+= ） 等价运算符 （== ，!=） 5.自定义运算符，自定义优先级 “新的运算符要使用 operator 关键字在全局作用域内进行定义，同时还要指定 prefix、infix或者 postfix 修饰符： +++ 实现，自增的正值 优先级]]></content>
      <categories>
        <category>实用技术</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>实用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift语法-读书笔记]]></title>
    <url>%2F2016%2F09%2F20%2F2016b%2Fswift%E8%AF%AD%E6%B3%95-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1.字符串语法 字符串的转移 类型转换运算符 字面量表达式 2.语句 guard defer 语句 #if endif 下标声明 运算符声明 infix operator 优先级声明 声明修饰符 3.特性 available iOS，iOSApplicationExtension —- @available(iOS 10.0, macOS 10.12, *) unavailable 在指定的平台上无效的 introduced = 版本号 deprecated = 版本号 obsoleted = 版本号 renamed = 新名字 discardableResult 抑制编译器中 函数或方法的返回值被调而没有使用其结果的警告 GKInspectable 暴露一个自定义GameplayKit组件属性给SpriteKit编辑器UI objc NSApplicationMain NSCopying NSManaged testable UIApplicationMain autoclosure escaping convention 4.权限 下面的代码表示把变量UUID的赋值权限设为private，对整个app可读，但值只能在本文件里写入 5.值类型和引用类型 值类型：枚举，结构体，元组 引用类型：类 值类型复制，是全部复制；引用类型复制是指针复制，其实是同一个数据。]]></content>
      <categories>
        <category>实用技术</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>实用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记网站]]></title>
    <url>%2F2016%2F09%2F06%2F2016b%2F%E7%AC%94%E8%AE%B0%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[技术路线： Java学习路线图 人工智能+Python学习路线图 前端与移动开发学习路线图 H5+全栈工程师学习路线图 产品经理学习路线图 云计算大数据学习路线图1.IT社区: 推荐 http://www.cnblogs.com/ http://www.csdn.net/ http://www.51cto.com/ http://www.cocoachina.com/ http://www.techcn.com.cn/ http://mobilehub.io/ 2.iOS 学习网站: iOS 学习网站 http://www.w3school.com.cn/ http://objccn.io/ http://github.ibireme.com/github/list/ios/ github上ios第三方库集合 可以多看看 https://github.com/chasseurmic/TWRProgressView Swift学习 https://github.com/CocoaChina-editors/Welcome-to-Swift https://github.com/numbbbbb/the-swift-programming-language-in-chinese http://www.infoq.com/cn 软件开发领域:此网站里面有很多文章都是翻译国外的 里面有一些架构设计的文章很不错 http://www.cnblogs.com/wendingding/ 传智学员记录了学习ios 安全: http://blog.csdn.net/yiyaaixuexi 好像是一位妹子好牛逼 http://nianxi.net/ 她的新博客不过现在内容比较少 http://bbs.pediy.com/ 开雪学院 国内重量级 数据结构与算法 http://blog.csdn.net/v_july_v http://blog.csdn.net/itcastcpp?viewmode=contents C++学院院长 尹成 blog: http://blog.devtang.com/ 唐巧 曾开发网易微博后台\ iOS:曾开发过 有道云笔记\粉笔网\猿题库 http://onevcat.com/ 王巍 就职Line 技术领域: ios+Unity3d http://beyondvincent.com/blog/archives/ http://esoftmobile.com/ http://blog.csdn.net/tonny_guan?viewmode=contents http://blog.csdn.net/opengl_es 游戏开发: http://blog.codingnow.com/ 吴云洋( 云风) 很牛逼 网易研究中心总监 http://www.gameres.com/ 非常不错的一个 游戏资讯门户 http://game.ceeger.com/forum/ Unity3D 学习论坛 开源网站: https://github.com/ http://code4app.com/ http://code.cocoachina.com/ 推荐书籍: 现代操作系统 iOS与OS X多线程和内存管理 Effective Objective-C 2.0：编写高质量iOS与OS X代码的52个有效方法 Objective-C编程之道：iOS设计模式解析 iOS应用逆向工程：分析与实战 重构：改善既有代码的设计 鸟哥的Linux私房菜 3.学习资源 一个非常强大的mac retina高清壁纸网站 http://wallpaperswide.com Quartz2D使用 http://www.cnblogs.com/wendingding/p/3778940.html Quartz2D简单介绍 Quartz2D简单使用（一） Quartz2D简单使用(二) Quartz2D简单使用（三） iOS开发UI篇—Quartz2D使用（绘制基本图形） Quartz2D(自定义UIImageView控件) Quartz2D使用（截屏） Quartz2D使用(信纸条纹) Quartz2D使用（绘图路径） Quartz2D使用（图片剪切） Quartz2D使用（矩阵操作） Quartz2D使用（图形上下文栈） 李明杰浅谈逆向 https://pan.baidu.com/s/1kVn1Nc7#list/path=%2F 密码: hq19 自动化测试视频讲解 https://pan.baidu.com/s/1boQb6cZ#list/path=%2F 揭秘微博、微信刷fen平台内幕与实战吸粉 https://pan.baidu.com/s/1i5PzDpb#list/path=%2F 密码: cgj6 求职心态篇 https://pan.baidu.com/s/1nvC02ZB#list/path=%2F 密码: wz8a vue.js腾讯课堂百度云链接： https://pan.baidu.com/s/1nvPXGpj#list/path=%2F 密码: v2vw 带你玩转github https://pan.baidu.com/s/1mi4uMhU#list/path=%2F 密码: yg1t 微信朋友圈开发视频：（转给你需要的朋友） https://pan.baidu.com/s/1cKUb9c#list/path=%2F 即时通常融云讲解视频： https://pan.baidu.com/s/1eRDehUi#list/path=%2F swiift项目实战视频： https://pan.baidu.com/s/1c1YgVoG#list/path=%2F iOS面试官面试上百个iOS感受以及面试技巧 https://pan.baidu.com/s/1eSqtFlo#list/path=%2F-1000套求职简历模板： https://pan.baidu.com/s/1jIHVLK6#list/path=%2F lldb调试bug高级用法 https://pan.baidu.com/s/1o89Gb82#list/path=%2F 支付宝生活圈开发视频：（仅限学习使用） https://pan.baidu.com/s/1nuZPSiH#list/path=%2F 4.GitHub网址 https://github.com/lihongli528628/HLBookReader 电子书+语音阅读 https://github.com/GGGHub/Reader 电子书源码 https://github.com/Aufree/trip-to-iOS iOS学习资料列表，开源框架前100， https://github.com/nicklockwood/iCarousel 动画 轮播动画，反转的类似 https://github.com/zwaldowski/BlocksKit 改变系统的target+selector模式为 block模式。 带来紧凑的代码风格，高效率的回调执行 objc.io Swift Apprentice objectManager 5.博客 iOS Provisioning Profile(Certificate)与Code Signing详解 基于 CoreText 的排版引擎：基础 iOS开发之网络编程篇六：AFNetworking3.0使用简介 RTImageAssets：自动生成全尺寸icon以及2x/3x图片 网易滚动导航栏——（第三方框架实现） HACursor AMScrollingNavbar框架(自动隐藏导航栏)使用简介 3D Touch 使用：Quick Action（Short Cut） 3D Touch 使用：Peek 和 Pop 系统自带的iOS扫描二维码 AVMetadataObjec 友盟消息推送SDK集成 NSScanner类的基本用法 6.技巧网址 iOS/mac开发的一些知名个人博客 http://www.cocoachina.com/bbs/read.php?tid=299721 Windows 8.1正式版官方专业版原版iso镜像系统下载 http://www.wingod8.com/a/yuanbanxitong/win8/466.html 程序员如何优雅地使用 Mac？ http://www.zhihu.com/question/20873070 ios开发学习笔记 http://blog.csdn.net/mad1989/article/details/7972612 苹果6Mac软件下载网址 http://www.pc6.com/mac/ 少数派 https://sspai.com/post/33493 Xcode插件优缺点对比（推荐20款插件） http://www.cnblogs.com/dsxniubility/p/5099191.html CocoaChina 代码分类 ://code.cocoachina.com/ code4App 7.分享网址 仿新浪微博表情键盘 HMEmoticon https://github.com/itheima-developer/HMEmoticon 轻量级的上拉／下拉刷新控件 https://github.com/itheima-developer/HMRefresh 轻量级图像选择框架 https://github.com/itheima-developer/HMImagePicker Objective-C 语法糖 https://github.com/itheima-developer/HMObjcSugar 轻量级图片浏览器 https://github.com/itheima-developer/HMPhotoBrowser swift二维码 https://github.com/liufan321/SwiftQRCode FFlable https://github.com/liufan321/FFLabel]]></content>
      <categories>
        <category>实用技术</category>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>实用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NSPropertyListSerialization 持久化字典与数组]]></title>
    <url>%2F2016%2F06%2F19%2F2016b%2FNSPropertyListSerialization%20%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%97%E5%85%B8%E4%B8%8E%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[NSPropertyListSerialization 持久化字典与数组 使用 封装细节 设置存储路径，方法1：根据字典路径存储 方法2： 根据路径返回字典，修改后存储 .m文件实现]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>实用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后台上传300张图片]]></title>
    <url>%2F2016%2F06%2F18%2F2016b%2F%E5%90%8E%E5%8F%B0%E4%B8%8A%E4%BC%A0300%E5%BC%A0%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[后台上传300张图片 监听进入后台通知，执行后台方法。结束任务时结束后台任务task 参考简书： http://www.jianshu.com/p/9bf161a14725 、 锁屏 或者进入后台能继续上传 监听通知： 设置后台任务，设置自己的任务，完成时结束任务写在block里面 执行耗时操作，如果所有的都上传完，就执行completionBlock(); 执行上面的代码，结束任务]]></content>
      <categories>
        <category>实用技术</category>
        <category>开发问题</category>
      </categories>
      <tags>
        <tag>实用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新浪微博分享不跳转]]></title>
    <url>%2F2016%2F06%2F18%2F2016b%2F%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A%E5%88%86%E4%BA%AB%E4%B8%8D%E8%B7%B3%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[实际开发中遇到第三方分享分享微博不能跳转 1.在info.plist 中，设置白名单，少设置了后面2个，加上之后正常跳转 2.新浪微博和其他分享不一样，只能分享图片和文字， 3.将网址和文字拼接在一块，在微信上显示网址，在微博上只显示链接，]]></content>
      <categories>
        <category>实用技术</category>
        <category>开发问题</category>
      </categories>
      <tags>
        <tag>实用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS关于启动页自定义特殊处理 启动广告]]></title>
    <url>%2F2016%2F06%2F17%2F2016b%2FiOS%E5%85%B3%E4%BA%8E%E5%90%AF%E5%8A%A8%E9%A1%B5%E8%87%AA%E5%AE%9A%E4%B9%89%E7%89%B9%E6%AE%8A%E5%A4%84%E7%90%86%20%E5%90%AF%E5%8A%A8%E5%B9%BF%E5%91%8A%2F</url>
    <content type="text"><![CDATA[其实原理也是很简单，启动页还是运用Launch Images Source的内容，然后在做一个视图在最上层，视图的背景用启动项的那张图，让人误以为还在启动中，启动页加载完成后，就显示这层视图，在2秒后再把这层视图删除，产生一个过度的假启动页效果；而我们自定义的动作就可以在这层视图上进行；下面将通过Coding.net的APP讲解这个功能 一：创建一个视图EaseStartView EaseStartView.h文件内容： 12345#import &lt;UIKit/UIKit.h&gt;@interface EaseStartView : UIView+ (instancetype)startView;- (void)startAnimationWithCompletionBlock:(void(^)(EaseStartView *easeStartView))completionHandler;@end EaseStartView.m文件内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#import "EaseStartView.h"#import &lt;NYXImagesKit/NYXImagesKit.h&gt;#import "StartImagesManager.h"@interface EaseStartView ()@property (strong, nonatomic) UIImageView *bgImageView, *logoIconView;@property (strong, nonatomic) UILabel *descriptionStrLabel;@end@implementation EaseStartView+ (instancetype)startView&#123; UIImage *logoIcon = [UIImage imageNamed:@"logo_coding_top"]; StartImage *st = [[StartImagesManager shareManager] randomImage]; return [[self alloc] initWithBgImage:st.image logoIcon:logoIcon descriptionStr:st.descriptionStr];&#125;- (instancetype)initWithBgImage:(UIImage *)bgImage logoIcon:(UIImage *)logoIcon descriptionStr:(NSString *)descriptionStr&#123; self = [super initWithFrame:kScreen_Bounds]; if (self) &#123; //add custom code UIColor *blackColor = [UIColor blackColor]; self.backgroundColor = blackColor; _bgImageView = [[UIImageView alloc] initWithFrame:kScreen_Bounds]; _bgImageView.contentMode = UIViewContentModeScaleAspectFill; _bgImageView.alpha = 0.0; [self addSubview:_bgImageView]; [self addGradientLayerWithColors:@[(id)[blackColor colorWithAlphaComponent:0.4].CGColor, (id)[blackColor colorWithAlphaComponent:0.0].CGColor] locations:nil startPoint:CGPointMake(0.5, 0.0) endPoint:CGPointMake(0.5, 0.4)]; _logoIconView = [[UIImageView alloc] init]; _logoIconView.contentMode = UIViewContentModeScaleAspectFit; [self addSubview:_logoIconView]; _descriptionStrLabel = [[UILabel alloc] init]; _descriptionStrLabel.font = [UIFont systemFontOfSize:10]; _descriptionStrLabel.textColor = [UIColor colorWithWhite:1.0 alpha:0.5]; _descriptionStrLabel.textAlignment = NSTextAlignmentCenter; _descriptionStrLabel.alpha = 0.0; [self addSubview:_descriptionStrLabel]; [_descriptionStrLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.centerX.equalTo(@[self, _logoIconView]); make.height.mas_equalTo(10); make.bottom.equalTo(self.mas_bottom).offset(-15); make.left.equalTo(self.mas_left).offset(20); make.right.equalTo(self.mas_right).offset(-20); &#125;]; [_logoIconView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.centerX.equalTo(self); make.top.mas_equalTo(kScreen_Height/7); make.width.mas_equalTo(kScreen_Width *2/3); make.height.mas_equalTo(kScreen_Width/4 *2/3); &#125;]; [self configWithBgImage:bgImage logoIcon:logoIcon descriptionStr:descriptionStr]; &#125; return self;&#125; 1234567- (void)configWithBgImage:(UIImage *)bgImage logoIcon:(UIImage *)logoIcon descriptionStr:(NSString *)descriptionStr&#123;bgImage = [bgImage scaleToSize:[_bgImageView doubleSizeOfFrame] usingMode:NYXResizeModeAspectFill];self.bgImageView.image = bgImage;self.logoIconView.image = logoIcon;self.descriptionStrLabel.text = descriptionStr;[self updateConstraintsIfNeeded];&#125; 1234567891011121314151617181920212223242526- (void)startAnimationWithCompletionBlock:(void(^)(EaseStartView *easeStartView))completionHandler&#123; [[UIApplication sharedApplication].keyWindowaddSubview:self]; [[UIApplication sharedApplication].keyWindowbringSubviewToFront:self]; _bgImageView.alpha = 0.0; _descriptionStrLabel.alpha = 0.0; @weakify(self); [UIView animateWithDuration:2.0 animations:^&#123; @strongify(self); self.bgImageView.alpha = 1.0; self.descriptionStrLabel.alpha = 1.0; &#125; completion:^(BOOL finished) &#123; [UIView animateWithDuration:0.6 delay:0.3 options:UIViewAnimationOptionCurveEaseIn animations:^&#123; @strongify(self); [self setX:-kScreen_Width]; &#125; completion:^(BOOL finished) &#123; @strongify(self); [self removeFromSuperview]; if (completionHandler) &#123; completionHandler(self); &#125; &#125;]; &#125;];&#125;@end 其实本实例中最为关键的内容在方法startAnimationWithCompletionBlock里 12[[UIApplication sharedApplication].keyWindow addSubview:self];[[UIApplication sharedApplication].keyWindow bringSubviewToFront:self]; 代码就是把这个视图设置成在最前的最上层，这样就可以盖住程序中的页面； 123456789101112131415161718192021_bgImageView.alpha = 0.0;_descriptionStrLabel.alpha = 0.0;这个是为了下面的动画做准备，若是直接用背景图可以把这两个都设置成0.99这样就不会有一闪的错觉；@weakify(self);[UIView animateWithDuration:2.0 animations:^&#123; @strongify(self); self.bgImageView.alpha = 1.0; self.descriptionStrLabel.alpha = 1.0;&#125; completion:^(BOOL finished) &#123; [UIView animateWithDuration:0.6 delay:0.3 options:UIViewAnimationOptionCurveEaseIn animations:^&#123; @strongify(self); [self setX:-kScreen_Width]; &#125; completion:^(BOOL finished) &#123; @strongify(self); [self removeFromSuperview]; if (completionHandler) &#123; completionHandler(self); &#125; &#125;];&#125;]; 这边是动画效果，时间设置为2秒，因为这边第一个动画完还有一个缩放的效果；当动画结束后就可以 [self removeFromSuperview]; 二：调用启动页视图 在AppDelegate中的didFinishLaunchingWithOptions进行调用； 1234567891011121314151617181920212223242526272829303132- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];// Override point for customization after application launch.self.window.backgroundColor = [UIColor whiteColor];//网络[[AFNetworkActivityIndicatorManager sharedManager] setEnabled:YES];[[AFNetworkReachabilityManager sharedManager] startMonitoring];//设置导航条样式[self customizeInterface];[[UIApplication sharedApplication] setStatusBarHidden:NO withAnimation:UIStatusBarAnimationFade];if ([Login isLogin]) &#123; [self setupTabViewController];&#125;else&#123; [UIApplication sharedApplication].applicationIconBadgeNumber = 0; [self setupIntroductionViewController];&#125;[self.window makeKeyAndVisible];[FunctionIntroManager showIntroPage];EaseStartView *startView = [EaseStartView startView];@weakify(self);[startView startAnimationWithCompletionBlock:^(EaseStartView *easeStartView) &#123; @strongify(self); //可以做其它事情&#125;];return YES;&#125; 注意，EaseStartView代码的位置是要放在最后面，因为要让它盖在最上层，就要后面加载，这样就可以盖在登录页面上面或者主页上；到这就已经可以成功启动页的效果； 三：下面实例为项目中用到的动态加载版本号到启动页上123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#import "StartUpView.h"@interface StartUpView()@property (strong, nonatomic) UIImageView *bgImageView;@property (strong, nonatomic) UILabel *descriptionStrLabel;@end@implementation StartUpView+ (instancetype)startView &#123; UIImage *bgImage=kshamLaunchImage; return [[self alloc] initWithBgImage:bgImage];&#125;- (instancetype)initWithBgImage:(UIImage *)bgImage&#123; self = [super initWithFrame:Main_Screen_Bounds]; if (self) &#123; _bgImageView = [[UIImageView alloc] initWithFrame:Main_Screen_Bounds]; _bgImageView.contentMode = UIViewContentModeScaleAspectFill; _bgImageView.alpha = 0; _bgImageView.image=bgImage; [self addSubview:_bgImageView]; _descriptionStrLabel = [[UILabel alloc] init]; _descriptionStrLabel.font = [UIFont systemFontOfSize:15]; _descriptionStrLabel.textColor = [UIColor blackColor]; _descriptionStrLabel.textAlignment = NSTextAlignmentCenter; _descriptionStrLabel.alpha = 0; _descriptionStrLabel.text=[NSString stringWithFormat:@"版本号为:%@",appVersion]; [self addSubview:_descriptionStrLabel]; [_descriptionStrLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.height.mas_equalTo(50); make.bottom.equalTo(self.mas_bottom).offset(-15); make.left.equalTo(self.mas_left).offset(20); make.right.equalTo(self.mas_right).offset(-20); &#125;]; &#125; return self;&#125;- (void)startAnimationWithCompletionBlock:(void(^)(StartUpView *easeStartView))completionHandler&#123; [[UIApplication sharedApplication].keyWindow addSubview:self]; [[UIApplication sharedApplication].keyWindow bringSubviewToFront:self]; _bgImageView.alpha = 0.99; _descriptionStrLabel.alpha = 0.99; @weakify(self); [UIView animateWithDuration:2.0 animations:^&#123; @strongify(self); self.bgImageView.alpha = 1.0; self.descriptionStrLabel.alpha = 1.0; &#125; completion:^(BOOL finished) &#123; [self removeFromSuperview]; if (completionHandler) &#123; completionHandler(self); &#125; &#125;];&#125;@end]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>实用</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新特性界面]]></title>
    <url>%2F2016%2F06%2F16%2F2016b%2F%E6%96%B0%E7%89%B9%E6%80%A7%E7%95%8C%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[使用collectionView UIcollectionViewlayout 自定义prepared 调用顺序，1.count，2.准备布局，3.返回cell 重写init 方法，设置外部参数照片的数组， 一个文件中可以创建多个class ，创建类flowLyout. newFertureCell NewfeatureLayout 中prepareLayout() 方法 设置layout的参数，和collectionView的参数 什么时候调用? 1.先调用一个有多少行cell 2.调用准备布局 3.调用返回cell 1234567891011121314151617181920212223override func prepareLayout() &#123;// 1.设置layout布局itemSize = UIScreen.mainScreen().bounds.sizeminimumInteritemSpacing = 0minimumLineSpacing = 0scrollDirection = UICollectionViewScrollDirection.Horizontal// 2.设置collectionView的属性collectionView?.showsHorizontalScrollIndicator = falsecollectionView?.bounces = falsecollectionView?.pagingEnabled = true &#125; cell 中设置button 显示的动画，设置button的点击发送通知 设置 transform 动画，完成之后 transform 设置 CGAffineTransform.identity ，归位初始值 usingSpringWithDamping 为（0-1）， 数值越小，弹力越大 initialSpringVelocity 速度 5,10,15 1234567891011121314151617181920// button的动画func buttonStartAnimation()&#123; cellButton.isHidden = false cellButton.transform = CGAffineTransform(scaleX: 0, y: 0); cellButton.isUserInteractionEnabled = false UIView.animate(withDuration: 2, delay: 0, usingSpringWithDamping: 0.8, initialSpringVelocity: 10, options: UIViewAnimationOptions.init(rawValue: 0), animations: &#123; self.cellButton.transform = CGAffineTransform.identity &#125;) &#123; (_) in self.cellButton.isUserInteractionEnabled = true &#125;&#125; swift 3.0 之发送通知 创建一个swift文件，存储常量， 通知变化为 NSNotification.Name(rawValue:””） 123456789// 发送通知let SwitchRootVCNotification = NSNotification.Name(rawValue:"SwitchRootViewControllerKey")NotificationCenter.default.post(name:SwitchRootVCNotification, object: nil)// 接收通知NotificationCenter.default.addObserver(self, selector: #selector(changeRoot), name: SwitchRootVCNotification, object: nil)]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>实用</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FRDLiveLyButton]]></title>
    <url>%2F2016%2F05%2F05%2F2016b%2FFRDLiveLyButton%2F</url>
    <content type="text"><![CDATA[1.FRDLiveLyButton 使用FRDLiveLyButton 有动画的button，FRDLiveLyButton 实用方法 1.设置style 2: setOptions方法，设置外观 2.基于FMDB的keyValue 唐巧基于FMDB的keyValue模式存储，value是json格式活着是字典数组模型可以考虑存储 3.LazyFadeInView 说明LazyFadeInView 非常酷，以一种动画的形式来显示一个label。 使用LazyFadeInView，创建一个LazyFadeInView，然后添加到你的view中。它会自动的用动画的形式显示出来。 代码 1234LazyFadeInView *fadeInView = [[LazyFadeInView alloc] initWithFrame:CGRectMake(20, 120, 280, 200)];self.fadeInView.text = @"Stray birds of summer come to my window to sing and fly away.";self.fadeInView.textColor = [UIColor whiteColor];[self.view addSubview:self.fadeInView]; 4.YLGIFImage 异步加载GIF图片的类，支持GIF图片的播放与暂停。 它用的内存很少，完全解码GIF通常会消耗600MB的内存（800x600x389x4 Bytes），但是如果你用了YLGIFImage，它只占用30MB内存。 上面这张GIF图片。iOS加载时会直接崩溃，而使用了YLGIFImage，那就不会。 123YLImageView* imageView = [[YLImageView alloc] initWithFrame:CGRectMake(0, 160, 320, 240)];[self.view addSubview:imageView];imageView.image = [YLGIFImage imageNamed:@"joy.gif"]; 5.SDCycleScrollView 轮播图的使用 SDCycleScrollView 轮播图的使用： 初始化的方法，给定位置，何数据源，图片网址 若是顶部出现空白区域：设置 self.automaticallyAdjustsScrollViewInsets = NO pagecontrol的小圆点自定义接口改为：currentPageDotColor、pageDotColor、currentPageDotImage、pageDotImage 设置定义的标题，代理，时间间隔 12345// 网络加载图片的轮播器 SDCycleScrollView *cycleScrollView = [cycleScrollViewWithFrame:frame delegate:delegate placeholderImage:placeholderImage]; cycleScrollView.imageURLStringsGroup = imagesURLStrings; // 本地加载图片的轮播器 SDCycleScrollView *cycleScrollView = [SDCycleScrollView cycleScrollViewWithFrame: imagesGroup:图片数组]; 12345678// 设置pageControl居右，默认居中cycleScrollView.pageControlAliment = SDCycleScrollViewPageContolAlimentRight; // 如果设置title数组，则会在图片下面添加标题cycleScrollView.titlesGroup = 标题数组（数组元素个数必须和图片数组元素个数保持一致）; // 如需监听图片点击，请设置代理，实现代理方法cycleScrollView.delegate = ;// 自定义轮播时间间隔cycleScrollView.autoScrollTimeInterval = ;]]></content>
      <categories>
        <category>UI</category>
      </categories>
      <tags>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用cocoapods中遇到的问题]]></title>
    <url>%2F2016%2F03%2F21%2F2016b%2F%E4%BD%BF%E7%94%A8cocoapods%2F</url>
    <content type="text"><![CDATA[1.使用cocoapods 使用时需要新建一个名为 Podfile 的文件，以如下格式，将依赖的库名字依次列在 文件中即可 然后你将编辑好的 Podfile 文件放到你的项目根目录中，执行如下命令即可： 现在，你的所有第三方库都已经下载完成并且设置好了编译参数和依赖，你只需要记住如下 2 点即可： 使用 CocoaPods 生成的 .xcworkspace 文件来打开工程，而不是以前的 .xcodeproj 文件。 每次更改了 Podfile 文件，你需要重新执行一次pod update命令。 进行搜索第三方框架的时候，终端命令输入 pod search json 找到做多版本更新最多的，粘贴复制到podfile文件中，这个文件在项目的根目录下，一个项目使用一个podfile， 2.使用pod时 pod search 第三方框架 复制 版本更新最多的，将podfile 文件复制到项目跟路径下，修改podfile文件内容， 保存， 执行pod install命令，执行成功之后，是已经加入到workspace中。 3.使用第三方有cocoapods时，进行pod update: 用这时候，打开终端，进入UAAppReviewManagerExample所在的目录，也就是和Podfile在同一目录下，和场景1一样，输入以下命令（由于已经有Podfile，所以不需要再创建Podfile）： 下载的第三方中间有podfile和podlock,直接切换到根目录下进行更新。 $ pod update pod setup 等待时间过上 从GitHub上下载文件，下载，详情请看Alamofire4.4.0 安装 或替换下载源 123pod repo remove masterpod repo add master https://gitcafe.com/akuandev/Specs.gitpod repo update 4.问题： cocoapoadss的出现问题，pod Install 也不行， 1build diff: /../Podfile.lock: No such file or directory 开始的时候用pod install/update各种都没有用。后来试了这种方法，重新build就ok。 在工程设置中的Build Phases下删除Check Pods Manifest.lock及Copy Pods Resources 5.删除cocoapads 删除下载资源库 直接删除改行就行 cd到当前项目目录下，重新执行pod install命令 123451.打开Podfile文件，删除JSONKit该行，即：platform:ios, '7.0' pod 'AFNetworking', '~&gt; 2.1.0'pod 'JSONKit', '~&gt; 1.5pre'（删除该行）pod 'MBProgressHUD', '~&gt; 0.8' 删除整个cocoapods 删除工程文件夹下的Podfile、Podfile.lock和Pods文件夹 删除xcworkspace文件。 打开xcodeproj文件，删除项目中的libpods.a和Pods.xcconfig引用： 打开Build Phases选项，删除Check Pods Manifest.lock和Copy Pods Resources 6.cocoaPods - Alamofire4.4.0 安装cocoaPods 开始： -&gt; 打开Terminal 移走原有的ruby源 1gem sources -remove https://rubygems.org/ 指定添加国内最新镜像源 gem sources -a https://gems.ruby-china.org/ 查看结果 gem sources -l 检查更新ruby环境 sudo gem update --system 最新安装cocoapods的路径 sudo gem install -n /usr/local/bin cocoapods 直接敲 pod setup 检查是否安装成功 cd 项目目录下 cd ~/Path/To/Folder/Containing/IceCreamShop 创建podFile 12pod initopen -a Xcode Podfile 编辑podFile 123456*#* Uncomment this line to define a global platform for your project*#* platform :ios, '6.0' target 'IceCreamShop' do end target 'IceCreamShopTests' do end 将注释的内容替换成下面的两行： 12platform :ios, "8.0"use_frameworks! pod install 完成 有坑 pod install 中由于网络原因下载不动 最终解决方案：在GitHub上找到Specs 后fork到自己的工程,然后使用工具GitHub Desktop工具把Specs下载下来，更名成master ，替换路径~/.cocoapods/repos目录下的master。就可以正常使用了 master 中.git .gitignore 是隐藏文件，直接覆盖的话会出错 7.cocoaPods - Alamofire4.4.0]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>cocoapods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KVC/KVO的内部实现]]></title>
    <url>%2F2016%2F03%2F11%2F2016b%2FKVC%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[KVC的内部实现 KVC运用了isa-swizzing技术。isa-swizzing就是类型混合指针机制。KVC通过isa-swizzing实现其内部查找定位。 isa指针（is kind of 的意思）指向维护分发表的对象的类，该分发表实际上包含了指向实现类中的方法的指针和其他数据。 12345 [site setValue:@"sitename" forKey:@"name"]//会被编译器处理成SEL sel = sel_get_uid(setValue:forKey);IMP method = objc_msg_loopup(site-&gt;isa,sel);method(site,sel,@"sitename",@"name"); 每个类都有一张方法表，是一个hash表，值是还书指针IMP，SEL的名称就是查表时所用的键。 SEL数据类型：查找方法表时所用的键。定义成char*，实质上可以理解成int值。 IMP数据类型：他其实就是一个编译器内部实现时候的函数指针。当Objective-C编译器去处理实现一个方法的时候，就会指向一个IMP对象，这个对象是C语言表述的类型。 KVC的内部机制： 一个对象在调用setValue的时候进行了如下操作： 根据方法名找到运行方法的时候需要的环境参数 他会从自己的isa指针结合环境参数，找到具体的方法实现接口。 再直接查找得来的具体的实现方法 KVO概述 键值观察Key-Value-Observer就是观察者模式。 观察者模式的定义：一个目标对象管理所有依赖于它的观察者对象，并在它自身的状态改变时主动通知观察者对象。这个主动通知通常是通过调用各观察者对象所提供的接口方法来实现的。观察者模式较完美地将目标对象与观察者对象解耦。当需要检测其他类的属性值变化，但又不想被观察的类知道，有点像FBI监视嫌疑人，这个时候就可以使用KVO了。 KVO同KVC一样都依赖于Runtime的动态机制 注册： 1 -(void)addobserver:(nsobject*)anobserer forkeypath:(nsstrig*)keypath options:(nskeyValueObservingOptions)options context:(void*)context&#123;&#125; 实现方法： ofOject:(id)object change:(nsdictionary*)change context:(void*)context ```12- 移除：``` －(void)removeObsever:(nsobject)observer forkeypath:(nsnsting*)keypath; KVO实现步骤12345678910111213141516 注册//keyPath就是要观察的属性值//options给你观察键值变化的选择//context方便传输你需要的数据-(void)addObserver:(NSObject *)anObserver forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(void *)context 实现方法//change里存储了一些变化的数据，比如变化前的数据，变化后的数据；如果注册时context不为空，这里context就能接收到。-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context 移除- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath; 系统实现KVO有以下几个步骤： 当类A的对象第一次被观察的时候，系统会在运行期动态创建类A的派生类。我们称为B。 在派生类B中重写类A的setter方法，B类在被重写的setter方法中实现通知机制。类B重写会 class方法，将自己伪装成类A。类B还会重写dealloc方法释放资源。 系统将所有指向类A对象的isa指针指向类B的对象。 KVO同KVC一样，通过 isa-swizzling 技术来实现。当观察者被注册为一个对象的属性的观察对象的isa指针被修改，指向一个中间类，而不是在真实的类。其结果是，isa指针的值并不一定反映实例的实际类。 所以不能依靠isa指针来确定对象是否是一个类的成员。应该使用class方法来确定对象实例的类。]]></content>
      <categories>
        <category>实用技术</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>KVC/KVO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修正iOS从照相机和相册中获取的图片方向]]></title>
    <url>%2F2016%2F03%2F11%2F2016b%2F%E4%BF%AE%E6%AD%A3iOS%E4%BB%8E%E7%85%A7%E7%9B%B8%E6%9C%BA%E5%92%8C%E7%9B%B8%E5%86%8C%E4%B8%AD%E8%8E%B7%E5%8F%96%E7%9A%84%E5%9B%BE%E7%89%87%E6%96%B9%E5%90%91%2F</url>
    <content type="text"><![CDATA[使用系统相机拍照得到的图片的默认方向有时不是ImageOrientationDown，而是ImageOrientationLeft，在使用的时候会出现图片顺时针偏转90°。使用fixOrientation方法修正这个问题。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576- (UIImage *)fixOrientation&#123; // No-op if the orientation is already correct if (self.imageOrientation == UIImageOrientationUp) return self; // We need to calculate the proper transformation to make the image upright. // We do it in 2 steps: Rotate if Left/Right/Down, and then flip if Mirrored. CGAffineTransform transform = CGAffineTransformIdentity; switch (self.imageOrientation) &#123; case UIImageOrientationDown: case UIImageOrientationDownMirrored: transform = CGAffineTransformTranslate(transform, self.size.width, self.size.height); transform = CGAffineTransformRotate(transform, M_PI); break; case UIImageOrientationLeft: case UIImageOrientationLeftMirrored: transform = CGAffineTransformTranslate(transform, self.size.width, 0); transform = CGAffineTransformRotate(transform, M_PI_2); break; case UIImageOrientationRight: case UIImageOrientationRightMirrored: transform = CGAffineTransformTranslate(transform, 0, self.size.height); transform = CGAffineTransformRotate(transform, -M_PI_2); break; default: break; &#125; switch (self.imageOrientation) &#123; case UIImageOrientationUpMirrored: case UIImageOrientationDownMirrored: transform = CGAffineTransformTranslate(transform, self.size.width, 0); transform = CGAffineTransformScale(transform, -1, 1); break; case UIImageOrientationLeftMirrored: case UIImageOrientationRightMirrored: transform = CGAffineTransformTranslate(transform, self.size.height, 0); transform = CGAffineTransformScale(transform, -1, 1); break; default: break; &#125; // Now we draw the underlying CGImage into a new context, applying the transform // calculated above. CGContextRef ctx = CGBitmapContextCreate(NULL, self.size.width, self.size.height, CGImageGetBitsPerComponent(self.CGImage), 0, CGImageGetColorSpace(self.CGImage), CGImageGetBitmapInfo(self.CGImage)); CGContextConcatCTM(ctx, transform); switch (self.imageOrientation) &#123; case UIImageOrientationLeft: case UIImageOrientationLeftMirrored: case UIImageOrientationRight: case UIImageOrientationRightMirrored: // Grr... CGContextDrawImage(ctx, CGRectMake(0,0,self.size.height,self.size.width), self.CGImage); break; default: CGContextDrawImage(ctx, CGRectMake(0,0,self.size.width,self.size.height), self.CGImage); break; &#125; // And now we just create a new UIImage from the drawing context CGImageRef cgimg = CGBitmapContextCreateImage(ctx); UIImage *img = [UIImage imageWithCGImage:cgimg]; CGContextRelease(ctx); CGImageRelease(cgimg); return img;&#125;]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>实用</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[StoryBoard]]></title>
    <url>%2F2016%2F03%2F10%2F2016b%2FStoryBoard%2F</url>
    <content type="text"><![CDATA[1.UIStoryboard 通过xib 加载控制器的View initWithName:bundle: 如果指定了特定的名称的xib,会去加载指定的xib 如果指定是nil, 判断有没有当前控制器相同的xib,如果有，自动加载跟它相同名称的xib(aTextViewController.xib) r如果没有和它相同名称的xib，自动加载和它相同名称并且是去掉Controller的xib(aTextView.xib) 使用storyboard 界面跳转 使用UIStoryboardSegue 的destinationViewController和sourceViewController进行控制亲间传值 2.loadView 方法 loadView 作用是用来创建控制器的view 什么时候调用，当控制器的view，第一次使用的时候调用 load view的底层u 原理 先判断当前控制器是不是从storyBoard当中加载的，如果是从中加载的控制器，那么它会就会从storyBoard当中加载的控制器的view，设置当前控制器的view 当前控制器是不是从xib当中加载的，如果是从xib当中加载的话，把xib当中指定的view，设置当前控制器的view 如果也不是从xib加载的，会创建空白的view 3.load 方法 程序一运行，就创建对象 load 方法：当类被加载到内存中就会调用 使用shareInstance 禁止不能使用alloc 方法：如果调用，抛出异常 view 的实现原理 1.设置角标，首先设注册用户通知，才能设置提醒值：]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Swift学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 单元测试]]></title>
    <url>%2F2016%2F03%2F09%2F2016b%2FiOS%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[1.单元测试 测试性能，测试消耗时间 相同的代码重复执行10次，统计计算时间，平均时间 测试异步的耗时操作，使用Expection 2.猴子测试 猴子测试不能和UI测试共存 https://github.com/jonathanpenn/ui-auto-monkey]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>实用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[svn常用到操作指令]]></title>
    <url>%2F2016%2F03%2F08%2F2016b%2Fsvn%E5%B8%B8%E7%94%A8%E5%88%B0%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1.显示隐藏的文件夹 打开“终端”，根据自己的版本选择命令 早期的OS X（10.6~10.8）系统可以使用如下两条命令来开始或者关闭系统隐藏文件的显示： 12defaults write com.apple.Finder AppleShowAllFiles Yes &amp;&amp; killall Finder //显示隐藏文件defaults write com.apple.Finder AppleShowAllFiles No &amp;&amp; killall Finder //不显示隐藏文件 当升级到OS X 10.9 Mavericks版本之后，这两条命令需要做一些修改，变成了如下命令： 12defaults write com.apple.finder AppleShowAllFiles Yes &amp;&amp; killall Finder //显示隐藏文件defaults write com.apple.finder AppleShowAllFiles No &amp;&amp; killall Finder //不显示隐藏文件 快捷键： 在 macOS Sierra，我们可以使用快捷键⌘⇧.(Command + Shift + .) 来快速（在 Finder 中）显示和隐藏隐藏文件了。 2.查看 svn 所在文件下的文件状态， svn status / svn st 3.unix 下的命令行 unix 下的命令行 4.svn的客户端命令行 svn checkout 拉取服务器代码创建本地仓库 svn commit 提交到服务器 svn update 拉取服务器代码同步本地/会有本地冲突 svn add 将创建的文件添加到本地版本控制中 svn delete 删除本地文件 svn remove 移除本地文件 svn move 移动本地文件 svn mkdir 创建本地管理新目录 svn revert 撤销之前的修改 svn merge 合并某一个版本的代码 5.svn 常用到操作指令。 svn checkout 拉取服务器代码创建本地仓库 svn commit 提交到服务器 svn add - &gt; svn commit 将新创建的文件 添加到服务器上 svn delete -&gt; svn commit 删除本地文件，同步到服务器上 svn update 拉取服务器代码同步本地/会有本地冲突 // 124881677]]></content>
      <categories>
        <category>实用技术</category>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>实用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断银行卡-识别银行卡所在银行]]></title>
    <url>%2F2015%2F09%2F23%2F2015b%2F%E5%88%A4%E6%96%AD%E9%93%B6%E8%A1%8C%E5%8D%A1-%E8%AF%86%E5%88%AB%E9%93%B6%E8%A1%8C%E5%8D%A1%E6%89%80%E5%9C%A8%E9%93%B6%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[获取bank.infoPlist 根据银行卡号的前6位，或者前8位进行识别 1234567891011121314151617181920212223242526- (NSString *)returnBankName:(NSString*) idCard&#123; if(idCard==nil || idCard.length&lt;16 || idCard.length&gt;19)&#123; _resultLabel.text = @"卡号不合法"; return @""; &#125; NSString *plistPath = [[NSBundle mainBundle] pathForResource:@"bank" ofType:@"plist"]; NSDictionary* resultDic = [NSDictionary dictionaryWithContentsOfFile:plistPath]; NSArray *bankBin = resultDic.allKeys; //6位Bin号 NSString* cardbin_6 = [idCard substringWithRange:NSMakeRange(0, 6)]; //8位Bin号 NSString* cardbin_8 = [idCard substringWithRange:NSMakeRange(0, 8)]; if ([bankBin containsObject:cardbin_6]) &#123; return [resultDic objectForKey:cardbin_6]; &#125;else if ([bankBin containsObject:cardbin_8])&#123; return [resultDic objectForKey:cardbin_8]; &#125;else&#123; _resultLabel.text = @"plist文件中不存在请自行添加对应卡种"; return @""; &#125; return @""; &#125; 在输入的过程中控制4位1控制，使用uitext的代理： 12345678910111213141516171819202122232425262728293031323334-(BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string&#123; NSString *text = [self.textField text]; NSCharacterSet *characterSet = [NSCharacterSet characterSetWithCharactersInString:@"0123456789\b"]; string = [string stringByReplacingOccurrencesOfString:@" " withString:@""]; if ([string rangeOfCharacterFromSet:[characterSet invertedSet]].location != NSNotFound) &#123; return NO; &#125; text = [text stringByReplacingCharactersInRange:range withString:string]; text = [text stringByReplacingOccurrencesOfString:@" " withString:@""]; NSString *newString = @""; while (text.length &gt; 0) &#123; NSString *subString = [text substringToIndex:MIN(text.length, 4)]; newString = [newString stringByAppendingString:subString]; if (subString.length == 4) &#123; newString = [newString stringByAppendingString:@" "]; &#125; text = [text substringFromIndex:MIN(text.length, 4)]; &#125; newString = [newString stringByTrimmingCharactersInSet:[characterSet invertedSet]]; // 限制长度 if (newString.length &gt;= 24) &#123; return NO; &#125; [self.textField setText:newString]; return NO;&#125;]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>实用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实用软件工具]]></title>
    <url>%2F2015%2F09%2F22%2F2015b%2F%E5%AE%9E%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[1.突破百度网盘下载速度现在，使用 Aria2下载 Aria2-不限速全平台下载利器 但是百度网盘账号会被限速 ，冲会员解除正常限制网速 2.Safari + 预览，将网页转化为自定义尺寸 PDF3.清除Xcode 缓存 删除模拟器运行缓存，找到Developer-&gt;Devices,打开后可以看到是哪个项目，自行决定删除 1~/Library/Developer/Xcode/CoreSimulator /Devices 清除 Xcode 的打包数据缓存 1~/Library/Developer/Xcode/Archives 清除 Xcode 支持的真机系统文件 每次连接新的真机，Xcode都会拷贝设备系统 1~/Library/Developer/Xcode/iOS DeviceSupport 删除Xcode运行缓存。不同版本会有不同的缓存，尽量删除不必要的。 Xcode-&gt;DerivedData 路径 123456789101.Xcode证书路径：~/Library/MobileDevice/Provisioning Profiles2.Jenkines共享证书路径：/用户/共享/Jenkins/Library/MobileDevice/Provisioning Profiles3.Xcode编译项目缓存垃圾的目录：~/Library/Developer/Xcode/DerivedData4.Xcode PCH 根文件路径：$(PROJECT_DIR)/$(PROJECT_NAME)/5.Xcode插件路径：~/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins -name 4.表格优化模拟器技巧 1).代码评审 代码评审工具phabricator 评审之后上传SVN 或git 2).awakefromnib 中布局，子视图还没有bounds，取宽度为0 3).图像的优化，设置圆角的优化 模拟器技巧 使用 color Misaligned Images 对齐 如果图片拉伸使用CPU 拉伸图片，如果显示黄色，是拉伸的，需要编程绿色，或者不变色 使用Color Blended Layers 混合 4).模拟器常用性能测试工具 5.表格视图优化 缓存行高，是解决性能的最佳途径， 尽量少计算，所需要的素材是提前计算好，使用ViewModel中计算，再赋值给cell 控件上不要设置圆角半径，所有图像渲染的属性，都要注意 不要动态创建控件，所需要的控件，都要提前准备好，在显示的时候，根据数据隐藏 cell 中的控件曾是越少越好，数量越少越好 离屏渲染 ,需要在CPU和GPU之间快速切换，耗电增加 layer 异步加载，self.layer.drawsAsynchronously = true 栅格化 异步绘制的时候会生成一张独立的图像，滚动的是一张图像，停下来会切换CPU， 12self.layer.shouldRasterize = trueself.layer.rasterizationScale = UIScreen.main().scale 6.使用instrument 工具分析 Leaks 找到引发内存泄漏的起点 Core Animation 测试核心动画屏幕刷新帧率 time Profiler 分析代码的执行时间，找出导致程序变慢原因 Allocation 监测内存使用／分配情况 Zombiles 僵尸对象，（MRC 开发必备）]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>实用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有用的UI组件]]></title>
    <url>%2F2015%2F09%2F22%2F2015b%2F%E6%9C%89%E7%94%A8%E7%9A%84UI%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Xcode 快捷键倒计时闪烁问题可视化编程中—-cell的自适应高度iOS 关闭图片渲染setValue 和setObject 的区别IOS如何让实现国际化的相关配置UITextView的点击链接collecton的长按编辑的代码实现NSAttributedString.h 中属性的定义，key使用openURL实现程序间带参数跳转详解 1.子类父类class/superclass判断 子类调用子类自己的方法，判断如下 子类调用父类的方法，结果如下 2.倒计时闪烁问题 UIButton+countDown.h，点击获取验证码后进行倒计时，效果挺好，但会闪烁， 解决办法:将UIButton的类型由system改为custom就OK。 3.Xcode 快捷键 快捷键 123456789101112131、command 1/2/3/4/5 左侧的不同栏目2、commad + e 搜索当前词 在本文件中搜索 3、command +g 结合上面，选中搜索，然后下一个4、 Command + [ 左缩进 Command + ] 右缩进5、 control +6 搜索本文件的方法显示出方法列表6、command option + j 跳到目录搜索7、command option + [ 当前行上下移动8、command option ＋ Left/Right 折叠、展开当前代码段9、command control + Up/Down .h 和.m 之间的切换10、command control ＋ Left/Right浏览历史的前进后退11、command shift o 文件、方法全局搜索12、command shift ＋f 全局搜索 13、 command shift +J 左侧栏显示当前所在文件 4.Xcode描述文件问题 No matching provisioning profile found: Your build settings specify a provis 解决办法~/Library/MobileDevice/Provisioning Profiles 全部删除，之后重新安装描述文件即可 5.可视化编程中—-cell的自适应高度 可视化编程中—-cell的自适应高度 1234567891011- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath&#123;Joke *joke = self.dataArray[indexPath.row];NSString *content = joke.joke;self.customCell.contentLabel.text = content;self.customCell.bounds = CGRectMake(0, 0, self.view.frame.size.width, self.customCell.frame.size.height);[self.customCell updateConstraintsIfNeeded];[self.customCell layoutIfNeeded];CGFloat height = [self.customCell systemLayoutSizeFittingSize: UILayoutFittingCompressedSize].height + 1;return height;&#125; 6.iOS 关闭图片渲染 在为Button 设置背景图片的时候, 会发现显示的效果和UI给的图片不一样, 往往是把图片显示成为蓝色, 这是因为在新版的iOS中, 会自动对图片渲染.我们只要把图片渲染关掉就OK了 1234567- (UIImage *)imageWithRenderingMode:(UIImageRenderingMode)renderingMode这个方法就是用来设置图片的渲染模式的UIImageRenderingModeAlwaysOriginal这个枚举值是声明这张图片要按照原来的样子显示，不需要渲染成其他颜色UIImage *playImage = [UIImage imageNamed:@"luzhi"];playImage = [playImage imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal];[_playBtn setImage:playImage forState:UIControlStateNormal]; 7.setValue 和setObject 的区别 setObject：forkey：中value是不能够为nil的，不然会报错。 setValue：forKey：中value能够为nil，但是当value为nil的时候，会自动调用removeObject：forKey方法 setValue：forKey：中key的参数只能够是NSString类型，而setObject：forKey：的可以是任何类型 8.IOS如何让实现国际化的相关配置 iOS中国际化需要做相关的配置： 选中应用程序对应的project，然后添加所需要国际化的语言。 新建Localizable.strings文件，作为多语言对应的词典，存储多种语言，点击右侧Localization，勾选国际化对应的语言。 添加一个字段，设置你想要国际化的字段 在English中，添加：SUBMIT_BTN_TITLE = Go; 在Chinese中，添加：SUBMIT_BTN_TITLE = 开始; 9.UITextView的点击链接 UITextView的链接创建一个NSAttributedString然后增加给它增加一个NSLinkAttributeName 属性，见以下： 1234567891011121314NSMutableAttributedString *attributedString = [[NSMutableAttributedString alloc] initWithString:@"This is an example by @marcelofabri_"];[attributedString addAttribute:NSLinkAttributeName value:@"username://marcelofabri_" range:[[attributedString string] rangeOfString:@"@marcelofabri_"]]; NSDictionary *linkAttributes = @&#123;NSForegroundColorAttributeName: [UIColor greenColor], NSUnderlineColorAttributeName: [UIColor lightGrayColor], NSUnderlineStyleAttributeName: @(NSUnderlinePatternSolid)&#125;;textView.linkTextAttributes = linkAttributes; // customizes the appearance of linkstextView.attributedText = attributedString;textView.delegate = self; 这样就可以让链接在文本中显示。然而，你也可以控制当链接被点击的时候会发生什么，实现这个可以使用UITextViewDelegate协议的新的shouldInteractWithURL方法，就像这样： 12345678- (BOOL)textView:(UITextView *)textView shouldInteractWithURL:(NSURL *)URL inRange:(NSRange)characterRange &#123; if ([[URL scheme] isEqualToString:@"username"]) &#123; NSString *username = [URL host]; // do something with this username return NO; &#125; return YES; // let the system open this URL&#125; 10.table下面滑不下去，是table的高度超出了屏幕宽度 高度超过了屏幕宽度，高度设置的不对 12[weakSelf.currentVC.view setFrame:CGRectMake(0, 100, ScreenW, ScreenH-64)]; self.edgesForExtendedLayout = UIRectEdgeNone; //也是个方法，是上方多处一块64时 11.气泡图片中间拉伸 把一张小的图片做背景保持四周不变，拉伸中间，则用如下属性。UIEdgeInsets是拉伸的区域，一般取最中间的一个点 1234UIImage *meBgNor=[UIImage imageNamed:@"chat_send_nor"];UIEdgeInsets edge1=UIEdgeInsetsMake(28, 32, 28, 32);meBgNor=[meBgNor resizableImageWithCapInsets:edge1 resizingMode:UIImageResizingModeStretch];[self.textView setBackgroundImage:meBgNor forState:UIControlStateNormal]; 背景气泡图 1234567891011UIImage *normal;if (message.from == UUMessageFromMe) &#123; normal = [UIImage imageNamed:@"chatto_bg_normal"]; normal = [normal resizableImageWithCapInsets:UIEdgeInsetsMake(35, 10, 10, 22)];&#125;else&#123; normal = [UIImage imageNamed:@"chatfrom_bg_normal"]; normal = [normal resizableImageWithCapInsets:UIEdgeInsetsMake(35, 22, 10, 10)];&#125;[self.btnContent setBackgroundImage:normal forState:UIControlStateNormal];[self.btnContent setBackgroundImage:normal forState:UIControlStateHighlighted]; 12.collecton的长按编辑的代码实现 （1） 对collectionView的处理 123456789101112131415161718192021222324252627282930- (void)handlelongGesture:(UILongPressGestureRecognizer *)longGesture &#123;//判断手势状态switch (longGesture.state) &#123; case UIGestureRecognizerStateBegan: &#123; //判断手势落点位置是否在路径上 NSIndexPath *indexPath = [self.theCollectionView indexPathForItemAtPoint:[longGesture locationInView:self.theCollectionView]]; if (indexPath == nil) &#123; break; &#125; //在路径上则开始移动该路径上的cell [self.theCollectionView beginInteractiveMovementForItemAtIndexPath:indexPath]; &#125; break; case UIGestureRecognizerStateChanged: //移动过程当中随时更新cell位置 [self.theCollectionView updateInteractiveMovementTargetPosition: [longGesture locationInView:self.theCollectionView]]; break; case UIGestureRecognizerStateEnded: //移动结束后关闭cell移动 [self.theCollectionView endInteractiveMovement]; break; default: [self.theCollectionView cancelInteractiveMovement]; break;&#125;&#125; (2) 代理方法能否编辑返回yes, 1234- (BOOL)collectionView:(UICollectionView *)collectionViewcanMoveItemAtIndexPath:(NSIndexPath *)indexPath &#123; return YES;&#125; (3) 对数据源数据的处理： 1234567891011121314151617- (void)collectionView:(UICollectionView *)collectionViewmoveItemAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath &#123;//取出源item数据id objc1 = [_titleMuarray objectAtIndex:sourceIndexPath.row];id objc2 = [_imageNameMuarray objectAtIndex:sourceIndexPath.row];//从资源数组中移除该数据[_titleMuarray removeObject:objc1];[_imageNameMuarray removeObject:objc2];//将数据插入到资源数组中的目标位置上[_titleMuarray insertObject:objc1 atIndex:destinationIndexPath.row];[_imageNameMuarray insertObject:objc2 atIndex:destinationIndexPath.row];WorkStore *workStoreInfomation1 = [WorkStore MR_findFirst];workStoreInfomation1.sortOrder = _titleMuarray;workStoreInfomation1.imageName = _imageNameMuarray;[[NSManagedObjectContext MR_defaultContext] MR_saveToPersistentStoreAndWait];&#125; 13.项目中使用多个storyBoard之间的跳转 使用代码进行2个storyboard之间的跳转： 另外创建的storyboard的名字自己定义，之后在将要跳转的controller中取出storyboard，然后再取出其中需要的controller，进行跳转 123UIStoryboard *secondStroyBoard=[UIStoryboard storyboardWithName:@"Storyboard2" bundle:nil]; UIViewController *test2obj=[secondStroyBoard instantiateViewControllerWithIdentifier:@"test2"];[self.navigationController pushViewController:test2obj animated:NO]; 如何从多个storyboard中取出控制器实例。不用管控制在哪个storyboard文件里，只要 控制器设置identifier为类名就OK。 14.NSAttributedString.h 中属性的定义，key 如何使用NSString在 drawInRect中居中 drewRect属性， withAttributes:参数是属性字典，该字典的key在NSAttributedString.h中获得， 123456789NSMutableParagraphStyle style = [[NSMutableParagraphStyle alloc] init]; [style setAlignment:UITextAlignmentCenter]; style.lineBreakMode =NSLineBreakByCharWrapping;NSDictionary attr = @&#123; NSParagraphStyleAttributeName:style, NSFontAttributeName: [UIFont systemFontOfSize:10], NSForegroundColorAttributeName:[UIColor colorWithHexString:@"333333"]&#125;; NSAttributedString.h 中属性的定义，key 1234567891011121314字符属性字符属性可以应用于 attributed string 的文本中。NSString *const NSFontAttributeName;(字体)NSString *const NSParagraphStyleAttributeName;(段落)NSString *const NSForegroundColorAttributeName;(字体颜色)NSString *const NSBackgroundColorAttributeName;(字体背景色)NSString *const NSLigatureAttributeName;(连字符)NSString *const NSKernAttributeName;(字间距)NSString *const NSStrikethroughStyleAttributeName;(删除线)NSString *const NSUnderlineStyleAttributeName;(下划线)NSString *const NSStrokeColorAttributeName;(边线颜色)NSString *const NSStrokeWidthAttributeName;(边线宽度)NSString *const NSShadowAttributeName;(阴影)(横竖排版)NSString *const NSVerticalGlyphFormAttributeName; 详细解释 123456789101112131415161718192021222324252627282930313233343536常量1&gt; NSFontAttributeName(字体)该属性所对应的值是一个 UIFont 对象。该属性用于改变一段文本的字体。如果不指定该属性，则默认为12-point Helvetica(Neue)。2&gt; NSParagraphStyleAttributeName(段落)该属性所对应的值是一个 NSParagraphStyle 对象。该属性在一段文本上应用多个属性。如果不指定该属性，则默认为 NSParagraphStyle 的defaultParagraphStyle 方法返回的默认段落属性。3&gt; NSForegroundColorAttributeName(字体颜色)该属性所对应的值是一个 UIColor 对象。该属性用于指定一段文本的字体颜色。如果不指定该属性，则默认为黑色。4&gt; NSBackgroundColorAttributeName(字体背景色)该属性所对应的值是一个 UIColor 对象。该属性用于指定一段文本的背景颜色。如果不指定该属性，则默认无背景色。5&gt; NSLigatureAttributeName(连字符)该属性所对应的值是一个 NSNumber 对象(整数)。连体字符是指某些连在一起的字符，它们采用单个的图元符号。0 表示没有连体字符。1 表示使用默认的连体字符。2表示使用所有连体符号。默认值为 1（注意，iOS 不支持值为 2）。6&gt; NSKernAttributeName(字间距)该属性所对应的值是一个 NSNumber 对象(整数)。字母紧排指定了用于调整字距的像素点数。字母紧排的效果依赖于字体。值为 0 表示不使用字母紧排。默认值为0。7&gt; NSStrikethroughStyleAttributeName(删除线)该属性所对应的值是一个 NSNumber 对象(整数)。该值指定是否在文字上加上删除线，该值参考“Underline Style Attributes”。默认值是NSUnderlineStyleNone。8&gt; NSUnderlineStyleAttributeName(下划线)该属性所对应的值是一个 NSNumber 对象(整数)。该值指定是否在文字上加上下划线，该值参考“Underline Style Attributes”。默认值是NSUnderlineStyleNone。9&gt; NSStrokeColorAttributeName(边线颜色)该属性所对应的值是一个 UIColor 对象。如果该属性不指定（默认），则等同于 NSForegroundColorAttributeName。否则，指定为删除线或下划线颜色。更多细节见“Drawing attributedstrings that are both filled and stroked”。10&gt; NSStrokeWidthAttributeName(边线宽度)该属性所对应的值是一个 NSNumber 对象(小数)。该值改变描边宽度（相对于字体size 的百分比）。默认为 0，即不改变。正数只改变描边宽度。负数同时改变文字的描边和填充宽度。例如，对于常见的空心字，这个值通常为3.0。11&gt; NSShadowAttributeName(阴影)该属性所对应的值是一个 NSShadow 对象。默认为 nil。12&gt; NSVerticalGlyphFormAttributeName(横竖排版)该属性所对应的值是一个 NSNumber 对象(整数)。0 表示横排文本。1 表示竖排文本。在 iOS 中，总是使用横排文本，0 以外的值都未定义。 15.清除所有的NSUserDefault 清除所有的NSUserDefault 1234- (void)clearAllUserDefaultsData&#123; NSString *appDomain = [[NSBundle mainBundle] bundleIdentifier]; [[NSUserDefaults standardUserDefaults] removePersistentDomainForName:appDomain];&#125; 16.使用openURL实现程序间带参数跳转详解 (1) target -&gt; info -&gt; url scheme 添加URL (2) 正常跳转 1234567NSURL *url = [NSURL URLWithString:@"B://com.YouXianMing"];if ([[UIApplication sharedApplication] canOpenURL:url])&#123; NSLog(@"跳转并打开"); [[UIApplication sharedApplication] openURL:url];&#125;else&#123; NSLog(@"打开失败");&#125; (3) 带参数跳转 1234567891011// 其他应用的 URL Schemes --&gt; B// 其他应用的 Identifier --&gt; com.xinguan// values? --&gt; 要传递的参数,方便解析NSURL *url = [NSURL URLWithString:\ @"B://com.xinguan/values?username=WT&amp;password=123456&amp;callback=invoking"];if ([[UIApplication sharedApplication] canOpenURL:url])&#123; NSLog(@"跳转并打开"); [[UIApplication sharedApplication] openURL:url];&#125;else&#123; NSLog(@"打开失败");&#125; (4) 接收到参数解析 123456789101112131415161718192021- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation&#123; if ([[url scheme] isEqualToString:@"B"])&#123; if ([[url host] isEqualToString:@"com.xinguan"])&#123; /* query用法 The query string from the URL. If the receiver does not conform to RFC 1808, returns nil. For example, in the URL http://www.example.com/index.php?key1=value1&amp;key2=value2, the query string is key1=value1&amp;key2=value2. */ NSString *query = [url query]; // 分割&amp; NSArray *array = [query componentsSeparatedByString:@"&amp;"]; // 显示数据 NSLog(@"%@", array); &#125; return YES; &#125; return NO;&#125; 17.在view上的window问题 在view上的window问题： 当在一个XIB上添加一个window，拖线出来，默认是显示的，就是不写任何代码，也是在当前窗口上覆盖，影响交互， 先设置hidden，后在makeKeyAndVisible 当取消key window的时候，注意hidden调]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>实用</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题《三》]]></title>
    <url>%2F2015%2F09%2F22%2F2015b%2F%E9%9D%A2%E8%AF%95%E9%A2%983%2F</url>
    <content type="text"><![CDATA[100道面试题1.__weak什么时候用？2.是否使用过coreImage和coreText?如果使用过，说说你的体验3.数据结构、写一个顺序排列4.什么是TCP、DUP等协议？他们分别属于第几层？5.写一个单项链表逆序6.在iPhone中怎么写入C++程序，详细写下来7.写一个快速排序8.autorelease的对象是在什么时候被release的？11.什么是OpenGL?具体使用12.开发过程中应用程序内存泄露了该怎么办13.ios开发中有什么方式支持多继承？（obj-c有多重继承么?不是的话有什么替代方法?）14.从1-n个五序列的数字中排序的算法有哪些，简单代码实现一个并写出时间复杂度15.开启一个其他线程来计算1+1 并且把结果用主线程显示在label上更新UI16.ios7中navigationBar的背景如何设置成透明的吗？需求是这样的：viewController的背景是蓝色的，然后让navigationbar的背景是透明的，就 这样navigationbar也变成蓝色的了18.用预处理指令#define声明一个常数，用以表明1年中有多少秒（忽略闰年问题）19.写一个委托的 interface20.写一个NSString类的实现21.obj-c有私有方法么?私有变量呢22.关键字const有什么含意？修饰类呢?static的作用,用于类呢?还有extern c的作用23.为什么标准头文件都有类似以下的结构？ 12345678910#ifndef __INCvxWorksh #define __INCvxWorksh #ifdef __cplusplus extern "C" &#123; #endif /*...*/ #ifdef __cplusplus &#125; #endif #endif /* __INCvxWorksh */ 25.列举几种进程的同步机制，并比较其优缺点。 26.什么是键-值,键路径是什么 27.c和obj-c如何混用 28.cocoa touch框架 29.自动释放池是什么,如何工作 30.objc优点和objc缺点？ 31.sprintf,strcpy,memcpy使用上有什么要注意的地方 32..http和scoket通信的区别。 35.什么是push。 36.静态链接库 37.fmmpeg框架 38.fmdb框架 39.320框架 40.什么是沙箱模型？哪些操作是属于私有api范畴? 41.你在开发项目中时，用到了哪些数据存储方式，iphone中常见的方式有哪些，各有什么区别？ 43..init和initwithobject区别（语法）？ 44.你连接服务器用的是什么方法，如果请求过程中，网络出了问题这么办？ 47.协议是什么，有什么作用.？ 49.分线程回调主线程方法是什么，有什么作用？ 50.iphone阅读器，如果要读取一个文本文件，请问你是如何处理编码问题的？另外像pdf格式的文件，你如何读取。? 51.你在开发大型项目的时候，如何进行内存泄露检测的? 52.你做iphone开发时候，有哪些传值方式，view和view之间是如何传值的？ 53.让一个物体从界面中的一点运动到另外一点，有哪些方法？ 54.你了解哪些加密方式？ 55.地图定位 56.http网络通信 57.图片浏览 58.对像序列化 59.线程 ？ 123a. 线程的创建和使用规则?b. 主分线程c.线程锁 60.各种 排序算法？61.通信底层原理62.为什么很多内置类如UITableViewController的delegate属性都是assign而不是retain的？ 以下每行代码执行后，person对象的retain count分别是多少？ 1234Person *person = [[Person alloc] init]; count 1[person retain]; [person release];[person release]; 64.在一个对象的方法里面:self.name = “object”;和name ＝”object”有什么不同吗?67.请写出obj-c的内存管理代码68.什么是OOP？69.类变量的@protected, @private,@public, @package声明各有什么含义71.什么是序列化或者Archiving?可以用来作什么？怎么跟copy结合？74.KVO是同步还是异步？notification是同步还是异步？75.ios对象的生命周期？78.为NSString扩展一个方法，方法能判断字符串是否是Url地址（即判断字符串是否以“http://”），放回BOOL值类型 85.写一个简单的Objective C中的类的继承示例86.这段代码的意义，有没有问题 12345-(void) setName : (NSString*)name&#123;[myname release];[name retain];myname = name;&#125; 87.上机题 写一个iphone程序，有2屏，可以通过滑动切换，第二屏有一个webview，读取本地的html文件，Html文件中会加载一个本地xml文件，获取xml文件中的数据内容并显示。（可选：html中加载的js文件） 88.协议？89.TCP、HTTP、UDP90.什么是协议？分几层？91.UIView从出现到销毁的过程92.认证93.drawRect方法什么时候调用94.js和webview如何交互、95.框架phonegap96.地图中怎么计算两点间的曲线距离97.定位不准如何优化98.TCP和DUP的区别这两包的字节内容有啥不同答 ：TCP多了一些纠错码包装，DUP纠错和校验码99.简单的顺序列表100.如何避免json解析出现内存泄露，内存泄露后怎么解决 iOS性能优化技巧 通过静态 Analyze 工具，以及运行时 Profile 工具分析性能瓶颈，并进行性能优化。结合本人在开发中遇到的问题，可以从以下几个方面进行性能优化。 view优化 透明，懒加载，不要使用layoutsubViews，尽量使用drawRect，不要直接调用，使用替代setneedsdisplayinrect,layoutifneeded, UITableView优化 重用cell，透明。复杂的cell使用drawrect, 不要使用cellforrowatinddexpatn,cache尽可能高的东西，包括行高。 缓存优化 缓存，尽量缓存使用率高。但改变比较少的，服务器的相应，图片，计算结果 线程优化 线程，耗时操作放到子线程中。同步使用串行队列，代替同步锁 内存优化 内存优化，使用autoreleasepoll 实现减少 内存峰值。 代码细节优化 图片优化 对图片数据进行decode。在子线程中设置image的大小后，在imageview中使用缩放后的image。原因：由于UIImage的 imageWithData函数是每次画图的时候才将Data解压成ARGB的图像，所以在每次画图的时候，会有一个解压操作，UIImage初始化后仅 仅是把图片加载到内存中，而实际的解码和重采样是在图片需要显示时才进行。 1234567//图片重采样，在子线程中进行CGSize itemSize = CGSizeMake(width, height);//实际要缩放的大小UIGraphicsBeginImageContext(itemSize);CGRect imageRect = CGRectMake(0.0, 0.0, itemSize.width, itemSize.height);[image drawInRect:imageRect];UIImage newImage = UIGraphicsGetImageFromCurrentImageContext(); //重采样后的图片UIGraphicsEndImageContext(); ７、代码的优化，viewappear中不进行耗时操作，关键代码使用c效率更高。]]></content>
      <categories>
        <category>实用技术</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题《二》]]></title>
    <url>%2F2015%2F09%2F21%2F2015b%2F%E9%9D%A2%E8%AF%95%E9%A2%982%2F</url>
    <content type="text"><![CDATA[一个区分度很大的面试题 考察一个面试者基础咋样，基本上问一个 @property 就够了： 1.@property 后面可以有哪些修饰符？ 2.什么情况使用 weak 关键字，相比 assign 有什么不同？ 3.怎么用 copy 关键字？ 4.这个写法会出什么问题： @property (copy) NSMutableArray *array; 5.如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？ 这一套问题区分度比较大，如果上面的问题都能回答正确，可以延伸问更深入点的： @property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的 @protocol 和 category 中如何使用 @property runtime 如何实现 weak 属性 每个人擅长的领域不一样，我们一般会从简历上找自己写擅长的技术聊，假如自己并不是很熟，最好别写出来或扯出来，万一面试官刚好非常精通这里就露馅了。 总结过些面试题，没坚持下去，后来把这些当 checklist，面试的时候实在没话聊的时候做个提醒，语言、框架、运行机制性质的： @property中有哪些属性关键字？ weak属性需要在dealloc中置nil么？ @synthesize和@dynamic分别有什么作用？ ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？ 用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？ @synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？ 在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？ objc中向一个nil对象发送消息将会发生什么？ objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？ 什么时候会报unrecognized selector的异常？ 一个objc对象如何进行内存布局？（考虑有父类的情况） 一个objc对象的isa的指针指向什么？有什么作用？ runtime | runloop runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法） 使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？ objc中的类方法和实例方法有什么本质区别和联系？ _objc_msgForward函数是做什么的，直接调用它将会发生什么？ runtime如何实现weak变量的自动置nil？ 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？ runloop和线程有什么关系？ runloop的mode作用是什么？ 以+ scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？ 猜想runloop内部是如何实现的？ objc使用什么机制管理对象内存？ ARC通过什么方式帮助开发者管理内存？ 不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建） BAD_ACCESS在什么情况下出现？ 苹果是如何实现autoreleasepool的？ 使用block时什么情况会发生引用循环，如何解决？ 在block内如何修改block外部变量？ 使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？ GCD的队列（dispatch_queue_t）分哪两种类型？ 如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图） dispatch_barrier_async的作用是什么？ 苹果为什么要废弃dispatch_get_current_queue？ 以下代码运行结果如何？ 12345678- (void)viewDidLoad&#123; [super viewDidLoad]; NSLog(@"1"); dispatch_sync(dispatch_get_main_queue(),^&#123; NSLog(@"2"); &#125;); NSLog(@"3");&#125; addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？ 如何手动触发一个value的KVO 若一个类有实例变量NSString *_foo，调用setValue:forKey:时，可以以foo还是_foo作为key？ KVC的keyPath中的集合运算符如何使用？ KVC和KVO的keyPath一定是属性么？ 如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？ apple用什么方式实现对一个对象的KVO？ IBOutlet连出来的视图属性为什么可以被设置成weak? IB中User Defined Runtime Attributes如何使用？ 如何调试BAD_ACCESS错误 lldb（gdb）常用的调试命令？ 这些小题可以做为讨论的入口，根据面试者的回答再继续聊下去。其中一些题比较底层，是留给屌屌的面试者或者试探评级用的，一般情况并不是重点的考察内容。 业务能力 毕竟平常的工作内容不是 runtime、runloop，不怎么会用到底层的黑魔法，80% 的时间都是和搭建页面、写业务逻辑、网络请求打交道。要求面试者能够熟练构建 UI，我会找一个面试者做过的页面让他分析下页面结构、约束或者 frame 布局的连法和计算方法；有时也会让面试者说说 UITableView 常用的几个 delegate 和 data source 代理方法，动态 Cell 高度计算什么的；接下来，在手机里随便找一个 App 的页面，让面试者当场说说如果是他写应该用哪些 UI 组件和布局方式等。问几个问题后就能大概了解业务能力了，我们这边重度使用 IB 和 AutoLayout，假如面试者依然使用代码码 UI 也到没关系，有“从良”意愿就很好~ 程序架构和一些设计模式如果面试者自己觉得还不错的话也会聊聊，但跪求别说 Singleton 了，用的越多对水平就越表示怀疑。对设计模式自信的我一般问一个问题，抽象工厂模式在 Cocoa SDK 中哪些类中体现？架构上 MVC 还是 MVVM 还是 MVP 神马的到是可以聊聊各自的见解，反正也没有正确答案，只要别搞的太离谱就行，比如有的人说网络请求和数据库的操作最好放到 UIView 的子类里面干。 网络请求、数据库等各家都有成熟的封装，基本知道咋用就行。除此之外，我们还会顺带的问下除了 iOS 开发外，还会什么其他编程语言、或者熟悉哪种脚本语言和 Terminal 操作等，甚至还问问是如何翻墙- -，相信这些技能都是很重要的。 性格 大家都是写程序的，没啥必要用奇怪的、很难的问题难为对方，更关键的还是性格，和 Team 的风格是不是和的来。一个心态良好的面试者需要有个平常心，不傲娇也不跪舔，表达要正常，经常遇到问一个问题后一两分钟一直处于沉思状态，一句话不说，交流像挤牙膏一样，很是憋屈；还有非常屌屌的，明明不懂仍然强行据理力争，镇得住面试官也罢，撞枪口上就别怪不客气了- - 。决定要不要一个人基本上聊 5 分钟就可以确定了，喜欢水到渠成的感觉，看对眼了挡都挡不住。]]></content>
      <categories>
        <category>实用技术</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有用的开发记录]]></title>
    <url>%2F2015%2F09%2F21%2F2015b%2F%E6%9C%89%E7%94%A8%E7%9A%84%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95%3C1%3E%2F</url>
    <content type="text"><![CDATA[1.字符串GB2312编码 字符串GB2312编码 123NSString *arrr = @"测试";NSStringEncoding gbkEncoding =CFStringConvertEncodingToNSStringEncoding(kCFStringEncodingGB_18030_2000);NSData *adata = [arrr dataUsingEncoding:gbkEncoding]; 2.UIView独占响应事件 一个布尔值,用来标示一个view独占触摸事件. 当把一个view中的exclusiveTouch设置成YES时,会致使这个window屏蔽掉其他的view触发响应事件.默认值是NO. 1_button1.exclusiveTouch = YES; 3.设置导航栏 设置隐藏导航栏 12345678- (void)viewWillAppear:(BOOL)animated &#123;[super viewWillAppear:animated]; [self.navigationController setNavigationBarHidden:YES animated:YES]; &#125; - (void)viewWillDisappear:(BOOL)animated &#123; [super viewWillDisappear:animated]; [self.navigationController setNavigationBarHidden:NO animated:YES];&#125; 设置导航栏为白色： 在plist中设置 View controller-based status bar appearance 11、plist View controller-based status bar appearance 设置为 NO 在appdelegate 代码设置 1[UIApplication sharedApplication].statusBarStyle = UIStatusBarStyleLightContent; 4.OC中block作为函数参数传递 使用枚举 typedef void (^OnFoolCallback)(NSString *name); 定义方法 - (void)productFool:(OnFoolCallback)callback; 123456typedef void (^OnFoolCallback)(NSString *name); - (void)productFool:(OnFoolCallback)callback; [fb productFool:^(NSString *name) &#123; NSLog(@"name = %@", name); &#125;]; 4.collectionView的section刷新的时候有动画会闪一下解决 解决办法：停止动画： 123456[UIView setAnimationsEnabled:NO];[self.homeCollectionView performBatchUpdates:^&#123; [self.homeCollectionView reloadSections:[NSIndexSet indexSetWithIndex:index]];&#125; completion:^(BOOL finished) &#123; [UIView setAnimationsEnabled:YES]; &#125;]; 5.控制数据越界崩溃 数组越界控制 1234567891011121314151617181920+(void)load&#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; SEL safeSel=@selector(safeObjectAtIndex:); SEL unsafeSel=@selector(objectAtIndex:); Class myClass = NSClassFromString(@"__NSArrayI"); Method safeMethod=class_getInstanceMethod (myClass, safeSel); Method unsafeMethod=class_getInstanceMethod (myClass, unsafeSel); Method_exchangeImplementations(unsafeMethod, safeMethod); &#125;);&#125;-(id)safeObjectAtIndex:(NSUInteger)index&#123; if (index&gt;(self.count-1)) &#123; NSAssert(NO, @"beyond the boundary"); return nil; &#125; else&#123; return [self safeObjectAtIndex:index]; &#125;&#125; 6.Pt与Px 相互转换关系 Pt与Px 相互转换关系。Pt＝（Px／96.0)＊72.0 Pixel Point 7.设置声音静音：soundname 推送通知禁止声音 设置声音静音：soundname ，震动也是一个souond：kSystemSoundID_Vibrate 后台的代码设置推送内容 1234PushNotificationPayload payLoad = PushNotificationPayload.fromJSON(message); payLoad.addAlert("iphone推送测试 www.baidu.com"); // 消息内容 payLoad.addBadge(count); // iphone应用图标上小红圈上的数值 payLoad.addSound("default"); // 铃音 默认 2:程序内代码 12345678910111213#import &lt;AudioToolbox/AudioToolbox.h&gt; AudioServicesPlaySystemSound(kSystemSoundID_Vibrate); AudioServicesPlaySystemSound(1007);其中1007是系统声音的编号，其他的可用编号：//音效文件路径 NSString *path = [[NSBundle mainBundle] pathForResource:@"message" ofType:@"wav"]; //组装并播放音效 SystemSoundID soundID; NSURL *filePath = [NSURL fileURLWithPath:path isDirectory:NO]; AudioServicesCreateSystemSoundID((__bridge CFURLRef)filePath, &amp;soundID); AudioServicesPlaySystemSound(soundID); //声音停止 AudioServicesDisposeSystemSoundID(soundID); 8.编辑键盘问题-&gt;键盘下缩 有键盘，点击保存，或者编辑等时候点击键盘下缩，出现如下bug 1“[App] if we're in the real pre-commit handler we can't actually add any new fences due to CA restriction” 解决办法： [self layoutSubviews]; 9.UI View相对位置 获取点击事件的点相对于屏幕的位置 如果点击事件是如下这个方法（将UIEvent当做参数传回来） 1234-(void)expandButtonClicked:(id)sender withEvent:(UIEvent*)event那么点击的位置相对于屏幕的坐标就是：UITouch* touch = [[event touchesForView:btn] anyObject];CGPoint rootViewLocation = [touch locationInView:[FtAppDelegate shareAppDelegate].rootViewCtrl.view]; 如果想知道一个view相对于屏幕或者另外一个view 的坐标，那么可以通过如下的方法得到： 12UIWindow * window=[[[UIApplication sharedApplication] delegate] window];CGRect rect=[bView convertRect: bView.bounds toView:window]; 10.UI View 移除子视图 移除所有子视图，无需循环只需要一句代码 1[view.subviews makeObjectsPerformSelector:@selector(removeFromSuperview)]; 11.虚拟机安装之后隔一段时间不能实用了修复 VirtualBox 打开虚拟机，报如下错误 123456shjyytxnj Implementation of the USB 2.0 controller not found!Because the USB 2.0 controller state is part of the saved VM state, the VM cannot be started. To fix this problem, either install the 'Oracle VM VirtualBox Extension Pack' or disable USB 2.0 support in the VM settings.Note! This error could also mean that an incompatible version of the 'Oracle VM VirtualBox Extension Pack' is installed (VERR_NOT_FOUND). 安装了不兼容版本的“Oracle VM VirtualBox Extension Pack” 1234重新下载 最新版的（1）VirtualBox 5.1.12 platform packages.\（2）VirtualBox 5.1.12 Oracle VM VirtualBox Extension Pack https://www.virtualbox.org/wiki/Downloads找到相匹配的版本和插件 重新札幌 12.设置textField 的placeholder的颜色 设置textField 的placeholder的颜色 12[self.searchtextField setValue:RGB(156, 86, 49) forKeyPath:@"_placeholderLabel.textColor"];[self.searchtextField setValue:[UIFont boldSystemFontOfSize:14] forKeyPath:@"_placeholderLabel.font"]; 13.navbarhiddern ,消失之后的显示隐藏的缺一部分bug, Hidden动画问题 12345678910111213141516171819202122@property (nonatomic, assign) BOOL closeNavBarAnimating;- (void)viewDidLoad&#123; [super viewDidLoad]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(chageBool:) name:@"closeBarAnimationing" object:nil];&#125;-(void)viewWillAppear:(BOOL)animated&#123; [super viewWillAppear:animated]; if (self.closeNavBarAnimating) &#123; animated = NO; &#125; [self.navigationController setNavigationBarHidden:YES animated:animated];｝-(void)viewWillDisappear:(BOOL)animated&#123; [super viewWillDisappear:animated]; [self.navigationController setNavigationBarHidden:NO animated:animated]; self.closeNavBarAnimating = NO; &#125;-(void)chageBool:(id)sedner&#123; self.closeNavBarAnimating = YES; &#125; 14.APP启动GIF动画 UIImageView和UIImage都不支持GIF动画，使用UIWebView 加载GIF启动动画 1234567891011121314151617181920212223242526@interface ViewController ()@property (weak, nonatomic) IBOutlet UIWebView *webViewBG;@property (weak, nonatomic) IBOutlet UIButton *regBtn;@property (weak, nonatomic) IBOutlet UIButton *loginBtn;@end@implementation ViewController - (void)viewDidLoad &#123; [super viewDidLoad]; //初始化UIWebView对象，添加GIF文件 NSString *filePath = [[NSBundle mainBundle] pathForResource:@"bg" ofType:@"gif"]; NSData *gif =[NSData dataWithContentsOfFile:filePath]; [self.webViewBG loadData:gif MIMEType:@"image/gif" textEncodingName:nil baseURL:nil]; self.webViewBG.userInteractionEnabled = NO; //创建一个灰色的蒙版，提升效果（可选） UIView *filter = [[UIView alloc] initWithFrame:self.view.bounds]; filter.backgroundColor = [UIColor blackColor]; filter.alpha = 0.5; [self.view addSubview:filter]; //修改登录按钮和注册按钮的显示层级 [self.view bringSubviewToFront:self.loginBtn]; [self.view bringSubviewToFront:self.regBtn];&#125; 15.QQ聊天气泡样式界面 定义枚举区别是自己还是别人 1234typedef enum&#123; WPMessageTypeMe=0, WPMessageTypeOther=1&#125;WPMessageType; 计算一段文字所占据的宽和高 123CGSize textMaxSize=CGSizeMake(200, MAXFLOAT);NSDictionary *attr1=@&#123;NSFontAttributeName:[UIFont systemFontOfSize:14]&#125;;CGSize textSize=[message.text boundingRectWithSize:textMaxSize options:NSStringDrawingUsesLineFragmentOrigin attributes:attr1 context:nil].size; 把一张小的图片做背景保持四周不变，拉伸中间，则用如下属性。UIEdgeInsets是拉伸的区域，一般取最中间的一个点 1234UIImage *meBgNor=[UIImage imageNamed:@"chat_send_nor"];UIEdgeInsets edge1=UIEdgeInsetsMake(28, 32, 28, 32);meBgNor=[meBgNor resizableImageWithCapInsets:edge1 resizingMode:UIImageResizingModeStretch];[self.textView setBackgroundImage:meBgNor forState:UIControlStateNormal]; 监听键盘的弹出隐藏 12345678910[[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(changeFrame:) name:UIKeyboardDidChangeFrameNotification object:nil];-(void)changeFrame:(NSNotification *)note&#123; self.view.superview.backgroundColor=[UIColor colorWithRed:0.9 green:0.9 blue:0.9 alpha:0.9]; CGFloat duration=[note.userInfo[UIKeyboardAnimationDurationUserInfoKey] doubleValue]; CGFloat keyboardY=[note.userInfo[UIKeyboardFrameEndUserInfoKey] CGRectValue].origin.y; CGFloat screenH=[UIScreen mainScreen].bounds.size.height; [UIView animateWithDuration:duration animations:^&#123; self.view.transform=CGAffineTransformMakeTranslation(0, keyboardY-screenH); &#125;];&#125; 输入框不是键盘的inputView没有键盘的时候也是悬浮在视图上，弹出键盘的时候控制view的frame就行，底部对齐 lable自适应 1label.adjustsFontSizeToFitWidth = YES; 16.使用CAShapeLayer实现一个音量大小动态改变的控件 类似微信的语音 思路，外界轮廓是有圆角的图像类似椭圆，layer是个矩形，maskToBounds 为yes, _dynamicView 表示外部轮廓的View。 _indicateLayer 表示内容动态显示的Layer 12345678910-(void)refreshUIWithVoicePower : (NSInteger)voicePower&#123; CGFloat height = (voicePower)*(CGRectGetHeight(_dynamicView.frame)/TOTAL_NUM); [_indicateLayer removeFromSuperlayer]; _indicateLayer = nil; UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(0, CGRectGetHeight(_dynamicView.frame)-height, CGRectGetWidth(_dynamicView.frame), height) cornerRadius:0]; _indicateLayer = [CAShapeLayer layer]; _indicateLayer.path = path.CGPath; _indicateLayer.fillColor = [UIColor whiteColor].CGColor; [_dynamicView.layer addSublayer:_indicateLayer];&#125; 17.比较UIimageView的image是哪张图片 实现手势引导页根据图片名字的不通切换下一张，最后一张的时候移除UIimageView 根据imageData判断是哪一个图片，也可以为imageView增加tag 12345678NSData *data = UIImagePNGRepresentation(self.guidImageView.image); NSData *data1 = UIImagePNGRepresentation([UIImage imageNamed:@"home_bj_yd1"]); NSData *data2 = UIImagePNGRepresentation([UIImage imageNamed:@"home_bj_yd2"]); NSData *data3 = UIImagePNGRepresentation([UIImage imageNamed:@"home_bj_yd3"]);if ( [data isEqual:data1]) &#123; self.guidImageView.image=[UIImage imageNamed:@"home_bj_yd2"]; &#125; 18.APP开发注意的手机尺寸 启动页 尺寸 引导页尺寸 AppStore商店的介绍图尺寸 12345NSLog(@"name: %@", [[UIDevice currentDevice] name]);NSLog(@"systemName: %@", [[UIDevice currentDevice] systemName]);NSLog(@"systemVersion: %@", [[UIDevice currentDevice] systemVersion]);NSLog(@"model: %@", [[UIDevice currentDevice] model]);NSLog(@"localizedModel: %@", [[UIDevice currentDevice] localizedModel]); 19.点击顶部通知消息报错： 在点击事件中，如果我们不写completionHandler（）这个方法，可能会报一下的错误，希望大家注意下~ 1234Warning: UNUserNotificationCenter delegate received call to -userNotificationCenter:didReceiveNotificationResponse:withCompletionHandler: but the completion handler was never called.2017-01-16 15:00:36.045772 JYYinYongBao[1006:326459] Warning: UNUserNotificationCenter delegate received call to -userNotificationCenter:didReceiveNotificationResponse:withCompletionHandler: but the completion handler was never called. 20.Xcode 文件夹 文件夹拖拽注意点 黄色的文件夹，打包的时候，不会建立目录，主要保存程序文件 素材不允许重名 蓝色的文件夹，打包的时候，会建立目录，可以分目录的存储素材文件 素材可以重名 游戏的场景，background.png 【草地／雪地／高山／坟墓】 手机应用的皮肤，／白天／夜间模式 切记：不能把程序文件放在蓝色文件夹内，程序会暴漏` Bundle： 通常在第三方框架素材 可以按照黄色文件夹的方式拖拽，同时保留目录结构 可以避免文件重名]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>实用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题《一》]]></title>
    <url>%2F2015%2F08%2F21%2F2015b%2F%E9%9D%A2%E8%AF%95%E9%A2%981%2F</url>
    <content type="text"><![CDATA[文章来自转载上面的答案都比较“抽象”，下面是我面试iOS程序员的问题列表（私人珍藏），能准确答对一半以上的人非常少（其实这些问题真的不难）。。有兴趣的可以试试。。 什么是arc？（arc是为了解决什么问题诞生的？） 请解释以下keywords的区别： assign vs weak, block vs weak __block在arc和非arc下含义一样吗？ 使用atomic一定是线程安全的吗？ 描述一个你遇到过的retain cycle例子。(别撒谎，你肯定遇到过) +(void)load; +(void)initialize；有什么用处？ 为什么其他语言里叫函数调用， objective c里则是给对象发消息（或者谈下对runtime的理解） 什么是method swizzling? UIView和CALayer是啥关系？ 如何高性能的给UIImageView加个圆角？（不准说layer.cornerRadius!） 使用drawRect有什么影响？（这个可深可浅，你至少得用过。。） ASIHttpRequest或者SDWebImage里面给UIImageView加载图片的逻辑是什么样的？（把UIImageView放到UITableViewCell里面问更赞） 麻烦你设计个简单的图片内存缓存器（移除策略是一定要说的） 讲讲你用Instrument优化动画性能的经历吧（别问我什么是Instrument） loadView是干嘛用的？ viewWillLayoutSubView你总是知道的。。 GCD里面有哪几种Queue？你自己建立过串行queue吗？背后的线程模型是什么样的？ 用过coredata或者sqlite吗？读写是分线程的吗？遇到过死锁没？咋解决的？ http的post和get啥区别？（区别挺多的，麻烦多说点） 我知道你大学毕业过后就没接触过算法数据结构了，但是请你一定告诉我什么是Binary search tree? search的时间复杂度是多少？我很想知道！ 技术层面： 1、对面向对象的理解，不好也可以写程序，但是写不好大程序2、对内存的理解3、调试的能力4、调优的能力 产品层面： 1、对基本商业模式的了解2、对流行产品和产品流行趋势的了解3、对app store营销基础知识的了解4、对SNS的了 其他技能 1.通用编程技能，例如：一道小算法，数据结构的实现方式，网络，多线程。2.开发语言，例如：语言特性，重新实现语言提供的功能，是否深入研究过这门语言的某部分。3.开发平台，例如：该平台的内部消息，内存，线程等机制。4.工具，例如：调试技巧，是否熟练使用，代码管理工具，项目管理工具，效率工具。5.行业视角，例如：用什么，知道什么。6.其他能力，例如：网络上解决问题的能力，是否有持续学习的意识。 有经验的，1-6都会问到，刚毕业的，只要重点面1和6 你使用过Objective-C的运行时编程（Runtime Programming）么？如果使用过，你用它做了什么？你还能记得你所使用的相关的头文件或者某些方法的名称吗？ 你实现过多线程的Core Data么？NSPersistentStoreCoordinator，NSManagedObjectContext和NSManagedObject中的哪些需要在线程中创建或者传递？你是用什么样的策略来实现的？ Core开头的系列的内容。是否使用过CoreAnimation和CoreGraphics。UI框架和CA，CG框架的联系是什么？分别用CA和CG做过些什么动画或者图像上的内容。（有需要的话还可以涉及Quartz的一些内容） 是否使用过CoreText或者CoreImage等？如果使用过，请谈谈你使用CoreText或者CoreImage的体验。 NSNotification和KVO的区别和用法是什么？什么时候应该使用通知，什么时候应该使用KVO，它们的实现上有什么区别吗？如果用protocol和delegate（或者delegate的Array）来实现类似的功能可能吗？如果可能，会有什么潜在的问题？如果不能，为什么？（虽然protocol和delegate这种东西面试已经面烂了…） 你用过NSOperationQueue么？如果用过或者了解的话，你为什么要使用NSOperationQueue，实现了什么？请描述它和GCD的区别和类似的地方（提示：可以从两者的实现机制和适用范围来描述）。 既然提到GCD，那么问一下在使用GCD以及block时要注意些什么？它们两是一回事儿么？block在ARC中和传统的MRC中的行为和用法有没有什么区别，需要注意些什么？ 您是否做过异步的网络处理和通讯方面的工作？如果有，能具体介绍一些实现策略么？ 对于Objective-C，你认为它最大的优点和最大的不足是什么？对于不足之处，现在有没有可用的方法绕过这些不足来实现需求。如果可以的话，你有没有考虑或者实践过重新实现OC的一些功能，如果有，具体会如何做？ 你实现过一个框架或者库以供别人使用么？如果有，请谈一谈构建框架或者库时候的经验；如果没有，请设想和设计框架的public的API，并指出大概需要如何做、需要注意一些什么方面，来使别人容易地使用你的框架。 申请的空间的内存在哪个区？ new 申请的时候，申请的空间在内存的堆区，（程序动态分配的内存空间） 初始化的时候，如果实例变量是基本类型，此时给初始化的为0，如果是字符串，初始化为null， 实例变量又保存在什么地方？ 实例变量，存放在堆区，指针变量，对象名存放在栈区， 对象方法保存在什么地方？ 对象的方法存放在代码区 首先找到p对应的堆区空间，然后找到－isa指针，在找到指向的代码区，然后到该空间中找方法， 一个类可以创建多个对象。]]></content>
      <categories>
        <category>实用技术</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apple Pay]]></title>
    <url>%2F2015%2F03%2F23%2F2015b%2FApple%20Pay%2F</url>
    <content type="text"><![CDATA[1.介绍： Apple Pay并不是独立的第三方支付服务，相比较支付宝和微信支付，他没有自己的账户，也不参与资金的流动， Apple Pay只是将原有的实体银行卡变成手机上“虚拟的银行卡”。Apple Pay依赖iPhone系统底层的整合,在便捷程度上,非第三方支付能比。和第三方的支付对比：一个是系统级的，一个是应用级的。 iOS 8 中第一次被介绍，支持到iOS9以上的系统 2配置证书： 需要有一个具有ApplePay服务的APPid.以及真机测试的证书和描述文件 创建或者编辑appID的支持Apple pay 编辑Merchant ID 从钥匙串中请求证书 在Xcode 中设置允许Apple pay 3. 在界面中设置pay button PKPaymentButton –我们需要添加一个按钮，进行支付代码的实现 切图可以拉伸，但是不可以变窄！ 这个按钮有三个样式：White; WhiteOutLine; Black 同样具有三个不同类型：Plain; Buy；SetUp 4.上代码 创建button 123456789101112131415#import &lt;PassKit/PassKit.h&gt;// Type : 类型// PKPaymentButtonTypePlain// PKPaymentButtonTypeBuy// PKPaymentButtonTypeSetUp // style : 样式// PKPaymentButtonStyleWhite// PKPaymentButtonStyleWhiteOutline// PKPaymentButtonStyleBlack //以上的样式和类型，大家可以更换下，运行后可以直接查看到效果。在这里就不在解释。 PKPaymentButton * payButton = [PKPaymentButton buttonWithType:PKPaymentButtonTypePlain style:PKPaymentButtonStyleWhiteOutline]; payButton.center = self.view.center; [payButton addTarget:self action:@selector(payAction:) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:payButton]; 开始支付 系统提供了API来判断当前设备是否支持Apple Pay支付的功能。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112 if([PKPaymentAuthorizationViewController canMakePayments])&#123; //设备支持支付 //PKPayment类来创建支付请求 PKPaymentRequest *request = [[PKPaymentRequest alloc] init]; //国家 //HK 香港 CN : 中国大陆 request.countryCode = @"CN"; //人民币 // HKD 港币 CNY : 人民币 USD : 美元 request.currencyCode = @"CNY";// 其他国家以及币种的缩写自行百度 ///由商家支持的支付网络 所支持的卡类型 //此属性限制支付卡，可以支付。 // PKPaymentNetworkAmex : 美国运通 // PKPaymentNetworkChinaUnionPay : 中国银联 // PKPaymentNetworkVisa : Visa卡 // PKPaymentNetworkMasterCard : 万事达信用卡 // PKPaymentNetworkDiscover // PKPaymentNetworkInterac // PKPaymentNetworkPrivateLabel // PKEncryptionSchemeECC_V2 request.supportedNetworks = @[PKPaymentNetworkAmex, PKPaymentNetworkChinaUnionPay, PKPaymentNetworkDiscover, PKPaymentNetworkInterac, PKPaymentNetworkMasterCard, PKPaymentNetworkPrivateLabel, PKPaymentNetworkVisa, PKEncryptionSchemeECC_V2]; // PKMerchantCapability3DS // 美国的一个卡 必须支持 // PKMerchantCapabilityEMV // 欧洲的卡 // PKMerchantCapabilityCredit //信用卡 // PKMerchantCapabilityDebit //借记卡 //商家的支付处理能力 //PKMerchantCapabilityEMV : 他的旗下有三大银行 ： 中国银联 Visa卡 万事达信用卡 //也就是说merchantCapabilities指的支付的银行卡的范围。 request.merchantCapabilities = PKMerchantCapabilityDebit | PKMerchantCapabilityCredit | PKMerchantCapabilityEMV; //merchantIdentifier 要和你在开发者中心生成的id保持一致 request.merchantIdentifier = @"merchant.com.lanou3g.hanshanhuApplePayTest"; //需要的配送信息和账单信息 request.requiredBillingAddressFields = PKAddressFieldAll; request.requiredShippingAddressFields = PKAddressFieldAll; //运输方式 NSDecimalNumber * shippingPrice = [NSDecimalNumber decimalNumberWithString:@"11.0"]; PKShippingMethod *method = [PKShippingMethod summaryItemWithLabel:@"快递公司" amount:shippingPrice]; method.detail = @"24小时送到！"; method.identifier = @"kuaidi"; request.shippingMethods = @[method]; request.shippingType = PKShippingTypeServicePickup; // 2.9 存储额外信息 // 使用applicationData属性来存储一些在你的应用中关于这次支付请求的唯一标识信息，比如一个购物车的标识符。在用户授权支付之后，这个属性的哈希值会出现在这次支付的token中。 request.applicationData = [@"商品ID:123456" dataUsingEncoding:NSUTF8StringEncoding]; //添加物品到支付页 //创建物品并显示，这个对象描述了一个物品和它的价格，数组最后的对象必须是总价格。 //使用PKPaymentSummaryItem来创建商品信息 PKPaymentSummaryItem *widget1 = [PKPaymentSummaryItem summaryItemWithLabel:@"商品1" amount:[NSDecimalNumber decimalNumberWithString:@"20.0"]]; PKPaymentSummaryItem *widget2 = [PKPaymentSummaryItem summaryItemWithLabel:@"商品2" amount:[NSDecimalNumber decimalNumberWithString:@"10.0"]]; PKPaymentSummaryItem *total = [PKPaymentSummaryItem summaryItemWithLabel:@"商品3" amount:[NSDecimalNumber decimalNumberWithString:@"25.0"]]; request.paymentSummaryItems = @[widget1, widget2, total]; // request.paymentSummaryItems = @[widget1]; //显示认证视图 PKPaymentAuthorizationViewController * paymentPane = [[PKPaymentAuthorizationViewController alloc] initWithPaymentRequest:request]; paymentPane.delegate = self; [self presentViewController:paymentPane animated:TRUE completion:nil]; &#125;else&#123; //设备不支持支付 NSLog(@"设备不支持支付"); &#125; ``` - 支付过程中会进行调用 `PKPaymentAuthorizationViewControllerDelegate` ``` swift //这个代理方法指的是支付过程中会进行调用 - (void)paymentAuthorizationViewController:(PKPaymentAuthorizationViewController *)controller didAuthorizePayment:(PKPayment *)payment completion:(void (^)(PKPaymentAuthorizationStatus status))completion &#123; //payment:代表的是一个支付对象， 支付相关的所有信息都在他的身上：1.token. 2.address //completion : 是一个回调的block ，block回调的参数，直接影响到界面结果的展示。 /*PKPaymentAuthorizationStatus 交易状态 PKPaymentAuthorizationStatusSuccess, // 成功交易 PKPaymentAuthorizationStatusFailure // 没有授权交易 PKPaymentAuthorizationStatusInvalidBillingPostalAddress // 拒绝账单地址 PKPaymentAuthorizationStatusInvalidShippingPostalAddress, // 拒绝收货地址 PKPaymentAuthorizationStatusInvalidShippingContact //提供的信息不够 PKPaymentAuthorizationStatusPINRequired // 交易需要指纹输入 PKPaymentAuthorizationStatusPINIncorrect // 输入不正确,重新输入. PKPaymentAuthorizationStatusPINLockout// 输入次数超出 */ PKPaymentToken * token = payment.token; NSLog(@"获取token---%@", token); //获取订单地址 NSString * address = payment.billingContact.postalAddress.city; NSLog(@"获取到地址： %@", address); NSLog(@"验证通过后, 需要开发者继续完成交易"); // 在这个位置， 我们开发人员需要把token值和商品的其他信息如：地址 id 这些 ， 上传到自己公司的服务器。然后公司的服务器和银行的商家接口进行接口的调用，并将接口调用返回的支付结果信息返回到这里。 //根据不同的支付结果状态，让block调用不同的交易状态； //比如说：服务器调用支付结果是成功的， 就让 completion(PKPaymentAuthorizationStatusSuccess); 如果失败 调用 completion(PKPaymentAuthorizationStatusFailure); //如： BOOL isSuccess = YES; if (isSuccess) &#123; completion(PKPaymentAuthorizationStatusSuccess); &#125;else &#123; completion(PKPaymentAuthorizationStatusFailure); &#125; &#125; 授权成功之后或者取消授权之后会调用这个代理方法 1234- (void)paymentAuthorizationViewControllerDidFinish:(PKPaymentAuthorizationViewController *)controller &#123;NSLog(@"取消或者交易完成");[self dismissViewControllerAnimated:YES completion:nil];&#125;]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>实用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[viewController的生命周期]]></title>
    <url>%2F2015%2F03%2F23%2F2015b%2FviewController%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425UIViewController中的view显示步骤--------------------------------------------------------------------------------------------------------进入UIViewController时的情况:viewDidLoadviewWillLayoutSubviewsviewDidLayoutSubviewsviewWillAppearviewWillLayoutSubviewsviewDidLayoutSubviewsviewDidAppear切换了Controller后的情况(比如你在TabbarController中切换了):viewWillDisappearviewDidDisappear再次切换回来后的情况:viewWillLayoutSubviewsviewDidLayoutSubviewsviewWillAppearviewWillLayoutSubviewsviewDidLayoutSubviewsviewDidAppear退入到后台后的情况:无从后台进入程序时的情况:viewWillLayoutSubviewsviewDidLayoutSubviews]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>实用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[支付-微信支付（2）]]></title>
    <url>%2F2015%2F03%2F22%2F2015b%2F%E6%94%AF%E4%BB%98-%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1 微信支付2 ，参与后台接口： 123456789101112131415161718192021222324252627282930313233343536373839404142434445-(void)textWeixin&#123; // 1.拼接请求参数 JYUserInfomation *info=[JYUserInfomation allObjects].firstObject; if (info==nil|| !info.isLoged) &#123; return; &#125; WeakSelf(weakSelf); NSDictionary *dic = @&#123; @"person_id":info.person_id, @"orderId":self.listModel.id, @"token":info.appkey, @"version":AppVersion, &#125;; [LOHttpHelper lo_requestWithType:LO_HttpRequestTypeGet withPath:@"app/pay/weixinPay.htm?" params:dic successOrFail:^(NSDictionary *responseDic, NSError *error) &#123; if (!error) &#123; if ([responseDic[@"status"] integerValue]==1) &#123; NSLog(@"%@",responseDic); NSDictionary *dict=responseDic[@"data"]; NSMutableString *retcode = [dict objectForKey:@"retcode"]; if (retcode.intValue == 0)&#123; NSMutableString *stamp = [dict objectForKey:@"timestamp"]; //调起微信支付 PayReq* req = [[PayReq alloc] init]; req.partnerId = [dict objectForKey:@"partnerid"]; req.prepayId = [dict objectForKey:@"prepayid"]; req.nonceStr = [dict objectForKey:@"noncestr"]; req.timeStamp = stamp.intValue; req.package = [dict objectForKey:@"package"]; req.sign = [dict objectForKey:@"sign"]; [WXApi sendReq:req]; //日志输出 NSLog(@"appid=%@\npartid=%@\nprepayid=%@\nnoncestr=%@\ntimestamp=%ld\npackage=%@\nsign=%@",[dict objectForKey:@"appid"],req.partnerId,req.prepayId,req.nonceStr,(long)req.timeStamp,req.package,req.sign ); &#125; &#125;else&#123; [KVNProgress showErrorWithStatus:responseDic[@"msg"]]; &#125; &#125;else&#123; [KVNProgress showErrorWithStatus:@"请重新再试!"]; &#125; &#125;];&#125; 拼接参数，掉后台接口，接受后台参数： 根据返回的参数，调用微信SDK，进行支付：]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>实用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[支付-微信支付（1）]]></title>
    <url>%2F2015%2F03%2F21%2F2015b%2F%E6%94%AF%E4%BB%98-%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[微信支付 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758- (void)wechatPayClick&#123; NSMutableDictionary *dict = [NSMutableDictionary dictionary]; [dict setObject:WeChatAppID forKey:@"appid"]; [dict setObject:@"税务代理预缴税金" forKey:@"body"]; [dict setObject:WeChatMCH_ID forKey:@"mch_id"]; [dict setObject:[AppMethod getRandomString] forKey:@"nonce_str"]; [dict setObject:WeChatNOTIFY_URL forKey:@"notify_url"]; [dict setObject:@"ZLDD-201703070014" forKey:@"out_trade_no"]; [dict setObject:[AppMethod deviceIPAdress] forKey:@"spbill_create_ip"]; [dict setObject:@"1" forKey:@"total_fee"]; [dict setObject:@"APP" forKey:@"trade_type"]; NSDictionary *params = [AppMethod partnerSignOrder:dict]; NSString *postStr = [params XMLString]; NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://api.mch.weixin.qq.com/pay/unifiedorder"]]; [request setHTTPMethod:@"POST"]; [request addValue: @"text/html,text/plain,text/json" forHTTPHeaderField:@"Content-Type"]; [request setHTTPBody:[postStr dataUsingEncoding:NSUTF8StringEncoding]]; NSURLSession *requestSession = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]]; NSURLSessionDataTask *task = [requestSession dataTaskWithRequest:request completionHandler:^(NSData * _Nullable body , NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; NSLog(@"Response object: %@" , response); NSString *bodyString = [[NSString alloc] initWithData:body encoding:NSUTF8StringEncoding]; // NSDictionary *dic=[bodyString mj_JSONObject]; //打印应答中的body NSLog(@"Response body: %@" , body); NSDictionary *dic= [[XMLDictionaryParser sharedInstance] dictionaryWithData:body]; PayReq* req = [[PayReq alloc] init]; req.partnerId = WeChatMCH_ID; req.prepayId = [dic objectForKey:@"prepay_id"]; req.nonceStr = [dic objectForKey:@"nonce_str"]; req.timeStamp = [[NSString stringWithFormat:@"%.0f",[[NSDate date] timeIntervalSince1970]] intValue]; req.package = @"Sign=WXPay"; NSMutableDictionary *rdict = [NSMutableDictionary dictionary]; [rdict setObject:WeChatAppID forKey:@"appid"]; [rdict setObject:req.partnerId forKey:@"partnerid"]; [rdict setObject:req.prepayId forKey:@"prepayid"]; [rdict setObject:req.nonceStr forKey:@"noncestr"]; [rdict setObject:[NSString stringWithFormat:@"%u",(unsigned int)req.timeStamp] forKey:@"timestamp"]; [rdict setObject:req.package forKey:@"package"]; NSDictionary *result = [AppMethod partnerSignOrder:rdict]; req.sign = [result objectForKey:@"sign"]; [WXApi sendReq:req]; &#125;]; [task resume]; &#125; 拼接参数： 上传接口，获取预下单ID，打开微信，支付]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>实用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[支付-支付宝支付]]></title>
    <url>%2F2015%2F03%2F20%2F2015b%2F%E6%94%AF%E4%BB%98-%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98%2F</url>
    <content type="text"><![CDATA[1.支付宝支付，获取上传的参数加密参数等在后台处理，手机端拿到拼接好的sign，直接调取支付宝SDK： 123456789101112131415161718192021222324252627282930313233343536373839404142JYUserInfomation *info=[JYUserInfomation allObjects].firstObject;if (info==nil|| !info.isLoged) &#123; return;&#125;NSDictionary *dic=@&#123;@"person_id":info.person_id, @"orderId":self.listModel.id, @"token":info.appkey, @"version":AppVersion, &#125;;[LOHttpHelper lo_requestWithType:LO_HttpRequestTypeGet withPath:@"app/pay/getOrderInfo.htm?" params:dic successOrFail:^(NSDictionary *responseDic, NSError *error) &#123; if (!error) &#123; if ([responseDic[@"status"] integerValue]==1) &#123; NSLog(@"%@",responseDic); NSDictionary *data=responseDic[@"data"]; if ([data isKindOfClass:[NSNull class]]) &#123; return ; &#125; NSString *orderInfo=data[@"orderInfo"]; // NOTE: 调用支付结果开始支付 [[AlipaySDK defaultService] payOrder:orderInfo fromScheme:@"JYAliPaySDK" callback:^(NSDictionary *resultDic) &#123; NSLog(@"%@",resultDic); if ([[resultDic objectForKey:@"resultStatus"]intValue] == 9000) &#123; &#125; else if ([[resultDic objectForKey:@"resultStatus"]intValue] == 8000) &#123; //处理中 &#125; else &#123; &#125; &#125;]; &#125;else&#123; [KVNProgress showErrorWithStatus:responseDic[@"msg"]]; &#125; &#125;else&#123; [KVNProgress showErrorWithStatus:@"请重新再试!"]; &#125;&#125;]; 调取后台接口，获取sign 调取支付宝SDK]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>实用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取音视频文件AVMetadata数据]]></title>
    <url>%2F2015%2F03%2F19%2F2015b%2F%E8%8E%B7%E5%8F%96%E9%9F%B3%E8%A7%86%E9%A2%91%E6%96%87%E4%BB%B6AVMetadata%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[做音乐播放器应用有时候需要获取音乐文件的一些数据信息,比如该音乐文件中的封面图片,艺人名,专辑名等,如何获取呢?本人抛砖引玉,写一个获取封面图片的类供大家参考. 创建一个工具类 1234567891011#import &lt;AVFoundation/AVFoundation.h&gt;#warning 需要引入AVFoundation.framework@interface AVMetadataInfo : NSObject/**获取音视频文件的Metadata信息(可以获取到mp3以及m4a的相关信息)*AVMetadataCommonKeyArtwork这个参数是可以换的,换不同的参数可以取得不同的值*[注意]此方法中用到了信号量将异步操作转换成了同步操作,尽量在主线程中使用@param fileURL 文件的URL地址@return 一个包含了相关内容的字典*/+ (NSDictionary *)dataInfoFromFileURL:(NSURL *)fileURL; 实现方法 12345678910111213141516171819202122232425262728293031323334+ (NSDictionary *)dataInfoFromFileURL:(NSURL *)fileURL&#123; // 创建字典 NSMutableDictionary *dic = [NSMutableDictionary dictionary]; // 创建信号量(将异步变成同步) dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); AVAsset *asset = [AVURLAsset URLAssetWithURL:fileURL options:nil]; [asset loadValuesAsynchronouslyForKeys:@[@"commonMetadata"] completionHandler:^&#123; // 发送信号量 dispatch_semaphore_signal(semaphore); &#125;]; // 无限等待 dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); // 获取数据 NSArray *artworks = [AVMetadataItem metadataItemsFromArray:asset.commonMetadata withKey:AVMetadataCommonKeyArtwork keySpace:AVMetadataKeySpaceCommon]; for (AVMetadataItem *item in artworks)&#123; if ([item.keySpace isEqualToString:AVMetadataKeySpaceID3])&#123; NSDictionary *dict = [item.value copyWithZone:nil]; // 获取图片 UIImage *image = [UIImage imageWithData:[dict objectForKey:@"data"]]; [dic setObject:image forKey:@"Artwork"]; &#125; if ([item.keySpace isEqualToString:AVMetadataKeySpaceiTunes])&#123; // 获取图片 UIImage *image = [UIImage imageWithData:[item.value copyWithZone:nil]]; [dic setObject:image forKey:@"Artwork"]; &#125; &#125; return [NSDictionary dictionaryWithDictionary:dic];&#125;]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>实用</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIsearchViewControl]]></title>
    <url>%2F2015%2F03%2F18%2F2015b%2FUIsearchViewControl%2F</url>
    <content type="text"><![CDATA[创建UItableViewVC UISearchController alloc init ResultsController 一个tableVC，搜索到的数据源呈现在tableVC 继承UITableViewController .h文件 12@interface TestTableViewController : UITableViewController@end 继承UITableViewController .m文件 12345678910111213141516171819@interface TestTableViewController ()&lt;UISearchResultsUpdating, UISearchBarDelegate&gt;@property (nonatomic, strong) UISearchController *searchController;@property (nonatomic, strong) NSMutableArray *searchResults; // Filtered search results@property (nonatomic, strong) NSArray *products;@end@implementation TestTableViewController- (void)viewDidLoad&#123; [super viewDidLoad]; self.title = @"全部品牌"; self.products = [Product allProducts]; TestResultTableViewController *result = [[TestResultTableViewController alloc] init]; result.view.frame = CGRectMake(0, 0, [UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height); self.searchController = [[UISearchController alloc] initWithSearchResultsController:result]; self.searchController.searchResultsUpdater = self; self.searchController.searchBar.placeholder = @"搜索品牌"; self.searchController.searchBar.frame = CGRectMake(self.searchController.searchBar.frame.origin.x, self.searchController.searchBar.frame.origin.y, self.searchController.searchBar.frame.size.width, 44.0); self.tableView.tableHeaderView = self.searchController.searchBar; self.definesPresentationContext = YES;&#125; UISearchResultsUpdating UISearchBarDelegate 的代理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#pragma mark - UISearchResultsUpdating- (void)updateSearchResultsForSearchController:(UISearchController *)searchController&#123; NSString *searchString = [self.searchController.searchBar text]; NSString *scope = nil; NSInteger selectedScopeButtonIndex = [self.searchController.searchBar selectedScopeButtonIndex]; if (selectedScopeButtonIndex &gt; 0) &#123; scope = [[Product deviceTypeNames] objectAtIndex:(selectedScopeButtonIndex - 1)]; &#125; [self updateFilteredContentForProductName:searchString type:scope]; if (self.searchController.searchResultsController) &#123; TestResultTableViewController *vc = (TestResultTableViewController *)self.searchController.searchResultsController; vc.searchResults = self.searchResults; [vc.tableView reloadData]; &#125;&#125;#pragma mark - Content Filtering- (void)updateFilteredContentForProductName:(NSString *)productName type:(NSString *)typeName&#123; if ((productName == nil) || [productName length] == 0) &#123; if (typeName == nil) &#123; self.searchResults = [self.products mutableCopy]; &#125; else &#123; NSMutableArray *searchResults = [[NSMutableArray alloc] init]; for (Product *product in self.products) &#123; if ([product.type isEqualToString:typeName]) &#123; [searchResults addObject:product]; &#125; &#125; self.searchResults = searchResults; &#125; return; &#125; [self.searchResults removeAllObjects]; for (Product *product in self.products) &#123; if ((typeName == nil) || [product.type isEqualToString:typeName]) &#123; NSUInteger searchOptions = NSCaseInsensitiveSearch | NSDiacriticInsensitiveSearch; NSRange productNameRange = NSMakeRange(0, product.name.length); NSRange foundRange = [product.name rangeOfString:productName options:searchOptions range:productNameRange]; if (foundRange.length &gt; 0) &#123; [self.searchResults addObject:product]; &#125; &#125; &#125;&#125;#pragma mark - UISearchBarDelegate- (void)searchBar:(UISearchBar *)searchBar selectedScopeButtonIndexDidChange:(NSInteger)selectedScope&#123; [self updateSearchResultsForSearchController:self.searchController];&#125; 代码]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>实用</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MJRefreshGifHeader设置刷新动画]]></title>
    <url>%2F2015%2F03%2F17%2F2015b%2FMJRefreshGifHeader%E8%AE%BE%E7%BD%AE%E5%88%B7%E6%96%B0%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[设置MJRefreshGifHeader 的子类，重写prepare 方法。 interface12@interface CLRefreshHeaderCLRefreshHeader : MJRefreshGifHeaderMJRefreshGifHeader@end prepare() 12345678910111213141516171819-(void)prepare&#123; [super prepare]; // 设置普通状态的动画图片 NSMutableArray *idleImages = [NSMutableArray array]; for (NSUInteger i = 1; i&lt;=60; i++) &#123; UIImage *image = [UIImage imageNamed:@"icon_refresh_1"]; [idleImages addObject:image]; &#125; [self setImages:idleImages forState:MJRefreshStateIdle]; // 设置即将刷新状态的动画图片（一松开就会刷新的状态） NSMutableArray *refreshingImages = [NSMutableArray array]; for (NSUInteger i = 1; i&lt;=7; i++) &#123; UIImage *image = [UIImage imageNamed:[NSString stringWithFormat:@"icon_refresh_%zd", i]]; [refreshingImages addObject:image]; &#125; [self setImages:refreshingImages forState:MJRefreshStatePulling]; // 设置正在刷新状态的动画图片 [self setImages:refreshingImages forState:MJRefreshStateRefreshing];&#125; 设置tableView的header 刷新方法 1self.mTableView.header = [CLRefreshHeader headerWithRefreshingTarget:self refreshingAction:@selector(loadNewData)];]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>实用</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CAShapeLayer]]></title>
    <url>%2F2015%2F03%2F16%2F2015b%2FCAShapeLayer%2F</url>
    <content type="text"><![CDATA[CAShapeLayer 和 CALayer 的区别 普通CALayer在被初始化时是需要给一个frame值的,这个frame值一般都与给定view的bounds值一致,它本身是有形状的,而且是矩形. CAShapeLayer在初始化时也需要给一个frame值,但是,它本身没有形状,它的形状来源于你给定的一个path,然后它去取CGPath值,它与CALayer有着很大的区别 使用UIBezierPath绘制不规则曲线1 12345678910111213141516// 获取pathUIBezierPath *aPath = [UIBezierPath bezierPath];// 设定起始点[aPath moveToPoint:CGPointMake(0.0f, 0.0f)];// 添加一个不规则点[aPath addCurveToPoint:CGPointMake(100.f, 100.f) controlPoint1:CGPointMake(50.f, 0.f) // 开始点 controlPoint2:CGPointMake(0.f, 50.f)]; // 结束点// 添加一个点[aPath addLineToPoint:CGPointMake(0.0f, 100.f)];// 闭合path[aPath closePath]; 使用UIBezierPath绘制不规则曲线2 123456789101112131415// 获取pathUIBezierPath *aPath = [UIBezierPath bezierPath];// 设定起始点[aPath moveToPoint:CGPointMake(0.0f, 0.0f)];// 添加一个不规则点[aPath addQuadCurveToPoint:CGPointMake(100.f, 100.f) controlPoint:CGPointMake(0.f, 90.f)]; // 控制点// 添加一个点[aPath addLineToPoint:CGPointMake(0.0f, 100.f)];// 闭合path[aPath closePath];]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>实用</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Predicate]]></title>
    <url>%2F2015%2F03%2F15%2F2015b%2FPredicate%2F</url>
    <content type="text"><![CDATA[谓词： NSPredicate 1.比较操作 2.字符串常规操作 3.范围 4.通配符 5.逻辑运算符 6.正则表达式 判断是不是字母，判断是不是数字，判断是是不是字母和数字 123456789101112131415161718// If my string contains ony letters- (BOOL)containsOnlyLetters&#123; NSCharacterSet *letterCharacterset = [[NSCharacterSet letterCharacterSet] invertedSet]; return ([self rangeOfCharacterFromSet:letterCharacterset].location == NSNotFound);&#125;// If my string contains only numbers- (BOOL)containsOnlyNumbers&#123; NSCharacterSet *numbersCharacterSet = [[NSCharacterSet characterSetWithCharactersInString:@"0123456789"] invertedSet]; return ([self rangeOfCharacterFromSet:numbersCharacterSet].location == NSNotFound);&#125;// If my string contains letters and numbers- (BOOL)containsOnlyNumbersAndLetters&#123; NSCharacterSet *numAndLetterCharSet = [[NSCharacterSet alphanumericCharacterSet] invertedSet]; return ([self rangeOfCharacterFromSet:numAndLetterCharSet].location == NSNotFound);&#125;]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>实用</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARC下的block导致的循环引用问题解析]]></title>
    <url>%2F2015%2F03%2F14%2F2015b%2FARC%E4%B8%8B%E7%9A%84block%E5%AF%BC%E8%87%B4%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1.在ARC下面使用block,无论怎样,你都需要注意这几点: 外部对象进入block,请使用__weak修饰后再进入到block中 不要在block中初始化对象,请在block的外面初始化对象后再进入到block中去 无论该block是不是copy的,请都当做copy的block来处理 传入到堆区block中的对象会被强引用 2.Block的类型与内存管理 据Block在内存中的位置分为三种类型NSGlobalBlock，NSStackBlock, NSMallocBlock。 NSGlobalBlock：类似函数，位于text段； NSStackBlock：位于栈内存，函数返回后Block将无效； NSMallocBlock：位于堆内存。 此处我们可以得知,在处理对象时,block会malloc的. :这种block会导致_model对象泄露吗? 问:方法中的block是怎么回事呢? :MRC中的__block与ARC中的__weak有啥联系? 在MRC中, __block 可以让一个变量在 block 中进行修改而不会被这个 block retain. 在ARC中, __weak 才能让一个变量在 block 中不被这个block强引用. __block是在MRC中使用的. __weak是在ARC中使用的.]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>实用</tag>
      </tags>
  </entry>
</search>
