<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2019年总结]]></title>
    <url>%2F2019%2F12%2F30%2FiOS%2F2019%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[2019再来过1你的一年是活了365天，还是活了1天，重复了364遍？ 前言 其实每一年的年底，都有一次总结的过程，终归如同年初定下目标一样，到了年底终归留下遗憾。 2019，回想年初到年末，觉得很近又很远。很近，觉得年初还像在昨天，很远，匆匆忙忙一年又过去了。自从长大之后就再也没有以前那种时间过的很慢的错觉，每天，每周都感到时间飞逝，一年也再也没有以前那种很遥远的感觉。弹指瞬间，光阴匆匆而过。也许是我们长大了，也许是我们顿悟了。总感觉时间很快，但确无能为力。 过去1、工作 2018入职之后，做了一段Swift项目之后，从iOS开发者 转为Web开发;但是2018年底开始迷茫，一直很矛盾，没有方向，什么都想学，什么都不想学。自己的方向究竟在哪里，最后确定知道自己的目标和方向，2019年跟领导提出转岗，回到移动端开发 3-4月份，2个月的时间，不断的充实自己,进入快充状态，学习Weex/Java/Android；终于在4月底把项目接下来，谢谢毛同学耐心交接。 公司搬的远了些，上下班通勤3小时。这珍贵的3个小时，应该能做些事情； 0725，0831，0931，1021，1103，1131，1217，0103月初-月末-月初。。。月版本/周版本更新迭代… 2、学习 百度脑图计划的2019年的学习目标，果真大多没有完成。 1234567892019年知识付费买了不少；书籍：Flutter，JS开发进阶，CSS世界极客时间课程：重学前端；iOS开发高手；一些付费视频；iOS逆向/底层；openGL/Flutter；李明杰Swift底层原理；付费音频：喜马拉雅王斌； 在这一年里： 12345678Vue + Weex ; Java + Android ; React + ReactNativeHTML /CSS 和H5适配从原生去重新学习 JSSwift底层原SwiftUIiOS开发高手；重学前端iOS开发逆向 底层原理持续更新博客笔记； 3、生活 持续增肥中，管住嘴，迈开腿。 断断续续的减肥失败，Keep不只为了健康，是为了保命； ![IMG_6347](/images/IMG_6347.png) 脚崴了，最少3-6个月不能跑步；只是可惜了媳妇给加的新设备AirPods+ Watch；原先计划坚持跑步 减下些脂肪； 2019年是折腾的一年，去了N次医院，感谢媳妇一直陪着； 2019年只回了一1次老家，很想家； 4、经济 有种后悔 想从头来过2019。 年初2019年2月初做的计划，很保守的，如果按照纪律配置，收益率应该在30% 未来 我们应该放眼于未来，而不是纠结于过去。过去已去，未来将至。 心中有太多的计划，贪心总想实现。但是只能一一达成。希望在明年可以完成 现在所定的目标。而不是到了明年的这个时候又是一年的遗憾。 学习： 学习Flutter 补充一下小程序 深入学习RN+Weex 原理 深入学习底层逆向 WWDC2019； 工作 努力工作；升职加薪；养家糊口 生活 照顾好家庭； keep;减肥;(keep,晨跑，冥想) 经济 2020年做好配置 资产翻倍]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编学习1]]></title>
    <url>%2F2019%2F04%2F01%2FiOS%2F%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A01%2F</url>
    <content type="text"><![CDATA[汇编 计算机基础 计算机原理；数据结构；汇编； 首选官方；英文；验证； 编程语言验证知识；代码本质；破解；外挂； 代码本质挖掘； 举例分析 sizeof本质 sizeof(int) 不是函数，是编译器特性，直接替换为4； 汇编的函数，是调用call a++;++a的本质区别； if-else 和switch的比较，谁更快 程序的内存布局 多态的实现原理 软件/程序的执行过程 硬盘 -&gt; 内存 -&gt; CPU CPU 寄存器 信息存储 运算器 信息处理 控制器 控制其他器件进行工作 1 + 1 机器语言0 / 1 汇编语言 符号 move eax 1, add eax 1 高级语言 int a = 1 ; a + 1 编译 / 反编译 1对1 汇编语言 转换不了高级语言；结构体 数组等；可以转化为伪代码，只是供能读 123456789101112131415161718C++ :cout &lt;&lt; "hello" &lt;&lt; endljava:System.out.println('hello')php:&lt;?phpecho "hello"js:conslo.log('hello')1编译型 c / oc / c++ / swift2.脚本 Pyhon/js/php3.编译型 依赖虚拟机 javac++ 轻易反汇编 汇编02 代码执行效率分析 if-else / switch 谁的效率高 汇编代码的条数；执行多少条机器指令 代码地址 是连续的， 1234567- move dwrod ptr[no],4 // int no = 4- cmp dwrod ptr[no],1 // compare if (no== 1)- jne main + 44(0171914h) // jump not equal 跳转到代码地址是1914的地址- push offset string 'no is 1'- call _printf(017104)- add esp,4 栈平衡- jmp 无条件跳转 switch 先计算 再跳转 ，7条指令 已空间换时间；消耗更多的内存，节省时间；多开辟内存进行计算； 1234567891011121314151617181920212223242526272829303132333435363738mov a = 6mov eax = amov c = eaxmov ecx = csub ecx ,1 // 减1mov d = ecx // = 5cmp 4 与 d比较 ja mov edx = d // =5 jmp dword ptr [edx*4 + 11719F0]十进制的 5* 4 = 20 加上十六进制的11719F0,得到16进制的地址，0x011719FC去内存中找内存地址 中存储的内存地址 aa 19 17 01 大小端反转，存储的内存地址是011719aajpm [0x011719FC] = jpm 011719aajpm [(no-1) * 4 + 011719F0]switch(no) &#123;&#125;下面是一项存储在一个内存地址中，内存指向真实的代码地址 ；一次性的加载所有的枚举项代码块，加载在内存中；011719F0 -&gt; 0117197d011719F4011719F8011719FC01171A00乘以4 是4个字节；后面的加时各项地址数组的第一个sub ecx ,1 // 减1sub ecx ,x // 减去最小枚举值的值Acase 中的值 最小值A，最大值Bcase判断的值是M差额 M - （B - A）需要判断是否在区间中最小值A，最大值B linux unix 汇编格式是AT&amp;T格式 Windows 汇编是Intel格式 ARM64 是CPU架构 有对应的ARM 汇编 汇编03switch如何计算 7条指令 少量条件 没有优化，还是一样的效率；多条件 进行了优化 跨度小，判断的省略值多 1234567switch 5 case 1case 4case 8将最大值最小枚举值中间项 都存储在内存中，没有case 的2，3，6，7 和default 存放的是一样的地址 如果 switch 中值 很大，超出了枚举值范围，会对区间判断 （5-1）月 （8 -1）比较 (M - A ) 和 (B - A) 比较起来看范围，不在范围内 直接default cmp dword ptr [ebp-0DCh],5 进行比较 ja $LN7 + OFh (0D44529h) 如果大于，就进行跳转到default内存地址 跨度比较大 有一块地址 存放需要判断的值（M-A）+ 一块内存地址 movzx eax, byte ptr [edx + 1359522Ch]; 将里面的值取出来存放到eax中，执行下一步；byte 一个字节；若edx 是个8 ，取出04，相当于 movzx eax,04 从 0x1359522c开始 存放了所有的枚举项 各对应的 内存存放偏移； 1234500 04 01 0404 04 04 0204 04 04 0404 04 04 0404 03 cc cc jmp dword ptr [eax*4 + 1396218h]; 根据便宜的值计算真是存放枚举项代码的内存地址 0x1396218h 开始 是枚举项，若case只有5个，就存放5块，不是上面的多有的值都开放内存，用一个小子节，存放偏移量/偏移量 如果跨度 很大，枚举值也很大，switch 10000，case1，case8，case 10000； 这样 和if是一样的 没有进行优化 汇编04判断 a++ 和 ++a 的 a++ 先使用，再加一 ++a,先加一 再使用 123456789101112131415161718192021222324252627282930a++ = 4;++a = 4;int a = 5int b = ++a + 2汇编： 先a + 1，再赋值给a, 之后再+ 2，再赋值给beax ecx 寄存器mov dword ptr [a],5mov eax,dword ptr [a]add eax ,1mov dword ptr [a],eaxmov ecx,dword ptr [a]add ecx, 2mov dword pr [b],ecxint a = 5int b = a++ + 2汇编：将a赋值eax,执行 + 2 之后，再赋值给b; 之后a 赋值给ecx,ecx+1 ecx赋值给a mov dword ptr [a], 5mov eax, dword ptr [a]add eax,2mov dword ptr [b],eaxmov ecx,dword pt[a]add ecx,1mov dword ptr[a],ecx 汇编05. 构造函数 构造器 错误的 默认情况下，编译器会为每一个类生成空的无参数的构造函数 只有在某些特定的情况下，编译器才会成为类生成空的无参数的构造函数， 成员变量在声明的同时进行了初始化 有定义的虚函数 虚继承了其他类 包含了对象类型的成员，且这个成员有构造函数 父类有构造函数 需要做一些额外操作的时候，比比如内存，函数调用，编译器一般 成员变量在声明的同时进行了初始化 包含了对象类型的成员，且这个成员有构造函数 父类有构造函数 汇编06 函数的内存布局 调用一个函数，会开辟一段栈空间给函数 寄存器 esp ebp 栈指针寄存器 ；esp 标志栈顶；ebp标识栈底 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162text(1,2)汇编： (1)栈 有高内存地址 压入低内存地址(2) push 2,押入栈，内存esp指向 - 4,向上移动；(3) 执行call 之后，将下一个指令的内存地址压栈 占四个字节(4) add esp ,8 栈顶指针下移，内存地址加8，回复栈平衡 push 2push 1call text1(0D710E1h)add esp, 8void text1(int v1,int v2) &#123;&#125;函数内的汇编：(1)将ebp 的地址入栈(2)移动ebp esp 相同位置(3)将esp地址减少一定的值， 此时 ebp - esp 中间就是函数text1的栈空间； .....函数执行完成(4)push ebx esi edi 保护现场，从esp开始 入栈(5) add esp,0c0h 是将esp 下移，内存地址变大，(6)此时出栈 esp 和ebp 执行同一地方(7) pop ebp ：将栈顶指向的值，赋值给ebp; pop 了 esp下降一个字节，等于 + 4，指针下移(8) ret ;函数返回 将栈顶地址pop 出来，并指向这个地址，pop 了一次，地址 + 4 ，指针下移(9) 执行了上面的 add esp，8; 8 = 入栈的参数个数2 * 4；push ebp move ebp ,esp sub esp,0C0hpush ebxpush esipush edi...pop edipop esipop ebxadd esp,0C0hmov esp, ebp pop ebp void text2（int v1, int v2）&#123; int a = v1 + 1 int b = v2 + 2&#125;汇编：(1) 执行 int a = v1 + 1 之前 此时ebp 栈底 指向发的是text2函数内存块的开始位置 的上一个位置；ebp + 8 是入参数的位置，寄存器操作➕1，之后赋值给ebp - 8,存储在函数内存块中。mov eax,dword ptr [ebp + 8]add eax ,1mov dword ptr [ebp - 8],eaxmov eax, wdord ptr [ebp + 0Ch]add eax,2move wdord ptr [ebp + 0Ch],eax 重签名 framework 注入 runtime class_getInstanceMethod method_exchangeImplementations() fishHook 实用动态修改链接mach-o文件的工具，修改二进制C语言是静态重新修改符号。自己写的C函数是修改不了的。123456789101112131415import "fishhook.h"sruct rebinding = nslognslog.name= "nslog"nslog.replaced = (void*)$sys_nslog;nslog.replacement = myNSlog;struce rebinding rebs[1] = &#123;nslog&#125;;rebind_symbols(rebs,1);staic void(*sys_nslog)(NSString * format,...); void myNSlog(NSString * format)&#123; format = [format stringByAppendingString:@"hoolked"]; sys_nslog(format)&#125;]]></content>
      <categories>
        <category>iOS</category>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift-xmg23]]></title>
    <url>%2F2019%2F03%2F25%2FiOS%2Fswift-xmg23%2F</url>
    <content type="text"><![CDATA[Swift标准库源码分析Swift源码简介 Swift于2015年正式开源，github地址: https://github.com/apple/swift 几个可能会经常看的目录 docs:一些文档 stdlib:Swift源码 lib:C++源码 include:C++头文件 标准库源码位置 https://github.com/apple/swift/tree/master/stdlib/public/core Array分析 map、filter https://github.com/apple/swift/blob/master/stdlib/public/core/Sequence.swift flatMap、compactMap、reduce https://github.com/apple/swift/blob/master/stdlib/public/core/SequenceAlgorithms.swift Substring分析 append、lowercased、uppercased https://github.com/apple/swift/blob/master/stdlib/public/core/Substring.swift Optional分析 map、flatMap、==、?? https://github.com/apple/swift/blob/master/stdlib/public/core/Optional.swift Metadata分析 文档: https://github.com/apple/swift/blob/master/docs/ABI/TypeMetadata.rst 其他参考 phttps://github.com/apple/swift/blob/master/include/swift/ABI/Metadata.h https://github.com/apple/swift/blob/master/include/swift/ABI/MetadataKind.def https://github.com/apple/swift/blob/master/include/swift/ABI/MetadataValues.h https://github.com/apple/swift/blob/master/include/swift/Reflection/Records.h 反射 反射是编程语言中一项强大的能力，比如Java语言的反射机制 对于任意一个类型，都能够动态获取这个类的所有属性和方法信息 对于任意一个实例，都能够动态调用它的任意方法和属性 Swift的反射机制目前还比较弱，通过 Mirror 类型来提供简单的反射功能 123456789101112131415struct Person &#123; var age: Int = 0 var name: String = ""&#125;let mirror = Mirror(reflecting: Person(age: 10, name: "Jack")) print(mirror.displayStyle!) // structprint(mirror.subjectType) // Personprint(mirror.superclassMirror as Any) // nil// age 10// name Jackfor case let (label?, value) in mirror.children &#123; print(label, value)&#125; 项目相关常用Swift第三方库 网络请求: https://github.com/Alamofire/Alamofire 图片下载: https://github.com/onevcat/Kingfisher JSON访问: https://github.com/SwiftyJSON/SwiftyJSON JSON-Model转换:https://github.com/kakaopensource/KakaJSON Kingfisher注意点 Kingfisher默认不支持WebP格式的图片，需要额外安装KingfisherWebP pod ‘KingfisherWebP’ 123iconView.kf.setImage(with: URL(string: user.thumb), options: [.processor(WebPProcessor.default), .cacheSerializer(WebPSerializer.default)])]]></content>
      <categories>
        <category>iOS</category>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift-xmg22]]></title>
    <url>%2F2019%2F03%2F24%2FiOS%2Fswift-xmg22%2F</url>
    <content type="text"><![CDATA[函数式编程Array的常见操作 常见的高阶函数 map/flatmap/reduce ;本质还是for循环 arr.compactMap 非空值 reduce 累加累减/累计操作。 12345678910111213141516171819202122232425262728293031var arr = [1, 2, 3, 4]var arr2 = arr.map &#123; $0 * 2 &#125; // [2, 4, 6, 8]var arr3 = arr.filter &#123; $0 % 2 == 0 &#125; // [2, 4] var arr4 = arr.reduce(0) &#123; $0 + $1 &#125; // 10var arr5 = arr.reduce(0, +) // 10func double(_ i: Int) -&gt; Int &#123; i * 2 &#125; var arr = [1, 2, 3, 4]// [2, 4, 6, 8] print(arr.map(double))var arr = [1, 2, 3]// [[1], [2, 2], [3, 3, 3]]var arr2 = arr.map &#123; Array.init(repeating: $0, count: $0) &#125;// [1, 2, 2, 3, 3, 3]var arr3 = arr.flatMap &#123; Array.init(repeating: $0, count: $0) &#125;var arr = ["123", "test", "jack", "-30"] // [Optional(123), nil, nil, Optional(-30)] var arr2 = arr.map &#123; Int($0) &#125;// [123, -30]var arr3 = arr.compactMap &#123; Int($0) &#125; // 使用reduce实现map、filter的功能var arr = [1, 2, 3, 4]// [2, 4, 6, 8]print(arr.map &#123; $0 * 2 &#125;) print(arr.reduce([]) &#123; $0 + [$1 * 2] &#125;)// [2, 4]print(arr.filter &#123; $0 % 2 == 0 &#125;) print(arr.reduce([]) &#123; $1 % 2 == 0 ? $0 + [$1] : $0 &#125;) lazy的优化 Array.lay.map 不是每次都遍历全部，只取需要的index 1234567891011121314151617181920let arr = [1, 2, 3]let result = arr.lazy.map &#123; (i: Int) -&gt; Int in print("mapping \(i)") return i * 2&#125;print("begin-----")print("mapped", result[0])print("mapped", result[1])print("mapped", result[2])print("end----")// print:begin-----mapping 1mapped 2mapping 2mapped 4mapping 3mapped 6end---- Optional的map和flatMap map 是在返回值原类型上包一层； flatmap是 返回值类型 ，不包一层； 123456789101112131415161718var num1: Int? = 10// Optional(20)var num2 = num1.map &#123; $0 * 2 &#125;var num3: Int? = nil// nilvar num4 = num3.map &#123; $0 * 2 &#125;var num1: Int? = 10// Optional(Optional(20))var num2 = num1.map &#123; Optional.some($0 * 2) &#125;// Optional(20)var num3 = num1.flatMap &#123; Optional.some($0 * 2) &#125;var num1: Int? = 10var num2 = (num1 != nil) ? (num1! + 10) : nil var num3 = num1.map &#123; $0 + 10 &#125;// num2、num3是等价的 对可选项的简便判断 可以用map() | flatMap() 12345678910111213var fmt = DateFormatter()fmt.dateFormat = "yyyy-MM-dd"var str: String? = "2011-09-10"// oldvar date1 = str != nil ? fmt.date(from: str!) : nil // newvar date2 = str.flatMap(fmt.date)var score: Int? = 98// oldvar str1 = score != nil ? "socre is \(score!)" : "No score" // newvar str2 = score.map &#123; "score is \($0)" &#125; ?? "No score" 数组对象 巧用map 函数式编程 123456789101112131415161718 struct Person &#123; var name: String var age: Int&#125;var items = [ Person(name: "jack", age: 20), Person(name: "rose", age: 21), Person(name: "kate", age: 22)]// oldfunc getPerson1(_ name: String) -&gt; Person? &#123; let index = items.firstIndex &#123; $0.name == name &#125; return index != nil ? items[index!] : nil&#125;// newfunc getPerson2(_ name: String) -&gt; Person? &#123; return items.firstIndex &#123; $0.name == name &#125;.map &#123; items[$0] &#125;&#125; 对象初始化 可选项判断。 123456789101112131415161718struct Person &#123; var name: String var age: Int init?(_ json: [String : Any]) &#123; guard let name = json["name"] as? String, let age = json["age"] as? Int else &#123; return nil &#125; self.name = name self.age = age &#125; &#125;var json: Dictionary? = ["name" : "Jack", "age" : 10] // oldvar p1 = json != nil ? Person(json!) : nil// newvar p2 = json.flatMap(Person.init) 函数式编程(Funtional Programming) 函数式编程(Funtional Programming，简称FP)是一种编程范式，也就是如何编写程序的方法论 主要思想:把计算过程尽量分解成一系列可复用函数的调用 主要特征:函数是“第一等公民” 函数与其他数据类型一样的地位，可以赋值给其他变量，也可以作为函数参数、函数返回值 函数式编程最早出现在LISP语言，绝大部分的现代编程语言也对函数式编程做了不同程度的支持， 比如: Haskell、JavaScript、Python、Swift、Kotlin、Scala等 函数式编程中几个常用的概念 Higher-Order Function、Function Currying Functor、Applicative Functor、 Monad 参考资料 http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html http://www.mokacoding.com/blog/functor-applicative-monads-in-pictures 函数式编程传统写法/函数式写法 假设要实现以下功能:[(num + 3) * 5 - 1] % 10 / 2 12345678910111213141516171819202122232425var num = 1// 传统写法 func add(_ v1: Int, _ v2: Int) -&gt; Int &#123; v1 + v2 &#125;func sub(_ v1: Int, _ v2: Int) -&gt; Int &#123; v1 - v2 &#125;func multiple(_ v1: Int, _ v2: Int) -&gt; Int &#123; v1 * v2 &#125;func divide(_ v1: Int, _ v2: Int) -&gt; Int &#123; v1 / v2 &#125;func mod(_ v1: Int, _ v2: Int) -&gt; Int &#123; v1 % v2 &#125;divide(mod(sub(multiple(add(num, 3), 5), 1), 10), 2)// 函数式写法，返回闭包表达式func add(_ v: Int) -&gt; (Int) -&gt; Int &#123; &#123; $0 + v &#125; &#125;func sub(_ v: Int) -&gt; (Int) -&gt; Int &#123; &#123; $0 - v &#125; &#125;func multiple(_ v: Int) -&gt; (Int) -&gt; Int &#123; &#123; $0 * v &#125; &#125;func divide(_ v: Int) -&gt; (Int) -&gt; Int &#123; &#123; $0 / v &#125; &#125;func mod(_ v: Int) -&gt; (Int) -&gt; Int &#123; &#123; $0 % v &#125; &#125;infix operator &gt;&gt;&gt; : AdditionPrecedencefunc &gt;&gt;&gt;&lt;A, B, C&gt;(_ f1: @escaping (A) -&gt; B, _ f2: @escaping (B) -&gt; C) -&gt; (A) -&gt; C &#123; // $0 是返回值 block 传入的参数（A） return &#123; f2(f1($0)) &#125; &#125;var fn = add(3) &gt;&gt;&gt; multiple(5) &gt;&gt;&gt; sub(1) &gt;&gt;&gt; mod(10) &gt;&gt;&gt; divide(2)fn(num) 高阶函数(Higher-Order Function) 高阶函数是至少满足下列一个条件的函数: 接受一个或多个函数作为输入(map、filter、reduce等) 返回一个函数 FP中到处都是高阶函数1func add(_ v: Int) -&gt; (Int) -&gt; Int &#123; &#123; $0 + v &#125; &#125; 柯里化(Currying) 什么是柯里化? 将一个接受多参数的函数变换为一系列只接受单个参数的函数 123456func add(_ v1: Int, _ v2: Int) -&gt; Int &#123; v1 + v2 &#125;add(10, 20)// 柯里化func add(_ v: Int) -&gt; (Int) -&gt; Int &#123; &#123; $0 + v &#125; &#125;add(10)(20) Array、Optional的map方法接收的参数就是一个柯里化函数 讲一个函数currying化；进行拆分 123456789101112131415161718192021222324func add1(_ v1: Int, _ v2: Int) -&gt; Int &#123; v1 + v2 &#125;func add2(_ v1: Int, _ v2: Int, _ v3: Int) -&gt; Int &#123; v1 + v2 + v3 &#125;func currying&lt;A, B, C&gt;(_ fn: @escaping (A, B) -&gt; C) -&gt; (B) -&gt; (A) -&gt; C &#123; return &#123; b in &#123; a in fn(a, b) &#125; &#125; &#125;func currying&lt;A, B, C, D&gt;(_ fn: @escaping (A, B, C) -&gt; D) -&gt; (C) -&gt; (B) -&gt; (A) -&gt; D &#123; return &#123; c in &#123; b in &#123; a in fn(a, b, c) &#125; &#125; &#125;&#125;let curriedAdd1 = currying(add1)print(curriedAdd1(10)(20))let curriedAdd2 = currying(add2)print(curriedAdd2(10)(20)(30)) 柯里化(Currying) 结合 函数式编程 1234567891011121314151617func add(_ v1: Int, _ v2: Int) -&gt; Int &#123; v1 + v2 &#125;func sub(_ v1: Int, _ v2: Int) -&gt; Int &#123; v1 - v2 &#125;func multiple(_ v1: Int, _ v2: Int) -&gt; Int &#123; v1 * v2 &#125;func divide(_ v1: Int, _ v2: Int) -&gt; Int &#123; v1 / v2 &#125;func mod(_ v1: Int, _ v2: Int) -&gt; Int &#123; v1 % v2 &#125;prefix func ~&lt;A, B, C&gt;(_ fn: @escaping (A, B) -&gt; C) -&gt; (B) -&gt; (A) -&gt; C &#123; &#123; b in &#123; a in fn(a, b) &#125; &#125; &#125;infix operator &gt;&gt;&gt; : AdditionPrecedencefunc &gt;&gt;&gt;&lt;A, B, C&gt;(_ f1: @escaping (A) -&gt; B, _ f2: @escaping (B) -&gt; C) -&gt; (A) -&gt; C &#123; &#123; f2(f1($0)) &#125; &#125;var num = 1var fn = (~add)(3) &gt;&gt;&gt; (~multiple)(5) &gt;&gt;&gt; (~sub)(1) &gt;&gt;&gt; (~mod)(10) &gt;&gt;&gt; (~divide)(2)fn(num) 函子(Functor) 像Array、Optional这样支持map运算的类型，称为函子(Functor) 1234// Array&lt;Element&gt;public func map&lt;T&gt;(_ transform: (Element) -&gt; T) -&gt; Array&lt;T&gt;// Optional&lt;Wrapped&gt;public func map&lt;U&gt;(_ transform: (Wrapped) -&gt; U) -&gt; Optional&lt;U&gt; 适用函子(Applicative Functor) 对任意一个函子 F，如果能支持以下运算，该函子就是一个适用函子 Optional可以成为适用函子 1234567891011121314func pure&lt;A&gt;(_ value: A) -&gt; F&lt;A&gt;func &lt;*&gt;&lt;A, B&gt;(fn: F&lt;(A) -&gt; B&gt;, value: F&lt;A&gt;) -&gt; F&lt;B&gt;func pure&lt;A&gt;(_ value: A) -&gt; A? &#123; value &#125;infix operator &lt;*&gt; : AdditionPrecedencefunc &lt;*&gt;&lt;A, B&gt;(fn: ((A) -&gt; B)?, value: A?) -&gt; B? &#123; guard let f = fn, let v = value else &#123; return nil &#125; return f(v) &#125;var value: Int? = 10var fn: ((Int) -&gt; Int)? = &#123; $0 * 2&#125;// Optional(20)print(fn &lt;*&gt; value as Any) Array可以成为适用函子 123456789101112131415func pure&lt;A&gt;(_ value: A) -&gt; [A] &#123; [value] &#125;func &lt;*&gt;&lt;A, B&gt;(fn: [(A) -&gt; B], value: [A]) -&gt; [B] &#123; var arr: [B] = [] if fn.count == value.count &#123; for i in fn.startIndex..&lt;fn.endIndex &#123; arr.append(fn[i](value[i])) &#125; &#125; return arr &#125;print(pure(10)) // [10]var arr = [&#123; $0 * 2&#125;, &#123; $0 + 10 &#125;, &#123; $0 - 5 &#125;] &lt;*&gt; [1, 2, 3] print(arr) // [2, 12, -2] 单子(Monad) 对任意一个类型 F，如果能支持以下运算，那么就可以称为是一个单子(Monad) 12func pure&lt;A&gt;(_ value: A) -&gt; F&lt;A&gt;func flatMap&lt;A, B&gt;(_ value: F&lt;A&gt;, _ fn: (A) -&gt; F&lt;B&gt;) -&gt; F&lt;B&gt; 很显然，Array、Optional都是单子 面向协议编程 面向协议编程(Protocol Oriented Programming，简称POP) p是Swift的一种编程范式， Apple于2015年WWDC提出 在Swift的标准库中，能见到大量POP的影子 同时，Swift也是一门面向对象的编程语言(Object Oriented Programming，简称OOP) 在Swift开发中，OOP和POP是相辅相成的，任何一方并不能取代另一方 POP能弥补OOP一些设计上的不足回顾面向对象编程OOP OOP的三大特性:封装、继承、多态 继承的经典使用场合 当多个类(比如A、B、C类)具有很多共性时，可以将这些共性抽取到一个父类中(比如D类)，最后A、B、C类继承D类 OOP的不足 但有些问题，使用OOP并不能很好解决，比如 p如何将BVC、DVC 的公共方法run 抽取出来? 12345678910class BVC: UIViewController &#123; func run() &#123; print("run") &#125;&#125; class DVC: UITableViewController &#123; func run() &#123; print("run") &#125;&#125; 基于OOP想到的一些解决方案? 将run方法放到另一个对象A中，然后BVC、DVC拥有对象A属性 ； 多了一些额外的依赖关系 将run方法增加到UIViewController分类中 ； UIViewController会越来越臃肿，而且会影响它的其他所有子类 将run方法抽取到新的父类，采用多继承?(C++支持多继承) ； 会增加程序设计复杂度，产生菱形继承等问题，需要开发者额外解决 POP的解决方案 遵守相同的协议，然后实现 12345678910protocol Runnable &#123; func run()&#125;extension Runnable &#123; func run() &#123; print("run") &#125;&#125;class BVC: UIViewController, Runnable &#123;&#125; class DVC: UITableViewController, Runnable &#123;&#125; POP的注意点 优先考虑创建协议，而不是父类(基类) 优先考虑值类型(struct、enum)，而不是引用类型(class) 巧用协议的扩展功能 不要为了面向协议而使用协议 利用协议实现前缀效果 定义一个结构体 对原始值进行封装 定义协议，增加属性方法/类方法 获取self； 对需要增加前缀的遵守协议，扩展 增加方法，实现方法 123456789101112131415161718192021222324252627282930var string = "123fdsf434" print(string.sd.numberCount())struct SD&lt;Base&gt; &#123; let base: Base init(_ base: Base) &#123; self.base = base &#125; &#125;protocol SDCompatible &#123;&#125;extension SDCompatible &#123; static var sd: SD&lt;Self&gt;.Type &#123; get &#123; SD&lt;Self&gt;.self &#125; set &#123;&#125; &#125; var sd: SD&lt;Self&gt; &#123; get &#123; SD(self)&#125; set &#123;&#125; &#125;&#125;extension String: SDCompatible &#123;&#125; extension SD where Base == String &#123; func numberCount() -&gt; Int &#123; var count = 0 for c in base where ("0"..."9").contains(c) &#123; count += 1 &#125; return count &#125;&#125; 若想给NSString/NSMutableString 也增加此前缀 扩展方法，不用一个一个遵守协议，只需要让Base遵守协议， 12345678910111213141516171819var s1: String = "123fdsf434"var s2: NSString = "123fdsf434"var s3: NSMutableString = "123fdsf434" print(s1.sd.numberCount()) print(s2.sd.numberCount()) print(s3.sd.numberCount())extension String: SDCompatible &#123;&#125;extension NSString: SDCompatible &#123;&#125;extension SD where Base: ExpressibleByStringLiteral &#123; func numberCount() -&gt; Int &#123; let string = base as! String var count = 0 for c in string where ("0"..."9").contains(c) &#123; count += 1 &#125; return count &#125;&#125; 利用协议实现类型判断123456789101112131415161718func isArray(_ value: Any) -&gt; Bool &#123; value is [Any] &#125;isArray( [1, 2] )isArray( ["1", 2] )isArray( NSArray() )isArray( NSMutableArray() )protocol ArrayType &#123;&#125;extension Array: ArrayType &#123;&#125;extension NSArray: ArrayType &#123;&#125;func isArrayType(_ type: Any.Type) -&gt; Bool &#123; type is ArrayType.Type &#125;isArrayType([Int].self)isArrayType([Any].self)isArrayType(NSArray.self)isArrayType(NSMutableArray.self) 响应式编程 响应式编程(Reactive Programming，简称RP) 也是一种编程范式，于1997年提出，可以简化异步编程，提供更优雅的数据绑定 一般与函数式融合在一起，所以也会叫做:函数响应式编程(Functional Reactive Programming，简称FRP) 比较著名的、成熟的响应式框架 ReactiveCocoa 简称RAC，有Objective-C、Swift版本 官网: http://reactivecocoa.io/ github:https://github.com/ReactiveCocoa ReactiveX 简称Rx，有众多编程语言的版本，比如RxJava、RxKotlin、RxJS、RxCpp、RxPHP、RxGo、RxSwift等等 官网: http://reactivex.io/ github: https://github.com/ReactiveX RxSwift RxSwift(ReactiveX for Swift)，ReactiveX的Swift版本 源码:https://github.com/ReactiveX/RxSwift 中文文档: https://beeth0ven.github.io/RxSwift-Chinese-Documentation/ RxSwift的github上已经有详细的安装教程，这里只演示CocoaPods方式的安装 123456789101112// 1 Podfile use_frameworks!target 'target_name' do pod 'RxSwift', '~&gt; 5' pod 'RxCocoa', '~&gt; 5'end//2 命令行pod repo updateppod install//3 导入模块 import RxSwiftimport RxCocoa 模块说明 RxSwift:Rx标准API的Swift实现，不包括任何iOS相关的内容 RxCocoa:基于RxSwift，给iOS UI控件扩展了很多Rx特性 RxSwift的核心角色 Observable:负责发送事件(Event) Observer:负责订阅Observable，监听Observable发送的事件(Event) 12345678910Observable -&gt; 事件序列(Event Sequence) -&gt; 加工处理 -&gt; ObserverObserver -&gt; 订阅(Subscribe) -&gt; Observablepublic enum Event&lt;Element&gt; &#123;/// Next element is produced. case next(Element)/// Sequence terminated with an error.case error(Swift.Error)/// Sequence completed successfully. case completed&#125; Event有3种 next:携带具体数据 error:携带错误信息，表明Observable终止，不会再发出事件 completed:表明Observable终止，不会再发出事件 创建、订阅Observable1 创建一个observable 只订阅一个对象。之后立即完成 可以用just(1) ;of(1);form([1]) 123456789var observable = Observable&lt;Int&gt;.create &#123; observer in observer.onNext(1) observer.onCompleted() return Disposables.create()&#125;// 等价于observable = Observable.just(1) observable = Observable.of(1) observable = Observable.from([1]) 创建一个observable 订阅一种类型，订阅过个对象 之后立即完成，可以用类似of(1,2,3);form([]) 12345678910var observable = Observable&lt;Int&gt;.create &#123; observer in observer.onNext(1) observer.onNext(2) observer.onNext(3) observer.onCompleted() return Disposables.create() &#125;// 等价于observable = Observable.of(1, 2, 3) observable = Observable.from([1, 2, 3]) 多参数一起订阅 onNext;onError;onCompleted 12345678910111213observable.subscribe &#123; event in print(event)&#125;.dispose()observable.subscribe(onNext: &#123; print("next", $0)&#125;, onError: &#123; print("error", $0)&#125;, onCompleted: &#123; print("completed")&#125;, onDisposed: &#123; print("dispose")&#125;).dispose() 创建、订阅Observable2 监听定时器数字，绑定到label上 1234567let observable = Observable&lt;Int&gt;.timer(.seconds(3), period: .seconds(1), scheduler: MainScheduler.instance) observable.map &#123; "数值是\($0)" &#125; .bind(to: label.rx.text) .disposed(by: bag) 创建Observer1234567891011121314151617181920212223let observer = AnyObserver&lt;Int&gt;.init &#123; event in switch event &#123; case .next(let data): print(data) case .completed: print("completed") case .error(let error): print("error", error) &#125; &#125;Observable.just(1).subscribe(observer).dispose()let binder = Binder&lt;String&gt;(label) &#123; label, text in label.text = text&#125;Observable.just(1) .map &#123; "数值是\($0)" &#125; .subscribe(binder) .dispose() Observable.just(1) .map &#123; "数值是\($0)" &#125; .bind(to: binder) .dispose() 扩展Binder属性 创建一个定时器，1秒切花一次按钮的显示/隐藏 123456789101112extension Reactive where Base: UIView &#123; var hidden: Binder&lt;Bool&gt; &#123; Binder&lt;Bool&gt;(base) &#123; view, value in view.isHidden = value &#125; &#125;&#125;let observable = Observable&lt;Int&gt;.interval(.seconds(1), scheduler: MainScheduler.instance)observable.map &#123; $0 % 2 == 0 &#125; .bind(to: button.rx.hidden) .disposed(by: bag) 传统的状态监听 在开发中经常要对各种状态进行监听，传统的常见监听方案有 p KVO Target-Action Notification Delegate Block Callback 传统方案经常会出现错综复杂的依赖关系、耦合性较高，还需要编写重复的非业务代码 RxSwift的状态监听 UIButton的按钮点击监听 TableView的数据源绑定到Cell上 TableViewCell监听点击事件 1234567891011121314151617button.rx.tap.subscribe(onNext: &#123; print("按钮被点击了1")&#125;).disposed(by: bag)let data = Observable.just([ Person(name: "Jack", age: 10), Person(name: "Rose", age: 20) ])data.bind(to: tableView.rx.items(cellIdentifier: "cell")) &#123; row, person, cell in cell.textLabel?.text = person.name cell.detailTextLabel?.text = "\(person.age)" &#125;.disposed(by: bag)tableView.rx.modelSelected(Person.self) .subscribe(onNext: &#123; person in print("点击了", person.name) &#125;).disposed(by: bag) 对一个对象的某个属性值进行监听 App的通知 NotificationCenter发送通知的监听 12345678910111213141516class Dog: NSObject &#123; @objc dynamic var name: String?&#125;dog.rx.observe(String.self, "name") .subscribe(onNext: &#123; name in print("name is", name ?? "nil") &#125;).disposed(by: bag)dog.name = "larry"dog.name = "wangwang"NotificationCenter.default.rx .notification(UIApplication.didEnterBackgroundNotification) .subscribe(onNext: &#123; notification in print("APP进入后台", notification) &#125;).disposed(by: bag) 既是Observable，又是Observer 诸如UISlider.rx.value、UTextField.rx.text这类属性值，既是Observable，又是Observer p 它们是RxCocoa.ControlProperty类型 12345678910Observable.just(0.8).bind(to: slider.rx.value).dispose()slider.rx.value.map &#123; "当前数值是:\($0)"&#125; .bind(to: textField.rx.text) .disposed(by: bag) textField.rx.text .subscribe(onNext: &#123; text in print("text is", text ?? "nil") &#125;).disposed(by: bag) 订阅的取消方式 Disposable 每当Observable被订阅时，都会返回一个Disposable实例，当调用Disposable的dispose，就相当于取消订阅 在不需要再接收事件时，建议取消订阅，释放资源。有3种常见方式取消订阅 1234567891011121314// 立即取消订阅(一次性订阅) observable.subscribe &#123; event in print(event)&#125;.dispose()// 当bag销毁(deinit)时，会自动调用Disposable实例的dispose observable.subscribe &#123; event in print(event)&#125;.disposed(by: bag)// self销毁时(deinit)时，会自动调用Disposable实例的disposelet _ = observable.takeUntil(self.rx.deallocated).subscribe &#123; event in print(event)&#125;]]></content>
      <categories>
        <category>iOS</category>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift-xmg21]]></title>
    <url>%2F2019%2F03%2F23%2FiOS%2Fswift-xmg21%2F</url>
    <content type="text"><![CDATA[Swift项目相关Tips Tips 12345MARK、TODO、FIXME// MARK: 类似于OC中的 // MARK: 类似于OC中的 // TODO: 用于标记未完成的任务// FIXME: 用于标记待修复的问题 自定义LOG 123456func log&lt;T&gt;(_ msg: T, file: NSString = #file, line: Int = #line, fn: String = #function) &#123; #if DEBUG let prefix = "\(file.lastPathComponent)_\(line)_\(fn):" print(prefix, msg) #endif&#125; 系统版本检测 12345 if #available(iOS 10, macOS 10.12, *) &#123; // 对于iOS平台，只在iOS10及以上版本执行 // 对于macOS平台，只在macOS 10.12及以上版本执行 // 最后的*表示在其他所有平台都执行&#125; API可用性说明 12345678910@available(iOS 10, macOS 10.15, *)class Person &#123;&#125;struct Student &#123; @available(*, unavailable, renamed: "study") func study_() &#123;&#125; func study() &#123;&#125; @available(iOS, deprecated: 11) @available(macOS, deprecated: 10.12) func run() &#123;&#125;&#125; 条件编译 根据操作系统/CPU/Swift版本/环境/是否可导出等条件编译 123456789101112131415161718192021222324// 操作系统 macOS\iOS\tvOS\watchOS\Linux\Android\Windows\FreeBSD#if os(macOS) || os(iOS)// CPU 架构i386\x86_64\arm\arm64#elseif arch(x86_64) || arch(arm64)// Swift版本#elseif swift(&lt;5) &amp;&amp; swift(&gt;-3)// 是否是模拟器#elseif targetEnvironments(simulator)// 可以导入某模块#elseif canImport(Foundation)#else#endif#if DEBUG// ***print()#else// ** do some thing#endif Swift 调用OC 新建桥接文件 ；文件名固定格式{targetName}-Bridging-Header.h 在Build Setting中 搜索Bridging 引入桥接文件路径 在{targetName}-Bridging-Header.h 文件中#import OC需要暴露给Swift的内容 #import &quot;Person.h&quot; 如果C语言 暴露给Swift的函数 和Swift中的其他函数名冲突了。可以在Swift使用@_silgent_name修改C函数名 OC调用Swift Xcode 已经默认生成一个用于OC调用Swift的头文件，文件名格式{targetName}-Swift.h 在Building Setting中 搜索 generated interface 设置路径暴露给OC 调用 1234567891011121314151617181920import Foundation@objcMembers class Car: NSObject &#123; var price: Double var band: String init(price: Double, band: String) &#123; self.price = price self.band = band &#125; func run() &#123; print(price, band, "run") &#125; static func run() &#123; print("Car run") &#125; &#125;extension Car &#123; func test() &#123; print(price, band, "test") &#125;&#125; Swift暴露给OC的类最终继承自NSObject 使用@objc修饰需要暴露给OC的成员 使用@objcMembers修饰类 ;代表默认所有成员都会暴露给OC(包括扩展中定义的成员) ;最终是否成功暴露，还需要考虑成员自身的访问级别 选择器(Selector) Swift中依然可以使用选择器，使用#selector(name)定义一个选择器 必须是被@objcMembers或@objc修饰的方法才可以定义选择器 123456789101112@objcMembers class Person: NSObject &#123; func test1(v1: Int) &#123; print("test1") &#125; func test2(v1: Int, v2: Int) &#123; print("test2(v1:v2:)") &#125; func test2(_ v1: Double, _ v2: Double) &#123; print("test2(_:_:)") &#125; func run() &#123; perform(#selector(test1)) perform(#selector(test1(v1:))) perform(#selector(test2(v1:v2:))) perform(#selector(test2(_:_:))) perform(#selector(test2 as (Double, Double) -&gt; Void)) &#125; &#125; String Swift的字符串类型String，跟OC的NSString，在API设计上还是有较大差异 Swift 是结构体 12345678910111213141516171819202122232425// 空字符串var emptyStr1 = ""var emptyStr2 = String()var str = "123456" print(str.hasPrefix("123")) // true print(str.hasSuffix("456")) // truevar str: String = "1" // 拼接，jack_rose str.append("_2")// 重载运算符 +str = str + "_3" // 重载运算符 += str += "_4"// \()插值str = "\(str)_5"// 长度，9，1_2_3_4_5 print(str.count) String的插入和删除; 插入到头部/尾部/指定下标/ 指定下表偏移量 根据下标移除；可以移除字符数组；可以移除一个range 范围内的子串 123456789101112131415161718192021222324var str = "1_2"// 1_2_str.insert("_", at: str.endIndex)// 1_2_3_4str.insert(contentsOf: "3_4", at: str.endIndex)// 1666_2_3_4str.insert(contentsOf: "666", at: str.index(after: str.startIndex))// 1666_2_3_8884str.insert(contentsOf: "888", at: str.index(before: str.endIndex))// 1666hello_2_3_8884str.insert(contentsOf: "hello", at: str.index(str.startIndex, offsetBy: 4)) // 666hello_2_3_8884str.remove(at: str.firstIndex(of: "1")!)// hello_2_3_8884str.removeAll &#123; $0 == "6" &#125;var range = str.index(str.endIndex, offsetBy: -4)..&lt;str.index(before: str.endIndex) // hello_2_3_4str.removeSubrange(range) Substring String可以通过下标、 prefix、 suffix等截取子串，子串类型不是String，而是Substring Substring和它的base，共享字符串数据 Substring发生修改 或者 转为String时，会分配新的内存存储字符串数据 123456789101112131415var str = "1_2_3_4_5"// 1_2var substr1 = str.prefix(3)// 4_5var substr2 = str.suffix(3)// 1_2var range = str.startIndex..&lt;str.index(str.startIndex, offsetBy: 3) var substr3 = str[range]// 最初的String，1_2_3_4_5 print(substr3.base)// Substring -&gt; Stringvar str2 = String(substr3) String 与 Character 123456for c in "jack" &#123; // c是Character类型 print(c)&#125;var str = "jack"// c是Character类型var c = str[str.startIndex] String相关的协议 BidirectionalCollection 协议包含的部分内容 startIndex 、 endIndex 属性、index 方法 String、Array 都遵守了这个协议 RangeReplaceableCollection 协议包含的部分内容 append、insert、remove 方法 String、Array 都遵守了这个协议 Dictionary、Set 也有实现上述协议中声明的一些方法，只是并没有遵守上述协议 多行String 1234567891011121314151617181920212223242526// 如果要显示3引号，至少转义1个引号 let str = """Escaping the first quote \""" Escaping two quotes \"\"" Escaping all three quotes \"\"\" """输出是：Escaping the first quote """ Escaping two quotes """ Escaping all three quotes """// 缩进以结尾的3引号为对齐线 let str = """ 1 2 3 4"""输出是： 1 2 3 4 String 与 NSString 之间可以随时随地桥接转换 如果你觉得String的API过于复杂难用，可以考虑将String转为NSString 比较字符串内容是否等价 String使用 == 运算符 NSString使用isEqual方法，也可以使用 == 运算符(本质还是调用了isEqual方法) 1234567var str1: String = "jack"var str2: NSString = "rose"var str3 = str1 as NSStringvar str4 = str2 as String// javar str5 = str3.substring(with: NSRange(location: 0, length: 2)) print(str5) Swift、OC桥接转换表 Swift 转换 OC String ⇌ NSString String ← NSMutableString Array ⇌ NSArray Array ← NSMutableArray Dictionary ⇌ NSDictionary Dictionary ← NSMutableDictionary Set ⇌ NSSet Set ← NSMutableSet 可选协议 可以通过@objc 定义可选协议，这种协议只能被class 遵守 1234567891011@objc protocol Runnable &#123; func run1() @objc optional func run2()func run3() &#125;class Dog: Runnable &#123; func run3() &#123; print("Dog run3") &#125; func run1() &#123; print("Dog run1") &#125;&#125;var d = Dog()d.run1() // Dog run1d.run3() // Dog run3 dynamic 被 @objc dynamic修饰的内容会具有动态性，比如调用方法会走runtime那一套流程 1234567891011class Dog: NSObject &#123; @objc dynamic func test1() &#123;&#125; func test2() &#123;&#125;&#125;var d = Dog()d.test1()d.test2()// 汇编test2() 是正常的swift函数调用。callq *0x50(%rdx) 调用虚表text1() 是走消息转发 runtime callq 0x100007c5e ;symbol stub for:objc_msgSend KVC\KVO Swift 支持 KVC \ KVO 的条件 属性所在的类、监听器最终继承自 NSObject 用 @objc dynamic 修饰对应的属性 123456789101112131415161718192021222324// 重写observerclass Observer: NSObject &#123; override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) &#123; print("observeValue", change?[.newKey] as Any) &#125;&#125;class Person: NSObject &#123; @objc dynamic var age: Int = 0 var observer: Observer = Observer() override init() &#123; super.init() self.addObserver(observer, forKeyPath: "age", options: .new, context: nil) &#125; deinit &#123; self.removeObserver(observer, forKeyPath: "age") &#125; &#125;var p = Person()p.age = 20 // print: observeValue Optional(20)p.setValue(25, forKey: "age") // print: observeValue Optional(25) block方式的KVO123456789101112131415class Person: NSObject &#123; @objc dynamic var age: Int = 0 var observation: NSKeyValueObservation? override init() &#123; super.init() observation = observe(\Person.age, options: .new) &#123; (person, change) in print(change.newValue as Any) &#125;&#125; &#125;var p = Person()// Optional(20)p.age = 20// Optional(25)p.setValue(25, forKey: "age") 关联对象(Associated Object) 在Swift中，class依然可以使用关联对象 默认情况，extension不可以增加存储属性 借助关联对象，可以实现类似extension为class增加存储属性的效果 1234567891011121314151617181920class Person &#123;&#125;extension Person &#123; private static var AGE_KEY: Void? var age: Int &#123; get &#123; (objc_getAssociatedObject(self, &amp;Self.AGE_KEY) as? Int) ?? 0 &#125; set &#123; objc_setAssociatedObject(self, &amp;Self.AGE_KEY, newValue, .OBJC_ASSOCIATION_ASSIGN) &#125; &#125;&#125;var p = Person()print(p.age) // 0p.age = 10print(p.age) // 10 资源名管理 这种做法实际上是参考了Android的资源名管理方式 字符串/String的图片名 等，通过R 资源获取 ，易于管理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263enum R &#123; enum string: String &#123; case add = "添加" &#125; enum image: String &#123; case logo &#125; enum segue: String &#123; case login_main &#125;&#125;// 正常逻辑let img = UIImage(named: "logo") let btn = UIButton(type: .custom)btn.setTitle("添加", for: .normal) performSegue(withIdentifier: "login_main", sender: self)// 处理后let img = UIImage(R.image.logo) let btn = UIButton(type: .custom)btn.setTitle(R.string.add, for: .normal) performSegue(withIdentifier: R.segue.login_main, sender: self)// 也可以使用扩展extension UIImage &#123; convenience init?(_ name: R.image) &#123; self.init(named: name.rawValue) &#125;&#125;extension UIViewController &#123; func performSegue(withIdentifier identifier: R.segue, sender: Any?) &#123; performSegue(withIdentifier: identifier.rawValue, sender: sender) &#125;&#125;extension UIButton &#123; func setTitle(_ title: R.string, for state: UIControl.State) &#123; setTitle(title.rawValue, for: state) &#125;&#125;let img = UIImage(named: "logo")let font = UIFont(name: "Arial", size: 14)let img = R.image.logolet font = R.font.arial(14)enum R &#123; enum image &#123; static var logo = UIImage(named: "logo") &#125; enum font &#123; static func arial(_ size: CGFloat) -&gt; UIFont? &#123; UIFont(name: "Arial", size: size) &#125; &#125; &#125;更多优秀的思路参考 https://github.com/mac-cain13/R.swift phttps://github.com/SwiftGen/SwiftGen 多线程开发 – 异步 定义一个任务Block; 创建DispatchItem; 在子线程中执行异步任务； 如果有主线程任务，item通知在主线程中执行 maintask 12345678910111213141516public typealias Task = ()-&gt; Voidpublic static func async(_task: @escaping Task) &#123; _async(task)&#125;public static func async(_task: @escaping Task, mainTask: @escaping Task) &#123; _async(task, mainTask)&#125;private static func _async(_ task: @escaping Task, _ mainTask: Task? = nil) &#123; let item = DispatchWorkItem(block: task) DispatchQueue.global().async(execute: item) if let main = mainTask &#123; item.notify(queue: DispatchQueue.main, execute: main) &#125;&#125; 多线程开发 – 延迟 在一个线程中 asyncAfter延迟 1234567@discardableResultpublic static func delay(_ seconds: Double, _ block: @escaping Task) -&gt; DispatchWorkItem &#123; let item = DispatchWorkItem(block: block) DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + seconds, execute: item) return item &#125; 多线程开发 – 异步延迟 当前任务行任务A，执行延迟任务B，之后回到主线程执行C 12345678910111213141516171819202122@discardableResultpublic static func asyncDelay(_ seconds: Double, _ task: @escaping Task) -&gt; DispatchWorkItem &#123; return _asyncDelay(seconds, task)&#125;@discardableResultpublic static func asyncDelay(_ seconds: Double, _ task: @escaping Task, _ mainTask: @escaping Task) -&gt; DispatchWorkItem &#123; return _asyncDelay(seconds, task, mainTask)&#125;private static func _asyncDelay(_ seconds: Double, _ task: @escaping Task, _ mainTask: Task? = nil) -&gt; DispatchWorkItem &#123; let item = DispatchWorkItem(block: task) DispatchQueue.global().asyncAfter(deadline: DispatchTime.now() + seconds, execute: item) if let main = mainTask &#123; item.notify(queue: DispatchQueue.main, execute: main) &#125; return item &#125; 多线程开发 – once dispatch_once在Swift中已被废弃，取而代之 可以用类型属性或者全局变量\常量 默认自带 lazy + dispatch_once 效果 12345678910111213141516fileprivate let initTask2: Void = &#123; print("initTask2---------") &#125;()class ViewController: UIViewController &#123; static let initTask1: Void = &#123; print("initTask1---------") &#125;() override func viewDidLoad() &#123; super.viewDidLoad() let _ = Self.initTask1 let _ = initTask2 &#125; &#125; 多线程开发 – 加锁 gcd信号量 DispatchSemaphore defer() ; 在作用域autoreleasepool释放之前执行。与写的位置无关 1234567891011class Cache &#123; private static var data = [String: Any]() private static var lock = DispatchSemaphore(value: 1) static func set(_ key: String, _ value: Any) &#123; lock.wait() defer &#123; lock.signal() &#125; data[key] = value &#125;&#125; Foundation NSLock || NSRecursiveLock 1234567891011121314private static var lock = NSLock()static func set(_ key: String, _ value: Any) &#123; lock.lock() defer &#123; lock.unlock() &#125;&#125;private static var lock = NSRecursiveLock() static func set(_ key: String, _ value: Any) &#123; lock.lock() defer &#123; lock.unlock() &#125;&#125;]]></content>
      <categories>
        <category>iOS</category>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift-xmg20]]></title>
    <url>%2F2019%2F03%2F22%2FiOS%2Fswift-xmg20%2F</url>
    <content type="text"><![CDATA[字面量 常见字面量的默认类型 public typealias IntegerLiteralType = Int public typealias FloatLiteralType = Double public typealias BooleanLiteralType = Bool public typealias StringLiteralType = String Swift自带的绝大部分类型，都支持直接通过字面量进行初始化 Bool、Int、Float、Double、String、Array、Dictionary、Set、Optional等 12345// 可以通过typealias修改字面量的默认类型typealias FloatLiteralType = Float typealias IntegerLiteralType = UInt8 var age = 10 // UInt8var height = 1.68 // Float 字面量协议 Swift自带类型之所以能够通过字面量初始化，是因为它们遵守了对应的协议 Bool : ExpressibleByBooleanLiteral Int : ExpressibleByIntegerLiteral Float、Double : ExpressibleByIntegerLiteral、ExpressibleByFloatLiteral Dictionary : ExpressibleByDictionaryLiteral String : ExpressibleByStringLiteral Array、Set : ExpressibleByArrayLiteral Optional : ExpressibleByNilLiteral 1234567891011var b: Bool = false // ExpressibleByBooleanLiteralvar i: Int = 10 // ExpressibleByIntegerLiteralvar f0: Float = 10 // ExpressibleByIntegerLiteralvar f1: Float = 10.0 // ExpressibleByFloatLiteralvar d0: Double = 10 // ExpressibleByIntegerLiteralvar d1: Double = 10.0 // ExpressibleByFloatLiteralvar s: String = "jack" // ExpressibleByStringLiteralvar arr: Array = [1, 2, 3] // ExpressibleByArrayLiteralvar set: Set = [1, 2, 3] // ExpressibleByArrayLiteralvar dict: Dictionary = ["jack" : 60] // ExpressibleByDictionaryLiteral var o: Optional&lt;Int&gt; = nil // ExpressibleByNilLiteral 字面量协议应用1 对象的多init实现 123456789101112131415161718192021222324252627// 扩展Bool字面量协议extension Int : ExpressibleByBooleanLiteral &#123; public init(booleanLiteral value: Bool) &#123; self = value ? 1 : 0 &#125;&#125;var num: Int = true // 可以直接赋Bool值print(num) // 1// 遵守了 Int,Float,String 字面量协议 实现init 字面量方法；初始化的时候直接赋值数字/字符串class Student : ExpressibleByIntegerLiteral, ExpressibleByFloatLiteral, ExpressibleByStringLiteral, CustomStringConvertible &#123; var name: String = "" var score: Double = 0 required init(floatLiteral value: Double) &#123; self.score = value &#125; required init(integerLiteral value: Int) &#123; self.score = Double(value) &#125; required init(stringLiteral value: String) &#123; self.name = value &#125; required init(unicodeScalarLiteral value: String) &#123; self.name = value &#125; required init(extendedGraphemeClusterLiteral value: String) &#123; self.name = value &#125; var description: String &#123; "name=\(name),score=\(score)" &#125;&#125;var stu: Student = 90print(stu) // name=,score=90.0 stu = 98.5print(stu) // name=,score=98.5 stu = "Jack"print(stu) // name=Jack,score=0.0 字面量协议应用2 结构体的多实现 12345678910111213141516171819202122struct Point &#123; var x = 0.0, y = 0.0&#125;extension Point : ExpressibleByArrayLiteral, ExpressibleByDictionaryLiteral &#123; init(arrayLiteral elements: Double...) &#123; guard elements.count &gt; 0 else &#123; return &#125; self.x = elements[0] guard elements.count &gt; 1 else &#123; return &#125; self.y = elements[1] &#125; init(dictionaryLiteral elements: (String, Double)...) &#123; for (k, v) in elements &#123; if k == "x" &#123; self.x = v &#125; else if k == "y" &#123; self.y = v &#125; &#125; &#125;&#125;var p: Point = [10.5, 20.5] print(p) // Point(x: 10.5, y: 20.5) p = ["x" : 11, "y" : 22]print(p) // Point(x: 11.0, y: 22.0) 模式(Pattern) 模式是用于匹配的规则，比如switch的case、捕捉错误的catch、if\guard\while\for语句的条件等 Swift中的模式有 通配符模式(Wildcard Pattern) 标识符模式(Identifier Pattern) 值绑定模式(Value-Binding Pattern) 元组模式(Tuple Pattern) 枚举Case模式(Enumeration Case Pattern) 可选模式(Optional Pattern) 类型转换模式(Type-Casting Pattern) 表达式模式(Expression Pattern) 通配符模式(Wildcard Pattern) _ 匹配任何值 _? 匹配非nil值 123456789101112131415161718enum Life &#123; case human(name: String, age: Int?) case animal(name: String, age: Int?)&#125;func check(_ life: Life) &#123; switch life &#123; case .human(let name, _): print("human", name) case .animal(let name, _?): print("animal", name) default: print("other") &#125; &#125;check(.human(name: "Rose", age: 20)) // human Rose check(.human(name: "Jack", age: nil)) // human Jack check(.animal(name: "Dog", age: 5)) // animal Dog check(.animal(name: "Cat", age: nil)) // other 标识符模式(Identifier Pattern) 给对应的变量、常量名赋值 12var age = 10let name = "jack" 值绑定模式(Value-Binding Pattern) case let (x,y) switch-case绑定元祖 12345let point = (3, 2)switch point &#123;case let (x, y): print("The point is at (\(x), \(y)).")&#125; 元组模式(Tuple Pattern) for循环(x,y)绑定，_ 是任何值都可以 case (_?, _ , _ as String): 第一个值非空，第二值都可以，第三个值是字符串类型 字典的(key,value) for循环 123456789101112131415161718192021let points = [(0, 0), (1, 0), (2, 0)]for (x, _) in points &#123; print(x) &#125;let name: String? = "jack"let age = 18let info: Any = [1, 2]switch (name, age, info) &#123; case (_?, _ , _ as String): print("case") default: print("default")&#125; // defaultvar scores = ["jack" : 98, "rose" : 100, "kate" : 86]for (name, score) in scores &#123; print(name, score)&#125; 枚举Case模式(Enumeration Case Pattern) if case语句等价于只有1个case的switch语句 1234567891011121314151617181920212223242526272829let age = 2// 原来的写法if age &gt;= 0 &amp;&amp; age &lt;= 9 &#123; print("[0, 9]")&#125;// 枚举Case模式if case 0...9 = age &#123; print("[0, 9]")&#125;guard case 0...9 = age else &#123; return &#125;print("[0, 9]")// 相当于下面switch age &#123; case 0...9: print("[0, 9]") default: break&#125;// case nil 有空值进入，结束For循环let ages: [Int?] = [2, 3, nil, 5]for case nil in ages &#123; print("有nil值") break&#125; // 有nil值// Item 的第二个值为0 进入for循环let points = [(1, 0), (2, 1), (3, 0)]for case let (x, 0) in points &#123; print(x)&#125; // 1 3 可选模式(Optional Pattern) case let x? = age 取出age 非空 才执行 123456789101112131415161718192021222324252627let age: Int? = 42if case .some(let x) = age &#123; print(x) &#125;if case let x? = age &#123; print(x) &#125;func check(_ num: Int?) &#123; switch num &#123; case 2?: print("2") case 4?: print("4") case 6?: print("6") case _?: print("other") case _: print("nil")&#125; &#125;check(4) // 4check(8) // othercheck(nil) // nillet ages: [Int?] = [nil, 2, 3, nil, 5]for case let age? in ages &#123; print(age)&#125; // 2 3 5// 跟上面的for，效果是等价的let ages: [Int?] = [nil, 2, 3, nil, 5]for item in ages &#123; if let age = item &#123; print(age) &#125;&#125; 类型转换模式(Type-Casting Pattern) is Int 和as Int 的区别 下面的case 走了is Int 但是类型没有转换，还是Any类型， case let dog as Gog 类型对应，并且转换了类型 1234567891011121314151617181920212223242526272829let num: Any = 6switch num &#123;case is Int: // 编译器依然认为num是Any类型 print("is Int", num) //case let n as Int: // print("as Int", n + 1) default: break&#125;class Animal &#123; func eat() &#123; print(type(of: self), "eat") &#125; &#125;class Dog : Animal &#123; func run() &#123; print(type(of: self), "run") &#125; &#125; class Cat : Animal &#123; func jump() &#123; print(type(of: self), "jump") &#125; &#125; func check(_ animal: Animal) &#123; switch animal &#123; case let dog as Dog: dog.eat() dog.run() case is Cat: animal.eat() default: break &#125; &#125;// Dog eat// Dog runcheck(Dog())// Cat eatcheck(Cat()) 表达式模式(Expression Pattern) 表达式模式用在case中 12345678910let point = (1, 2)switch point &#123; case (0, 0): print("(0, 0) is at the origin.") case (-2...2, -2...2): print("(\(point.0), \(point.1)) is near the origin.") default: print("The point is at (\(point.0), \(point.1)).") &#125; // (1, 2) is near the origin. 自定义表达式模式1 可以通过重载运算符，自定义表达式模式的匹配规则 1234567891011121314151617181920212223242526272829303132struct Student &#123; var score = 0, name = "" static func ~= (pattern: Int, value: Student) -&gt; Bool &#123; value.score &gt;= pattern &#125; static func ~= (pattern: ClosedRange&lt;Int&gt;, value: Student) -&gt; Bool &#123; pattern.contains(value.score) &#125; static func ~= (pattern: Range&lt;Int&gt;, value: Student) -&gt; Bool &#123; pattern.contains(value.score) &#125;&#125;var stu = Student(score: 75, name: "Jack") switch stu &#123; case 100: print("&gt;= 100") case 90: print("&gt;= 90") case 80..&lt;90: print("[80, 90)") case 60...79: print("[60, 79]") case 0: print("&gt;= 0") default: break&#125; // [60, 79]if case 60 = stu &#123; print("&gt;= 60")&#125; // &gt;= 60var info = (Student(score: 70, name: "Jack"), "及格") switch info &#123; case let (60, text): print(text) default: break&#125; // 及格 自定义表达式模式2 自定义表达式，pattern 接受一个函数， 此函数 对value的值进行处理，返回一个Bool值 12345678910111213extension String &#123; static func ~= (pattern: (String) -&gt; Bool, value: String) -&gt; Bool &#123; pattern(value) &#125;&#125;func hasPrefix(_ prefix: String) -&gt; ((String) -&gt; Bool) &#123; &#123; $0.hasPrefix(prefix) &#125; &#125;func hasSuffix(_ suffix: String) -&gt; ((String) -&gt; Bool) &#123; &#123; $0.hasSuffix(suffix) &#125; &#125;var str = "jack"switch str &#123; case hasPrefix("j"), hasSuffix("k"): print("以j开头，以k结尾") default: break&#125; // 以j开头，以k结尾 自定义表达式模式3 函数名传入作为参数 1234567891011121314151617func isEven(_ i: Int) -&gt; Bool &#123; i % 2 == 0 &#125; func isOdd(_ i: Int) -&gt; Bool &#123; i % 2 != 0 &#125;extension Int &#123; static func ~= (pattern: (Int) -&gt; Bool, value: Int) -&gt; Bool &#123; pattern(value) &#125;&#125;var age = 9switch age &#123; case isEven: print("偶数") case isOdd: print("奇数") default: print("其他") &#125; where 可以使用where为模式匹配增加匹配条件 12345678910111213141516171819202122var data = (10, "Jack")switch data &#123; case let (age, _) where age &gt; 10: print(data.1, "age&gt;10") case let (age, _) where age &gt; 0: print(data.1, "age&gt;0") default: break&#125;protocol Stackable &#123; associatedtype Element &#125; protocol Container &#123; associatedtype Stack : Stackable where Stack.Element : Equatable &#125;var ages = [10, 20, 44, 23, 55]for age in ages where age &gt; 30 &#123; print(age)&#125; // 44 55func equal&lt;S1: Stackable, S2: Stackable&gt;(_ s1: S1, _ s2: S2) -&gt; Bool where S1.Element == S2.Element, S1.Element : Hashable &#123; return false&#125;extension Container where Self.Stack.Element : Hashable &#123; &#125;]]></content>
      <categories>
        <category>iOS</category>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift-xmg19]]></title>
    <url>%2F2019%2F03%2F21%2FiOS%2Fswift-xmg19%2F</url>
    <content type="text"><![CDATA[字面量 常见字面量的默认类型 public typealias IntegerLiteralType = Int public typealias FloatLiteralType = Double public typealias BooleanLiteralType = Bool public typealias StringLiteralType = String Swift自带的绝大部分类型，都支持直接通过字面量进行初始化 Bool、Int、Float、Double、String、Array、Dictionary、Set、Optional等 12345// 可以通过typealias修改字面量的默认类型typealias FloatLiteralType = Float typealias IntegerLiteralType = UInt8 var age = 10 // UInt8var height = 1.68 // Float 字面量协议 Swift自带类型之所以能够通过字面量初始化，是因为它们遵守了对应的协议 Bool : ExpressibleByBooleanLiteral Int : ExpressibleByIntegerLiteral Float、Double : ExpressibleByIntegerLiteral、ExpressibleByFloatLiteral Dictionary : ExpressibleByDictionaryLiteral String : ExpressibleByStringLiteral Array、Set : ExpressibleByArrayLiteral Optional : ExpressibleByNilLiteral 1234567891011var b: Bool = false // ExpressibleByBooleanLiteralvar i: Int = 10 // ExpressibleByIntegerLiteralvar f0: Float = 10 // ExpressibleByIntegerLiteralvar f1: Float = 10.0 // ExpressibleByFloatLiteralvar d0: Double = 10 // ExpressibleByIntegerLiteralvar d1: Double = 10.0 // ExpressibleByFloatLiteralvar s: String = "jack" // ExpressibleByStringLiteralvar arr: Array = [1, 2, 3] // ExpressibleByArrayLiteralvar set: Set = [1, 2, 3] // ExpressibleByArrayLiteralvar dict: Dictionary = ["jack" : 60] // ExpressibleByDictionaryLiteral var o: Optional&lt;Int&gt; = nil // ExpressibleByNilLiteral 字面量协议应用1 对象的多init实现 123456789101112131415161718192021222324252627// 扩展Bool字面量协议extension Int : ExpressibleByBooleanLiteral &#123; public init(booleanLiteral value: Bool) &#123; self = value ? 1 : 0 &#125;&#125;var num: Int = true // 可以直接赋Bool值print(num) // 1// 遵守了 Int,Float,String 字面量协议 实现init 字面量方法；初始化的时候直接赋值数字/字符串class Student : ExpressibleByIntegerLiteral, ExpressibleByFloatLiteral, ExpressibleByStringLiteral, CustomStringConvertible &#123; var name: String = "" var score: Double = 0 required init(floatLiteral value: Double) &#123; self.score = value &#125; required init(integerLiteral value: Int) &#123; self.score = Double(value) &#125; required init(stringLiteral value: String) &#123; self.name = value &#125; required init(unicodeScalarLiteral value: String) &#123; self.name = value &#125; required init(extendedGraphemeClusterLiteral value: String) &#123; self.name = value &#125; var description: String &#123; "name=\(name),score=\(score)" &#125;&#125;var stu: Student = 90print(stu) // name=,score=90.0 stu = 98.5print(stu) // name=,score=98.5 stu = "Jack"print(stu) // name=Jack,score=0.0 字面量协议应用2 结构体的多实现 12345678910111213141516171819202122struct Point &#123; var x = 0.0, y = 0.0&#125;extension Point : ExpressibleByArrayLiteral, ExpressibleByDictionaryLiteral &#123; init(arrayLiteral elements: Double...) &#123; guard elements.count &gt; 0 else &#123; return &#125; self.x = elements[0] guard elements.count &gt; 1 else &#123; return &#125; self.y = elements[1] &#125; init(dictionaryLiteral elements: (String, Double)...) &#123; for (k, v) in elements &#123; if k == "x" &#123; self.x = v &#125; else if k == "y" &#123; self.y = v &#125; &#125; &#125;&#125;var p: Point = [10.5, 20.5] print(p) // Point(x: 10.5, y: 20.5) p = ["x" : 11, "y" : 22]print(p) // Point(x: 11.0, y: 22.0) 模式(Pattern) 模式是用于匹配的规则，比如switch的case、捕捉错误的catch、if\guard\while\for语句的条件等 Swift中的模式有 通配符模式(Wildcard Pattern) 标识符模式(Identifier Pattern) 值绑定模式(Value-Binding Pattern) 元组模式(Tuple Pattern) 枚举Case模式(Enumeration Case Pattern) 可选模式(Optional Pattern) 类型转换模式(Type-Casting Pattern) 表达式模式(Expression Pattern) 通配符模式(Wildcard Pattern) _ 匹配任何值 _? 匹配非nil值 123456789101112131415161718enum Life &#123; case human(name: String, age: Int?) case animal(name: String, age: Int?)&#125;func check(_ life: Life) &#123; switch life &#123; case .human(let name, _): print("human", name) case .animal(let name, _?): print("animal", name) default: print("other") &#125; &#125;check(.human(name: "Rose", age: 20)) // human Rose check(.human(name: "Jack", age: nil)) // human Jack check(.animal(name: "Dog", age: 5)) // animal Dog check(.animal(name: "Cat", age: nil)) // other 标识符模式(Identifier Pattern) 给对应的变量、常量名赋值 12var age = 10let name = "jack" 值绑定模式(Value-Binding Pattern) case let (x,y) switch-case绑定元祖 12345let point = (3, 2)switch point &#123;case let (x, y): print("The point is at (\(x), \(y)).")&#125; 元组模式(Tuple Pattern) for循环(x,y)绑定，_ 是任何值都可以 case (_?, _ , _ as String): 第一个值非空，第二值都可以，第三个值是字符串类型 字典的(key,value) for循环 123456789101112131415161718192021let points = [(0, 0), (1, 0), (2, 0)]for (x, _) in points &#123; print(x) &#125;let name: String? = "jack"let age = 18let info: Any = [1, 2]switch (name, age, info) &#123; case (_?, _ , _ as String): print("case") default: print("default")&#125; // defaultvar scores = ["jack" : 98, "rose" : 100, "kate" : 86]for (name, score) in scores &#123; print(name, score)&#125; 枚举Case模式(Enumeration Case Pattern) if case语句等价于只有1个case的switch语句 1234567891011121314151617181920212223242526272829let age = 2// 原来的写法if age &gt;= 0 &amp;&amp; age &lt;= 9 &#123; print("[0, 9]")&#125;// 枚举Case模式if case 0...9 = age &#123; print("[0, 9]")&#125;guard case 0...9 = age else &#123; return &#125;print("[0, 9]")// 相当于下面switch age &#123; case 0...9: print("[0, 9]") default: break&#125;// case nil 有空值进入，结束For循环let ages: [Int?] = [2, 3, nil, 5]for case nil in ages &#123; print("有nil值") break&#125; // 有nil值// Item 的第二个值为0 进入for循环let points = [(1, 0), (2, 1), (3, 0)]for case let (x, 0) in points &#123; print(x)&#125; // 1 3 可选模式(Optional Pattern) case let x? = age 取出age 非空 才执行 123456789101112131415161718192021222324252627let age: Int? = 42if case .some(let x) = age &#123; print(x) &#125;if case let x? = age &#123; print(x) &#125;func check(_ num: Int?) &#123; switch num &#123; case 2?: print("2") case 4?: print("4") case 6?: print("6") case _?: print("other") case _: print("nil")&#125; &#125;check(4) // 4check(8) // othercheck(nil) // nillet ages: [Int?] = [nil, 2, 3, nil, 5]for case let age? in ages &#123; print(age)&#125; // 2 3 5// 跟上面的for，效果是等价的let ages: [Int?] = [nil, 2, 3, nil, 5]for item in ages &#123; if let age = item &#123; print(age) &#125;&#125; 类型转换模式(Type-Casting Pattern) is Int 和as Int 的区别 下面的case 走了is Int 但是类型没有转换，还是Any类型， case let dog as Gog 类型对应，并且转换了类型 1234567891011121314151617181920212223242526272829let num: Any = 6switch num &#123;case is Int: // 编译器依然认为num是Any类型 print("is Int", num) //case let n as Int: // print("as Int", n + 1) default: break&#125;class Animal &#123; func eat() &#123; print(type(of: self), "eat") &#125; &#125;class Dog : Animal &#123; func run() &#123; print(type(of: self), "run") &#125; &#125; class Cat : Animal &#123; func jump() &#123; print(type(of: self), "jump") &#125; &#125; func check(_ animal: Animal) &#123; switch animal &#123; case let dog as Dog: dog.eat() dog.run() case is Cat: animal.eat() default: break &#125; &#125;// Dog eat// Dog runcheck(Dog())// Cat eatcheck(Cat()) 表达式模式(Expression Pattern) 表达式模式用在case中 12345678910let point = (1, 2)switch point &#123; case (0, 0): print("(0, 0) is at the origin.") case (-2...2, -2...2): print("(\(point.0), \(point.1)) is near the origin.") default: print("The point is at (\(point.0), \(point.1)).") &#125; // (1, 2) is near the origin. 自定义表达式模式1 可以通过重载运算符，自定义表达式模式的匹配规则 1234567891011121314151617181920212223242526272829303132struct Student &#123; var score = 0, name = "" static func ~= (pattern: Int, value: Student) -&gt; Bool &#123; value.score &gt;= pattern &#125; static func ~= (pattern: ClosedRange&lt;Int&gt;, value: Student) -&gt; Bool &#123; pattern.contains(value.score) &#125; static func ~= (pattern: Range&lt;Int&gt;, value: Student) -&gt; Bool &#123; pattern.contains(value.score) &#125;&#125;var stu = Student(score: 75, name: "Jack") switch stu &#123; case 100: print("&gt;= 100") case 90: print("&gt;= 90") case 80..&lt;90: print("[80, 90)") case 60...79: print("[60, 79]") case 0: print("&gt;= 0") default: break&#125; // [60, 79]if case 60 = stu &#123; print("&gt;= 60")&#125; // &gt;= 60var info = (Student(score: 70, name: "Jack"), "及格") switch info &#123; case let (60, text): print(text) default: break&#125; // 及格 自定义表达式模式2 自定义表达式，pattern 接受一个函数， 此函数 对value的值进行处理，返回一个Bool值 12345678910111213extension String &#123; static func ~= (pattern: (String) -&gt; Bool, value: String) -&gt; Bool &#123; pattern(value) &#125;&#125;func hasPrefix(_ prefix: String) -&gt; ((String) -&gt; Bool) &#123; &#123; $0.hasPrefix(prefix) &#125; &#125;func hasSuffix(_ suffix: String) -&gt; ((String) -&gt; Bool) &#123; &#123; $0.hasSuffix(suffix) &#125; &#125;var str = "jack"switch str &#123; case hasPrefix("j"), hasSuffix("k"): print("以j开头，以k结尾") default: break&#125; // 以j开头，以k结尾 自定义表达式模式3 函数名传入作为参数 1234567891011121314151617func isEven(_ i: Int) -&gt; Bool &#123; i % 2 == 0 &#125; func isOdd(_ i: Int) -&gt; Bool &#123; i % 2 != 0 &#125;extension Int &#123; static func ~= (pattern: (Int) -&gt; Bool, value: Int) -&gt; Bool &#123; pattern(value) &#125;&#125;var age = 9switch age &#123; case isEven: print("偶数") case isOdd: print("奇数") default: print("其他") &#125; where 可以使用where为模式匹配增加匹配条件 12345678910111213141516171819202122var data = (10, "Jack")switch data &#123; case let (age, _) where age &gt; 10: print(data.1, "age&gt;10") case let (age, _) where age &gt; 0: print(data.1, "age&gt;0") default: break&#125;protocol Stackable &#123; associatedtype Element &#125; protocol Container &#123; associatedtype Stack : Stackable where Stack.Element : Equatable &#125;var ages = [10, 20, 44, 23, 55]for age in ages where age &gt; 30 &#123; print(age)&#125; // 44 55func equal&lt;S1: Stackable, S2: Stackable&gt;(_ s1: S1, _ s2: S2) -&gt; Bool where S1.Element == S2.Element, S1.Element : Hashable &#123; return false&#125;extension Container where Self.Stack.Element : Hashable &#123; &#125;]]></content>
      <categories>
        <category>iOS</category>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift-xmg18]]></title>
    <url>%2F2019%2F03%2F20%2FiOS%2Fswift-xmg18%2F</url>
    <content type="text"><![CDATA[从OC到Swift注释 MARK、TODO、FIXME // MARK: 类似于OC中的 #pragma mark // MARK: - 类似于OC中的 #pragma mark - n// TODO: 用于标记未完成的任务 // FIXME: 用于标记待修复的问题 条件编译 条件编译 1234567891011121314151617// 操作系统:macOS\iOS\tvOS\watchOS\Linux\Android\Windows\FreeBSD #if os(macOS) || os(iOS)// CPU架构:i386\x86_64\arm\arm64#elseif arch(x86_64) || arch(arm64)// swift版本#elseif swift(&lt;5) &amp;&amp; swift(&gt;=3)// 模拟器#elseif targetEnvironment(simulator) // 可以导入某模块#elseif canImport(Foundation)#else#endif 系统版本检测 1234if #available(iOS 10, macOS 10.12, *) &#123; // 对于iOS平台，只在iOS10及以上版本执行 // 对于macOS平台，只在macOS 10.12及以上版本执行 // 最后的*表示在其他所有平台都执行&#125; API可用性说明 123456789101112@available(iOS 10, macOS 10.15, *)class Person &#123;&#125;struct Student &#123; @available(*, unavailable, renamed: "study") func study_() &#123;&#125; func study() &#123;&#125; @available(iOS, deprecated: 11) @available(macOS, deprecated: 10.12) func run() &#123;&#125;&#125; // 更多用法参考:https://docs.swift.org/swift-book/ReferenceManual/Attributes.html 打印 封装打印方法 12345func log&lt;T&gt;(_ msg: T, file: NSString = #file, line: Int = #line, fn: String = #function) &#123; #if DEBUG let prefix = "\(file.lastPathComponent)_\(line)_\(fn):" print(prefix, msg) #endif&#125; iOS程序的入口 在AppDelegate上面默认有个@UIApplicationMain标记，这表示 编译器自动生成入口代码(main函数代码)，自动设置AppDelegate为APP的代理 也可以删掉@UIApplicationMain，自定义入口代码:新建一个main.swift文件 1// func UIApplicationMain(_ argc: Int32, _ argv: UnsafeMutablePointer&lt;UnsafeMutablePointer&lt;Int8&gt;?&gt;, _ principalClassName: String?, _ delegateClassName: String?) -&gt; Int32 Swift 调用OC 在Swift项目中 创建OC文件，会提示是否创建桥接文件，自动生成 或者手动生成 新建1个桥接头文件，文件名格式默认为:{targetName}-Bridging-Header.h 在{targetName}-Bridging-Header.h 文件中#import OC需要暴露给Swift的内容 1#import "TPerson.h" 在Build Setting 搜索 bridging 在Object-C Bridging Header 填写配置 Swift调用OC – @_silgen_name 如果C语言暴露给Swift的函数名跟Swift中的其他函数名冲突了 可以在Swift中使用 @_silgen_name 修改C函数名 123456789// C语言int sum(int a, int b) &#123; return a + b; &#125;// Swift@_silgen_name("sum") func swift_sum(_ v1: Int32, _ v2: Int32) -&gt; Int32print(swift_sum(10, 20)) // 30print(sum(10, 20)) // 30 OC调用Swift Xcode已经默认生成一个用于OC调用Swift的头文件，文件名格式是: {targetName}-Swift.h 在Build Setting下 generated interface 搜索 Object-C Generated Interface Header Name 配置 123456789101112131415OC调用Swift – Car.swift import Foundation@objcMembers class Car: NSObject &#123; var price: Double var band: String init(price: Double, band: String) &#123; self.price = price self.band = band &#125; func run() &#123; print(price, band, "run") &#125; static func run() &#123; print("Car run") &#125; &#125;extension Car &#123; func test() &#123; print(price, band, "test") &#125;&#125; Swift暴露给OC的类最终继承自NSObject 使用@objc修饰需要暴露给OC的成员 使用@objcMembers修饰类 代表默认所有成员都会暴露给OC(包括扩展中定义的成员) 最终是否成功暴露，还需要考虑成员自身的访问级别 Xcode会根据Swift代码生成对应的OC声明，写入{targetName}-Swift.h 文件 在使用的的.m 文件中 要import &quot;{targetName}-Swift.h&quot; 才能使用 可以通过@objc 重命名Swift暴露给OC的符号名(类名、属性名、函数名等) 12345678910111213141516@objcMembers class Car: NSObject &#123; var price: Double @objc(name) var band: String init(price: Double, band: String) &#123; self.price = price self.band = band &#125; @objc(drive) func run() &#123; print(price, band, "run") &#125; static func run() &#123; print("Car run") &#125;&#125;extension Car &#123; @objc(exec:v2:) func test() &#123; print(price, band, "test") &#125; &#125; 选择器(Selector) Swift中依然可以使用选择器，使用#selector(name)定义一个选择器 必须是被@objcMembers或@objc修饰的方法才可以定义选择器 12345678910111213 @objcMembers class Person: NSObject &#123; func test1(v1: Int) &#123; print("test1") &#125; func test2(v1: Int, v2: Int) &#123; print("test2(v1:v2:)") &#125; func test2(_ v1: Double, _ v2: Double) &#123; print("test2(_:_:)") &#125; func run() &#123; perform(#selector(test1)) perform(#selector(test1(v1:))) perform(#selector(test2(v1:v2:))) perform(#selector(test2(_:_:))) perform(#selector(test2 as (Double, Double) -&gt; Void)) &#125; &#125;]]></content>
      <categories>
        <category>iOS</category>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift-xmg17]]></title>
    <url>%2F2019%2F03%2F19%2FiOS%2Fswift-xmg17%2F</url>
    <content type="text"><![CDATA[字面量 常见字面量的默认类型 public typealias IntegerLiteralType = Int public typealias FloatLiteralType = Double public typealias BooleanLiteralType = Bool public typealias StringLiteralType = String Swift自带的绝大部分类型，都支持直接通过字面量进行初始化 Bool、Int、Float、Double、String、Array、Dictionary、Set、Optional等 12345// 可以通过typealias修改字面量的默认类型typealias FloatLiteralType = Float typealias IntegerLiteralType = UInt8 var age = 10 // UInt8var height = 1.68 // Float 字面量协议 Swift自带类型之所以能够通过字面量初始化，是因为它们遵守了对应的协议 Bool : ExpressibleByBooleanLiteral Int : ExpressibleByIntegerLiteral Float、Double : ExpressibleByIntegerLiteral、ExpressibleByFloatLiteral Dictionary : ExpressibleByDictionaryLiteral String : ExpressibleByStringLiteral Array、Set : ExpressibleByArrayLiteral Optional : ExpressibleByNilLiteral 1234567891011var b: Bool = false // ExpressibleByBooleanLiteralvar i: Int = 10 // ExpressibleByIntegerLiteralvar f0: Float = 10 // ExpressibleByIntegerLiteralvar f1: Float = 10.0 // ExpressibleByFloatLiteralvar d0: Double = 10 // ExpressibleByIntegerLiteralvar d1: Double = 10.0 // ExpressibleByFloatLiteralvar s: String = "jack" // ExpressibleByStringLiteralvar arr: Array = [1, 2, 3] // ExpressibleByArrayLiteralvar set: Set = [1, 2, 3] // ExpressibleByArrayLiteralvar dict: Dictionary = ["jack" : 60] // ExpressibleByDictionaryLiteral var o: Optional&lt;Int&gt; = nil // ExpressibleByNilLiteral 字面量协议应用1 对象的多init实现 123456789101112131415161718192021222324252627// 扩展Bool字面量协议extension Int : ExpressibleByBooleanLiteral &#123; public init(booleanLiteral value: Bool) &#123; self = value ? 1 : 0 &#125;&#125;var num: Int = true // 可以直接赋Bool值print(num) // 1// 遵守了 Int,Float,String 字面量协议 实现init 字面量方法；初始化的时候直接赋值数字/字符串class Student : ExpressibleByIntegerLiteral, ExpressibleByFloatLiteral, ExpressibleByStringLiteral, CustomStringConvertible &#123; var name: String = "" var score: Double = 0 required init(floatLiteral value: Double) &#123; self.score = value &#125; required init(integerLiteral value: Int) &#123; self.score = Double(value) &#125; required init(stringLiteral value: String) &#123; self.name = value &#125; required init(unicodeScalarLiteral value: String) &#123; self.name = value &#125; required init(extendedGraphemeClusterLiteral value: String) &#123; self.name = value &#125; var description: String &#123; "name=\(name),score=\(score)" &#125;&#125;var stu: Student = 90print(stu) // name=,score=90.0 stu = 98.5print(stu) // name=,score=98.5 stu = "Jack"print(stu) // name=Jack,score=0.0 字面量协议应用2 结构体的多实现 12345678910111213141516171819202122struct Point &#123; var x = 0.0, y = 0.0&#125;extension Point : ExpressibleByArrayLiteral, ExpressibleByDictionaryLiteral &#123; init(arrayLiteral elements: Double...) &#123; guard elements.count &gt; 0 else &#123; return &#125; self.x = elements[0] guard elements.count &gt; 1 else &#123; return &#125; self.y = elements[1] &#125; init(dictionaryLiteral elements: (String, Double)...) &#123; for (k, v) in elements &#123; if k == "x" &#123; self.x = v &#125; else if k == "y" &#123; self.y = v &#125; &#125; &#125;&#125;var p: Point = [10.5, 20.5] print(p) // Point(x: 10.5, y: 20.5) p = ["x" : 11, "y" : 22]print(p) // Point(x: 11.0, y: 22.0) 模式(Pattern) 模式是用于匹配的规则，比如switch的case、捕捉错误的catch、if\guard\while\for语句的条件等 Swift中的模式有 通配符模式(Wildcard Pattern) 标识符模式(Identifier Pattern) 值绑定模式(Value-Binding Pattern) 元组模式(Tuple Pattern) 枚举Case模式(Enumeration Case Pattern) 可选模式(Optional Pattern) 类型转换模式(Type-Casting Pattern) 表达式模式(Expression Pattern) 通配符模式(Wildcard Pattern) _ 匹配任何值 _? 匹配非nil值 123456789101112131415161718enum Life &#123; case human(name: String, age: Int?) case animal(name: String, age: Int?)&#125;func check(_ life: Life) &#123; switch life &#123; case .human(let name, _): print("human", name) case .animal(let name, _?): print("animal", name) default: print("other") &#125; &#125;check(.human(name: "Rose", age: 20)) // human Rose check(.human(name: "Jack", age: nil)) // human Jack check(.animal(name: "Dog", age: 5)) // animal Dog check(.animal(name: "Cat", age: nil)) // other 标识符模式(Identifier Pattern) 给对应的变量、常量名赋值 12var age = 10let name = "jack" 值绑定模式(Value-Binding Pattern) case let (x,y) switch-case绑定元祖 12345let point = (3, 2)switch point &#123;case let (x, y): print("The point is at (\(x), \(y)).")&#125; 元组模式(Tuple Pattern) for循环(x,y)绑定，_ 是任何值都可以 case (_?, _ , _ as String): 第一个值非空，第二值都可以，第三个值是字符串类型 字典的(key,value) for循环 123456789101112131415161718192021let points = [(0, 0), (1, 0), (2, 0)]for (x, _) in points &#123; print(x) &#125;let name: String? = "jack"let age = 18let info: Any = [1, 2]switch (name, age, info) &#123; case (_?, _ , _ as String): print("case") default: print("default")&#125; // defaultvar scores = ["jack" : 98, "rose" : 100, "kate" : 86]for (name, score) in scores &#123; print(name, score)&#125; 枚举Case模式(Enumeration Case Pattern) if case语句等价于只有1个case的switch语句 1234567891011121314151617181920212223242526272829let age = 2// 原来的写法if age &gt;= 0 &amp;&amp; age &lt;= 9 &#123; print("[0, 9]")&#125;// 枚举Case模式if case 0...9 = age &#123; print("[0, 9]")&#125;guard case 0...9 = age else &#123; return &#125;print("[0, 9]")// 相当于下面switch age &#123; case 0...9: print("[0, 9]") default: break&#125;// case nil 有空值进入，结束For循环let ages: [Int?] = [2, 3, nil, 5]for case nil in ages &#123; print("有nil值") break&#125; // 有nil值// Item 的第二个值为0 进入for循环let points = [(1, 0), (2, 1), (3, 0)]for case let (x, 0) in points &#123; print(x)&#125; // 1 3 可选模式(Optional Pattern) case let x? = age 取出age 非空 才执行 123456789101112131415161718192021222324252627let age: Int? = 42if case .some(let x) = age &#123; print(x) &#125;if case let x? = age &#123; print(x) &#125;func check(_ num: Int?) &#123; switch num &#123; case 2?: print("2") case 4?: print("4") case 6?: print("6") case _?: print("other") case _: print("nil")&#125; &#125;check(4) // 4check(8) // othercheck(nil) // nillet ages: [Int?] = [nil, 2, 3, nil, 5]for case let age? in ages &#123; print(age)&#125; // 2 3 5// 跟上面的for，效果是等价的let ages: [Int?] = [nil, 2, 3, nil, 5]for item in ages &#123; if let age = item &#123; print(age) &#125;&#125; 类型转换模式(Type-Casting Pattern) is Int 和as Int 的区别 下面的case 走了is Int 但是类型没有转换，还是Any类型， case let dog as Gog 类型对应，并且转换了类型 1234567891011121314151617181920212223242526272829let num: Any = 6switch num &#123;case is Int: // 编译器依然认为num是Any类型 print("is Int", num) //case let n as Int: // print("as Int", n + 1) default: break&#125;class Animal &#123; func eat() &#123; print(type(of: self), "eat") &#125; &#125;class Dog : Animal &#123; func run() &#123; print(type(of: self), "run") &#125; &#125; class Cat : Animal &#123; func jump() &#123; print(type(of: self), "jump") &#125; &#125; func check(_ animal: Animal) &#123; switch animal &#123; case let dog as Dog: dog.eat() dog.run() case is Cat: animal.eat() default: break &#125; &#125;// Dog eat// Dog runcheck(Dog())// Cat eatcheck(Cat()) 表达式模式(Expression Pattern) 表达式模式用在case中 12345678910let point = (1, 2)switch point &#123; case (0, 0): print("(0, 0) is at the origin.") case (-2...2, -2...2): print("(\(point.0), \(point.1)) is near the origin.") default: print("The point is at (\(point.0), \(point.1)).") &#125; // (1, 2) is near the origin. 自定义表达式模式1 可以通过重载运算符，自定义表达式模式的匹配规则 1234567891011121314151617181920212223242526272829303132struct Student &#123; var score = 0, name = "" static func ~= (pattern: Int, value: Student) -&gt; Bool &#123; value.score &gt;= pattern &#125; static func ~= (pattern: ClosedRange&lt;Int&gt;, value: Student) -&gt; Bool &#123; pattern.contains(value.score) &#125; static func ~= (pattern: Range&lt;Int&gt;, value: Student) -&gt; Bool &#123; pattern.contains(value.score) &#125;&#125;var stu = Student(score: 75, name: "Jack") switch stu &#123; case 100: print("&gt;= 100") case 90: print("&gt;= 90") case 80..&lt;90: print("[80, 90)") case 60...79: print("[60, 79]") case 0: print("&gt;= 0") default: break&#125; // [60, 79]if case 60 = stu &#123; print("&gt;= 60")&#125; // &gt;= 60var info = (Student(score: 70, name: "Jack"), "及格") switch info &#123; case let (60, text): print(text) default: break&#125; // 及格 自定义表达式模式2 自定义表达式，pattern 接受一个函数， 此函数 对value的值进行处理，返回一个Bool值 12345678910111213extension String &#123; static func ~= (pattern: (String) -&gt; Bool, value: String) -&gt; Bool &#123; pattern(value) &#125;&#125;func hasPrefix(_ prefix: String) -&gt; ((String) -&gt; Bool) &#123; &#123; $0.hasPrefix(prefix) &#125; &#125;func hasSuffix(_ suffix: String) -&gt; ((String) -&gt; Bool) &#123; &#123; $0.hasSuffix(suffix) &#125; &#125;var str = "jack"switch str &#123; case hasPrefix("j"), hasSuffix("k"): print("以j开头，以k结尾") default: break&#125; // 以j开头，以k结尾 自定义表达式模式3 函数名传入作为参数 1234567891011121314151617func isEven(_ i: Int) -&gt; Bool &#123; i % 2 == 0 &#125; func isOdd(_ i: Int) -&gt; Bool &#123; i % 2 != 0 &#125;extension Int &#123; static func ~= (pattern: (Int) -&gt; Bool, value: Int) -&gt; Bool &#123; pattern(value) &#125;&#125;var age = 9switch age &#123; case isEven: print("偶数") case isOdd: print("奇数") default: print("其他") &#125; where 可以使用where为模式匹配增加匹配条件 12345678910111213141516171819202122var data = (10, "Jack")switch data &#123; case let (age, _) where age &gt; 10: print(data.1, "age&gt;10") case let (age, _) where age &gt; 0: print(data.1, "age&gt;0") default: break&#125;protocol Stackable &#123; associatedtype Element &#125; protocol Container &#123; associatedtype Stack : Stackable where Stack.Element : Equatable &#125;var ages = [10, 20, 44, 23, 55]for age in ages where age &gt; 30 &#123; print(age)&#125; // 44 55func equal&lt;S1: Stackable, S2: Stackable&gt;(_ s1: S1, _ s2: S2) -&gt; Bool where S1.Element == S2.Element, S1.Element : Hashable &#123; return false&#125;extension Container where Self.Stack.Element : Hashable &#123; &#125;]]></content>
      <categories>
        <category>iOS</category>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift-xmg16]]></title>
    <url>%2F2019%2F03%2F18%2FiOS%2Fswift-xmg16%2F</url>
    <content type="text"><![CDATA[内存管理 跟OC一样，Swift也是采取基于引用计数的ARC内存管理方案(针对堆空间) Swift的ARC中有3种引用 强引用(strong reference):默认情况下，引用都是强引用 弱引用(weak reference):通过weak定义弱引用 必须是可选类型的var，因为实例销毁后，ARC会自动将弱引用设置为nil ARC自动给弱引用设置nil时，不会触发属性观察器 无主引用(unowned reference):通过unowned定义无主引用 不会产生强引用，实例销毁后仍然存储着实例的内存地址(类似于OC中的unsafe_unretained) 试图在实例销毁后访问无主引用，会产生运行时错误(野指针)Fatal error: Attempted to read an unowned reference but object 0x0 was already deallocated week,unwoned只能用载类实例上 循环引用(Reference Cycle) weak、unowned 都能解决循环引用的问题，unowned 要比weak 少一些性能消耗 在生命周期中可能会变为 nil 的使用 weak 初始化赋值后再也不会变为 nil 的使用 unowned 闭包的循环引用 闭包表达式默认会对用到的外层对象产生额外的强引用(对外层对象进行了retain操作) 下面代码会产生循环引用，导致Person对象无法释放(看不到Person的deinit被调用) 在闭包表达式的捕获列表声明weak或unowned引用，解决循环引用问题 12345678910111213141516171819class Person &#123; var fn: (() -&gt; ())? func run() &#123; print("run") &#125; deinit &#123; print("deinit") &#125;&#125;func test() &#123; let p = Person() p.fn = &#123; p.run() &#125;&#125;test() p.fn = &#123; [weak p] in p?.run() &#125; p.fn = &#123; [unowned p] in p.run() &#125; p.fn = &#123; [weak wp = p, unowned up = p, a = 10 + 20] in wp?.run() &#125; 如果想在定义闭包属性的同时引用self，这个闭包必须是lazy的(因为在实例初始化完毕之后才能引用self) 左边的闭包fn内部如果用到了实例成员(属性、方法) 编译器会强制要求明确写出self 12345678class Person &#123; lazy var fn: (() -&gt; ()) = &#123; [weak self] in self?.run() &#125; func run() &#123; print("run") &#125; deinit &#123; print("deinit") &#125;&#125; 如果lazy属性是闭包调用的结果，那么不用考虑循环引用的问题(因为闭包调用后，闭包的生命周期就结束了) 1234567class Person &#123; var age: Int = 0 lazy var getAge: Int = &#123; self.age &#125;() deinit &#123; print("deinit") &#125;&#125; 逃逸闭包 @escaping 非逃逸闭包、逃逸闭包，一般都是当做参数传递给函数 非逃逸闭包:闭包调用发生在函数结束前，闭包调用在函数作用域内 逃逸闭包:闭包有可能在函数结束后调用，闭包调用逃离了函数的作用域，需要通过@escaping声明 12345678910111213141516171819202122232425262728293031import Dispatchtypealias Fn = () -&gt; ()// fn是非逃逸闭包func test1(_ fn: Fn) &#123; fn() &#125; // fn是逃逸闭包var gFn: Fn?func test2(_ fn: @escaping Fn) &#123; gFn = fn &#125;// fn是逃逸闭包func test3(_ fn: @escaping Fn) &#123; DispatchQueue.global().async &#123; fn() &#125; &#125;class Person &#123; var fn: Fn // fn是逃逸闭包 init(fn: @escaping Fn) &#123; self.fn = fn &#125; func run() &#123; // DispatchQueue.global().async也是一个逃逸闭包 // 它用到了实例成员(属性、方法)，编译器会强制要求明确写出self DispatchQueue.global().async &#123; self.fn() &#125; &#125; &#125; 逃逸闭包的注意点 逃逸闭包不可以捕获inout参数 12345678910111213typealias Fn = () -&gt; ()func other1(_ fn: Fn) &#123; fn() &#125;func other2(_ fn: @escaping Fn) &#123; fn() &#125;func test(value: inout Int) -&gt; Fn &#123; other1 &#123; value += 1 &#125; // error: 逃逸闭包不能捕获inout参数 other2 &#123; value += 1 &#125; func plus() &#123; value += 1 &#125; // error: 逃逸闭包不能捕获inout参数 return plus&#125; 内存访问冲突(Conflicting Access to Memory) 内存访问冲突会在两个访问满足下列条件时发生: 至少一个是写入操作 它们访问的是同一块内存 它们的访问时间重叠(比如在同一个函数内) 12345678910111213141516// 不存在内存访问冲突func plus(_ num: inout Int) -&gt; Int &#123; num + 1 &#125; var number = 1number = plus(&amp;number) // 存在内存访问冲突// Simultaneous accesses to 0x0, but modification requires exclusive access var step = 1func increment(_ num: inout Int) &#123; num += step &#125;increment(&amp;step) // 解决内存访问冲突var copyOfStep = step increment(&amp;copyOfStep) step = copyOfStep 内存访问冲突 如果下面的条件可以满足，就说明重叠访问结构体的属性是安全的 你只访问实例存储属性，不是计算属性或者类属性 结构体是局部变量而非全局变量 结构体要么没有被闭包捕获要么只被非逃逸闭包捕获 123456789func test() &#123; var tulpe = (health: 10, energy: 20) balance(&amp;tulpe.health, &amp;tulpe.energy) var holly = Player(name: "Holly", health: 10, energy: 10) balance(&amp;holly.health, &amp;holly.energy) &#125;test() // OK的 全局变量 存储属性，没有闭包捕获 指针指针类型 Swift中也有专门的指针类型，这些都被定性为“Unsafe”(不安全的)，常见的有以下4种类型 UnsafePointer&lt;T&gt; 类似于 const T * UnsafeMutablePointer&lt;T&gt; 类似于 T * UnsafeRawPointer 类似于 const void * UnsafeMutableRawPointer 类似于 void * 12345678910111213141516171819202122var age = 10func test1(_ ptr: UnsafeMutablePointer&lt;Int&gt;) &#123; ptr.pointee += 10&#125;func test2(_ ptr: UnsafePointer&lt;Int&gt;) &#123; print(ptr.pointee)&#125;test1(&amp;age)test2(&amp;age) // 20print(age) // 20var age = 10func test3(_ ptr: UnsafeMutableRawPointer) &#123; ptr.storeBytes(of: 20, as: Int.self) &#125;func test4(_ ptr: UnsafeRawPointer) &#123; print(ptr.load(as: Int.self))&#125;test3(&amp;age)test4(&amp;age) // 20print(age) // 20 指针的应用示例 数组遍历函数中的stop指针 123456789101112131415var arr = NSArray(objects: 11, 22, 33, 44)arr.enumerateObjects &#123; (obj, idx, stop) in print(idx, obj) if idx == 2 &#123; // 下标为2就停止遍历 stop.pointee = true &#125;&#125;// 等同var arr = NSArray(objects: 11, 22, 33, 44)for (idx, obj) in arr.enumerated() &#123; print(idx, obj) if idx == 2 &#123; break &#125; &#125; 获得指向某个变量的指针 withUnsafeMutablePointer 函数 返回的指针UnsafeMutablePointer&lt;T&gt; 类型的指针，指向的变量可以进行写入修改 body 接收一个闭包函数，此闭包函数入参是value T，返回值是Result 最后一个入参 是闭包，此闭包直邮一个返回值，可以写成尾随闭包 withUnsafePointer 返回的指针UnsafePointer&lt;T&gt; 类型的指针，指向的变量不可以写入修改 函数按$0原入参返回 类型是范型的，确切知道指针每次存取 指针的移动的个数类型； init 根据范型指针init 一个不带范型的指针； 存储写入数据 用storeBytes 函数；传入 值，偏移量，类型； 读取数据，用load 函数；传入 偏移量/类型 12345678910111213141516171819202122232425262728293031// func withUnsafeMutablePointer&lt;T, Result&gt;( to value: inout T, _ body: (UnsafeMutablePointer&lt;T&gt;) throws -&gt; Result) rethrows -&gt; Result// func withUnsafePointer&lt;T, Result&gt;(to value: T, _ body: (UnsafePointer&lt;T&gt;) throws -&gt; Result) rethrows -&gt; Result var age = 11// var ptr1: UnsafeMutablePointer&lt;Int&gt;var ptr1 = withUnsafeMutablePointer(to: &amp;age) &#123; $0 &#125; // var ptr2: UnsafePointer&lt;Int&gt;var ptr2 = withUnsafePointer(to: &amp;age) &#123; $0 &#125;ptr1.pointee = 22print(ptr2.pointee) // 22print(age) // 22// UnsafeMutableRawPointer init?&lt;T&gt;(_ other: UnsafeMutablePointer&lt;T&gt;?)// var ptr3: UnsafeMutableRawPointervar ptr3 = withUnsafeMutablePointer(to: &amp;age) &#123; UnsafeMutableRawPointer($0) &#125;// var ptr4: UnsafeRawPointervar ptr4 = withUnsafePointer(to: &amp;age) &#123; UnsafeRawPointer($0) &#125;// func storeBytes&lt;T&gt;(of value: T, toByteOffset offset: Int = default, as: T.Type)ptr3.storeBytes(of: 33, as: Int.self)// func load&lt;T&gt;(fromByteOffset offset: Int = default, as type: T.Type) -&gt; Tprint(ptr4.load(as: Int.self)) // 33print(age) // 33 获得指向堆空间实例的指针 先取出Person的指针，再读区 指针存储内存地址的存储内容 123456789class Person &#123;&#125;var person = Person()var ptr = withUnsafePointer(to: &amp;person) &#123; UnsafeRawPointer($0) &#125; // 取出指向Person的指针var heapPtr = UnsafeRawPointer(bitPattern: ptr.load(as: UInt.self)) // 取出Person指针的 存储的内容，是堆空间地址print(heapPtr!)Creates an OpaquePointer from a given address in memory.Declarationinit?(bitPattern: UInt) 创建指针 通过 malloc 必须 free(ptr) 通过 allocate 必须 ptr.deallocate(ptr) 1234567891011121314151617181920// 创建一个指针，申请16个字节，前8个字节存储11，偏移量8，后8个字节存储22var ptr = UnsafeRawPointer(bitPattern: 0x100001234) // 创建var ptr = malloc(16)// 存ptr?.storeBytes(of: 11, as: Int.self)ptr?.storeBytes(of: 22, toByteOffset: 8, as: Int.self)// 取print((ptr?.load(as: Int.self))!) // 11 print((ptr?.load(fromByteOffset: 8, as: Int.self))!) // 22 // 销毁free(ptr)// 创建一个16字节，前8个字节存储11 ；advanced 指针移动8个字节，再存储22占用8个字节var ptr = UnsafeMutableRawPointer.allocate(byteCount: 16, alignment: 1) ptr.storeBytes(of: 11, as: Int.self)ptr.advanced(by: 8).storeBytes(of: 22, as: Int.self) print(ptr.load(as: Int.self)) // 11print(ptr.advanced(by: 8).load(as: Int.self)) // 22 ptr.deallocate() 带范型&lt;Int&gt;的指针通过successor() 移动，每次移动8个字节， ptr.successor() 指针下移一位 通过 ptr + 1 / ptr[0] 来偏移读取 1234567891011121314var ptr = UnsafeMutablePointer&lt;Int&gt;.allocate(capacity: 3)ptr.initialize(to: 11)ptr.successor().initialize(to: 22)ptr.successor().successor().initialize(to: 33)print(ptr.pointee) // 11print((ptr + 1).pointee) // 22print((ptr + 2).pointee) // 33print(ptr[0]) // 11print(ptr[1]) // 22print(ptr[2]) // 33ptr.deinitialize(count: 3)ptr.deallocate() 需要每次创建之后进行 deinitialize / deallocate 操作 1234567891011121314151617181920class Person &#123; var age: Int var name: String init(age: Int, name: String) &#123; self.age = age self.name = name &#125; deinit &#123; print(name, "deinit") &#125; &#125;var ptr = UnsafeMutablePointer&lt;Person&gt;.allocate(capacity: 3) ptr.initialize(to: Person(age: 10, name: "Jack"))(ptr + 1).initialize(to: Person(age: 11, name: "Rose")) (ptr + 2).initialize(to: Person(age: 12, name: "Kate"))// Jack deinit// Rose deinit// Kate deinit ptr.deinitialize(count: 3) ptr.deallocate() 指针之间的转换 unsafeBitCast是忽略数据类型的强制转换，不会因为数据类型的变化而改变原来的内存数据 类似于C++中的reinterpret_cast 12345678910111213141516var ptr = UnsafeMutableRawPointer.allocate(byteCount: 16, alignment: 1) ptr.assumingMemoryBound(to: Int.self).pointee = 11(ptr + 8).assumingMemoryBound(to: Double.self).pointee = 22.0 print(unsafeBitCast(ptr, to: UnsafePointer&lt;Int&gt;.self).pointee) // 11print(unsafeBitCast(ptr + 8, to: UnsafePointer&lt;Double&gt;.self).pointee) // 22.0 ptr.deallocate()/*to: The type T that the memory has already been bound to. Returns: A typed pointer to the same memory as this raw pointer.Declarationfunc assumingMemoryBound&lt;T&gt;(to: T.Type) -&gt; UnsafeMutablePointer&lt;T&gt;*/class Person &#123;&#125;var person = Person()var ptr = unsafeBitCast(person, to: UnsafeRawPointer.self) print(ptr)]]></content>
      <categories>
        <category>iOS</category>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift-xmg15]]></title>
    <url>%2F2019%2F03%2F17%2FiOS%2Fswift-xmg15%2F</url>
    <content type="text"><![CDATA[访问控制(Access Control) 在访问权限控制这块，Swift提供了5个不同的访问级别(以下是从高到低排列， 实体指被访问级别修饰的内容) open:允许在定义实体的模块、其他模块中访问，允许其他模块进行继承、重写(open只能用在类、类成员上) public:允许在定义实体的模块、其他模块中访问，不允许其他模块进行继承、重写 internal:只允许在定义实体的模块中访问，不允许在其他模块中访问 fileprivate:只允许在定义实体的源文件中访问 private:只允许在定义实体的封闭声明中访问 绝大部分实体默认都是internal 级别，不写就是internal 访问级别的使用准则 一个实体不可以被更低访问级别的实体定义，比如 下面的多种类型 变量\常量类型 ≥ 变量\常量 参数类型、返回值类型 ≥ 函数 父类 ≥ 子类 父协议 ≥ 子协议 原类型 ≥ typealias 原始值类型、关联值类型 ≥ 枚举类型 定义类型A时用到的其他类型 ≥ 类型A …… 因为 如果外部文件 使用 变量 / 实体；但是读取不到Person类型的定义，就会报错；同理 实体级别 &lt;= 类型定义 元组类型 元组类型的访问级别是所有成员类型最低的那个 123456internal struct Dog &#123;&#125;fileprivate class Person &#123;&#125;// (Dog, Person)的访问级别是fileprivate fileprivate var data1: (Dog, Person) private var data2: (Dog, Person) // 实体级别 &lt;= 类型定义 泛型类型 泛型类型的访问级别是 类型的访问级别 以及 所有泛型类型参数的访问级别 中最低的那个 123456internal class Car &#123;&#125;fileprivate class Dog &#123;&#125;public class Person&lt;T1, T2&gt; &#123;&#125;// Person&lt;Car, Dog&gt;的访问级别是fileprivate fileprivate var p = Person&lt;Car, Dog&gt;() // p的级别 要 &lt;= fileprivate 初始化器 如果一个public类想在另一个模块调用编译生成的默认无参初始化器，必须显式提供public的无参初始化器 因为public类的默认初始化器是internal级别 required初始化器 ≥ 它的默认访问级别 如果结构体有private\fileprivate的存储实例属性，那么它的成员初始化器也是private\fileprivate p否则默认就是internal 方法也可以像函数那样，赋值给一个let或者var 类型方法可以直接赋值 调用；结构体内的函数， 在内部引用了实例变量，其类型是(Person) -&gt; ((Int) -&gt; ()) 12345678910111213struct Person &#123; var age: Int func run(_ v: Int) &#123; print("func run", age, v) &#125; static func run(_ v: Int) &#123; print("static func run", v) &#125;&#125;let fn1 = Person.runfn1(10) // static func run 10let fn2: (Int) -&gt; () = Person.runfn2(20) // static func run 20let fn3: (Person) -&gt; ((Int) -&gt; ()) = Person.runfn3(Person(age: 18))(30) // func run 18 30]]></content>
      <categories>
        <category>iOS</category>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift-xmg14]]></title>
    <url>%2F2019%2F03%2F16%2FiOS%2Fswift-xmg14%2F</url>
    <content type="text"><![CDATA[高级运算符溢出运算符 Swift的算数运算符出现溢出时会抛出运行时错误 Swift有溢出运算符(&amp;+、&amp;-、&amp;*)，用来支持溢出运算 123456789var min = UInt8.minprint(min &amp;- 1) // 255, Int8.maxvar max = UInt8.maxprint(max &amp;+ 1) // 0, Int8.min print(max &amp;* 2) // 254, 等价于 max &amp;+ maxUInt8.min 0 ----逐渐递增-----&gt; UInt8.max 255 运算符重载 类、结构体、枚举可以为现有的运算符提供自定义的实现，这个操作叫做:运算符重载 如果函数内部改变外部变量的值，使用inout函数 123456789101112static func + (p1: Point, p2: Point) -&gt; Point &#123; Point(x: p1.x + p2.x, y: p1.y + p2.y)&#125;static func - (p1: Point, p2: Point) -&gt; Point &#123; Point(x: p1.x - p2.x, y: p1.y - p2.y) &#125;static prefix func - (p: Point) -&gt; Point &#123; Point(x: -p.x, y: -p.y)&#125;static func += (p1: inout Point, p2: Point) &#123; p1 = p1 + p2 &#125; prefix 前结合 ++p 先自增改变自身，再使用 postfix 后结合 p++ 先使用自身，再加1 123456789101112static prefix func ++ (p: inout Point) -&gt; Point &#123; p += Point(x: 1, y: 1) return p&#125;static postfix func ++ (p: inout Point) -&gt; Point &#123; let tmp = p p += Point(x: 1, y: 1) return tmp&#125;static func == (p1: Point, p2: Point) -&gt; Bool &#123; (p1.x == p2.x) &amp;&amp; (p1.y == p2.y)&#125; Equatable 协议 要想得知2个实例是否等价，一般做法是遵守Equatable 协议，重载== 运算符 与此同时，等价于重载了 != 运算符 Swift为以下类型提供默认的Equatable 实现 没有关联类型的枚举 只拥有遵守 Equatable 协议关联类型的枚举 只拥有遵守 Equatable 协议存储属性的结构体 1234567struct Point : Equatable &#123; var x: Int, y: Int&#125;var p1 = Point(x: 10, y: 20)var p2 = Point(x: 11, y: 22)print(p1 == p2) // falseprint(p1 != p2) // true 引用类型比较存储的地址值是否相等(是否引用着同一个对象)，使用恒等运算符=== 、!== 实现了 == 相当于同时实现了 !== 枚举 默认 原始值实现了Equatable协议 枚举 默认 关联值 不能实现了Equatable协议 === 三个等号 是判断 指针也相同，下面例子 返回的是false 自定义运算符 prefix operator +++ 以自定义新的运算符:在全局作用域使用operator进行声明 123prefix operator 前缀运算符postfix operator 后缀运算符infix operator 中缀运算符 : 优先级组 定义优先级组 1234567891011121314151617181920212223242526precedencegroup 优先级组 &#123; associativity: 结合性(left\right\none) higherThan: 比谁的优先级高 lowerThan: 比谁的优先级低 assignment: true 代表在可选链操作中拥有跟赋值运算符一样的优先级&#125;``` - 举例说明```swiftprefix operator +++infix operator +- : PlusMinusPrecedence precedencegroup PlusMinusPrecedence &#123; associativity: none higherThan: AdditionPrecedence lowerThan: MultiplicationPrecedence assignment: true&#125;assignment: true: 如果 有可选链的赋值运算符 =，有相同的优先级；struct Person &#123; var point: Point&#125;var person: Person? = nil person?.point +- Point(x: 10, y: 20) 扩展Extension 遵守协议 Extension 安全的数组取值 12345678extension Array &#123; subscript(nullable idx: Int) -&gt; Element? &#123; if (startIndex..&lt;endIndex).contains(idx) &#123; return self[idx] &#125; return nil &#125; &#125; 定义一个可选实现的协议，是在extension 协议提供默认实现 12345678910111213141516171819202122232425262728293031protocol TestProtocol &#123; func test1()&#125;extension TestProtocol &#123; func test1() &#123; print("TestProtocol test1") &#125; func test2() &#123; print("TestProtocol test2") &#125;&#125;// 遵守了协议，但是没有自身实现，调用的方法时，去找协议本身是否实现class TestClass : TestProtocol &#123;&#125; var cls = TestClass()cls.test1() // TestProtocol test1 cls.test2() // TestProtocol test2 var cls2: TestProtocol = TestClass() cls2.test1() // TestProtocol test1 cls2.test2() // TestProtocol test2// 本身类 实现了协议的方法，调用本身的方法实现；// 但是定义 cls2: TestProtocol 是协议类型；调用方法test1的时候 ，先调用本身对象的实现class TestClass1 : TestProtocol &#123; func test1() &#123; print("TestClass1 test1") &#125; func test2() &#123; print("TestClass1 test2") &#125;&#125;var cls = TestClass1()cls.test1() // TestClass test1 cls.test2() // TestClass test2var cls2: TestProtocol = TestClass1() cls2.test1() // TestClass test1 cls2.test2() // TestProtocol test2]]></content>
      <categories>
        <category>iOS</category>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift-xmg13]]></title>
    <url>%2F2019%2F03%2F15%2FiOS%2Fswift-xmg13%2F</url>
    <content type="text"><![CDATA[String 底层 1个String 占用多少内存 下面2个String变量，底层存储有什么不同？ 123var st1 = "0123456789"var st2 = "0123456789ABCDEF"var st3 = "0123456789ABCDEG" 如果对String 进行拼接操作，内存地址会有什么变化 1234st1.append("ABCDE")st1.append("F)st2.append("G") 内存分布特征 内存地址从低到高分布依次为：代码区 / 常量区 / 全局区 / 堆空间 / 栈空间 / 动态库 / OC/Swift源码 编译连接成 可执行文件 Mach-o文件，先夹在内存的低地址区；按需加载动态库文件 加载在内存的高地址区； String 分析1 String 占用内存长度16个字节； 当String长度小于15 的时候，String的内容加载在String的内存中。 12345678var str1 = "0123456789"prinnt(Menms.memStr(ofVal:&amp;str1))// 0x3736353433323130 0xea0000000003938前8个字节 大小端读3031323334353637 ASCII编码 对应 01234567 后8个字节 383900000000ea 其中对应3839 对应 89ea 中 e 字符串类型，标志位是存在本身内存中 还是指向常量区，还是指向对内存中ea 中 a 是代表字符串长度 是10 String 分析2 当字符串长度大于15时 16个字节，前8个字节存储字符串长度，后8个字节，存储是地址，指向实际值在常量区地址 找到实际值 需要加上 0x20，前32个字节存储字符串的相关信息 ，便宜32个字节才是字符串的真实值的地址 String 当字符串拼接内存分析3 字面量 拼接字符串，拼接后长度小于15 ，直接改变内存存储的值。 当拼接后 长度大于15 ，向堆内存中申请空间，因为常量区的内存编辑之后就不能修改，只能从堆空间中申请空间。 总结 String内存3种情况分析总结 符号绑定dyld_stub_binder 符号的延迟绑定通过dyld_stub_binder完成 jmpq *0xb31(%rip)格式的汇编指令 占用6个字节 lazy 加载，只加载一次；使用的时候再加载 调用String.init函数，去动态库加载。 下一步，调用dyld_stub_binder Arrary 底层 1个Array 变量占用多少内存； Array是结构体 但是只占8个字节，存储的是堆内存的地址 指向内存地址 存储的地址 前4*8个字节是数组信息，之后才是存储信息。 内存存储8个字节，取出8个字节存储内容 就是数组的堆内存存储信息]]></content>
      <categories>
        <category>iOS</category>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift-xmg12]]></title>
    <url>%2F2019%2F03%2F14%2FiOS%2Fswift-xmg12%2F</url>
    <content type="text"><![CDATA[补充 类型属性 staic var age ; 可以通过类型名Person调用，也可以通过Person.self调用的 12345// 下面都是调用init()方法var p0 = Person() // init var p1 = Person.self() // init var p2 = Person.init() // init var p3 = Person.self.init() // init 错误处理/ 异常处理 error 开发过程常见的错误 语法错误 逻辑错误 运行时错误（可能导致闪退，一般也叫做异常） 自定义错误信息 自定义错误 Swift中可以通过Error协议自定义运行时的错误信息 12345enum SomeError : Error &#123; case illegalArg(String) case outOfBounds(Int, Int) case outOfMemory&#125; 函数内部通过throw抛出自定义Error，可能会抛出Error的函数必须加上throws声明 123456func divide(_ num1: Int, _ num2: Int) throws -&gt; Int &#123; if num2 == 0 &#123; throw SomeError.illegalArg("0不能作为除数") &#125; return num1 / num2&#125; 需要使用try调用可能会抛出Error的函数 1var result = try divide(20, 10) do-catch 可以使用do-catch捕捉Error 1234567891011121314151617181920212223242526272829303132333435func test() &#123; print("1") do &#123; print("2") print(try divide(20, 0)) print("3") &#125; catch let SomeError.illegalArg(msg) &#123; print("参数异常:", msg) &#125; catch let SomeError.outOfBounds(size, index) &#123; print("下标越界:", "size=\(size)", "index=\(index)") &#125; catch SomeError.outOfMemory &#123; print("内存溢出") &#125; catch &#123; print("其他错误") &#125; print("4") &#125;``` - 抛出Error后，try下一句直到作用域结束的代码都将停止运行```swifttest()// 1// 2// 参数异常: 0不能作为除数 // 4do &#123; try divide(20, 0)&#125; catch let error &#123; switch error &#123; case let SomeError.illegalArg(msg): print("参数错误:", msg) default: print("其他错误") &#125; &#125; 处理Error 处理Error的2种方式 1 通过do-catch捕捉Error 2 不捕捉Error，在当前函数增加throws声明，Error将自动抛给上层函数 如果最顶层函数(main函数)依然没有捕捉Error，那么程序将终止 12345678910111213func test() throws &#123; print("1") print(try divide(20, 0)) print("2") &#125;try test() // 1 Fatal error: Error raised at top level// do catch 捕获do &#123; print(try divide(20, 0))&#125; catch is SomeError &#123; print("SomeError")&#125; try 遇到错误之后，直接返回不会继续处理后面的代码，如果需要处理 使用关键字defer 123456789101112131415func test() throws &#123; print("1") do &#123; print("2") print(try divide(20, 0)) print("3") &#125; catch let error as SomeError &#123; print(error) &#125; print("4") &#125;try test()// 1// 2// illegalArg("0不能作为除数") // 4 rethrows rethrows表明:函数本身不会抛出错误，但调用闭包参数抛出错误，那么它会将错误向上抛 12345func exec(_ fn: (Int, Int) throws -&gt; Int, _ num1: Int, _ num2: Int) rethrows &#123; print(try fn(num1, num2))&#125;// Fatal error: Error raised at top leveltry exec(divide, 20, 0) defer defer语句:用来定义以任何方式(抛错误、return等)离开代码块前必须要执行的代码 defer语句将延迟至当前作用域结束之前执行 1234567func open(_ filename: String) -&gt; Int &#123; print("open") return 0 &#125;func close(_ file: Int) &#123; print("close")&#125; defer语句的执行顺序与定义顺序相反 123456789func fn1() &#123; print("fn1") &#125;func fn2() &#123; print("fn2") &#125;func test() &#123; defer &#123; fn1() &#125; defer &#123; fn2() &#125;&#125;test()// fn2// fn1 defer 出错继续执行，讲代码 放在代码作用域结束之前 调用。 1234567891011121314func processFile(_ filename: String) throws &#123; let file = open(filename) defer &#123; close(file) &#125; // 使用file // .... try divide(20, 0) // close将会在这里调用 &#125;try processFile("test.txt")// open// close// Fatal error: Error raised at top level assert(断言) 很多编程语言都有断言机制:不符合指定条件就抛出运行时错误，常用于调试(Debug)阶段的条件判断 默认情况下，Swift的断言只会在Debug模式下生效，Release模式下会忽略 12345678910111213141516171819202122232425262728293031323334func divide(_ v1: Int, _ v2: Int) -&gt; Int &#123; assert(v2 != 0, "除数不能为0") return v1 / v2&#125;print(divide(20, 0))``` - 增加Swift Flags修改断言的默认行为 - `-assert-config Release`:强制关闭断言 - `-assert-config Debug`:强制开启断言![屏幕快照 2019-08-01 下午5.46.16](/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-08-01%20%E4%B8%8B%E5%8D%885.46.16.png)### 泛型- 类 / 结构体 范型```swiftclass Stack&lt;E&gt; &#123; var elements = [E]() func push(_ element: E) &#123; elements.append(element) &#125; func pop() -&gt; E &#123; elements.removeLast() &#125; func top() -&gt; E &#123; elements.last! &#125; func size() -&gt; Int &#123; elements.count &#125;&#125;struct Stack&lt;E&gt; &#123; var elements = [E]() mutating func push(_ element: E) &#123; elements.append(element) &#125; mutating func pop() -&gt; E &#123; elements.removeLast() &#125; func top() -&gt; E &#123; elements.last! &#125; func size() -&gt; Int &#123; elements.count &#125;&#125; 使用 1234567891011class SubStack&lt;E&gt; : Stack&lt;E&gt; &#123;&#125;var stack = Stack&lt;Int&gt;()stack.push(11)stack.push(22)stack.push(33)print(stack.top()) // 33print(stack.pop()) // 33print(stack.pop()) // 22print(stack.pop()) // 11print(stack.size()) // 0 枚举的一个枚举值是范型 123456enum Score&lt;T&gt; &#123; case point(T) case grade(String)&#125;let score0 = Score&lt;Int&gt;.point(100) let score1 = Score.point(99)let score2 = Score.point(99.5) let score3 = Score&lt;Int&gt;.grade("A") 关联类型(Associated Type) 关联类型的作用:给协议中用到的类型定义一个占位名称 协议中可以拥有多个关联类型 1234567protocol Stackable &#123; associatedtype Element // 关联类型 mutating func push(_ element: Element) mutating func pop() -&gt; Element func top() -&gt; Element func size() -&gt; Int&#125; 给关联类型设定真实类型 typealias Element = String 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Stack&lt;E&gt; : Stackable &#123; // typealias Element = E var elements = [E]() func push(_ element: E) &#123; elements.append(element) &#125; func pop() -&gt; E &#123; elements.removeLast() &#125; func top() -&gt; E &#123; elements.last! &#125; func size() -&gt; Int &#123; elements.count &#125;&#125;class StringStack : Stackable &#123; // 给关联类型设定真实类型 // typealias Element = String var elements = [String]() func push(_ element: String) &#123; elements.append(element) &#125; func pop() -&gt; String &#123; elements.removeLast() &#125; func top() -&gt; String &#123; elements.last! &#125; func size() -&gt; Int &#123; elements.count &#125; &#125;var ss = StringStack()ss.push("Jack")ss.push("Rose")``` ### 类型约束 - 底层 以Swipe函数举例，传入了元类型matatype ；如果传入了Int, 即传入了Int.self 前8个字节，类型。 ```swift// Runnable 协议 定义一个函数，是Person类 并且遵守 Runnable 协议protocol Runnable &#123; &#125;class Person &#123; &#125;func swapValues&lt;T : Person &amp; Runnable&gt;(_ a: inout T, _ b: inout T) &#123; (a, b) = (b, a)&#125;// 定义一个类 是范型，并且遵守 Stackable协议，Stackable 关联类型且 遵守Equatable协议protocol Stackable &#123; associatedtype Element: Equatable&#125;class Stack&lt;E : Equatable&gt; : Stackable &#123; typealias Element = E &#125;// 定义函数 s1，s2范型参数遵守Stackable协议，s1,s2的关联类型相同，并且此类型遵守Hashable；func equal&lt;S1: Stackable, S2: Stackable&gt;(_ s1: S1, _ s2: S2) -&gt; Bool where S1.Element == S2.Element, S1.Element : Hashable &#123; return false&#125;var stack1 = Stack&lt;Int&gt;()var stack2 = Stack&lt;String&gt;()// error: requires the types 'Int' and 'String' be equivalent 编译报错，需要类型相同equal(stack1, stack2) 协议类型的注意点12345678910111213protocol Runnable &#123;&#125;class Person : Runnable &#123;&#125;class Car : Runnable &#123;&#125;func get(_ type: Int) -&gt; Runnable &#123; if type == 0 &#123; return Person() &#125; return Car()&#125;var r1 = get(0)var r2 = get(1) 如果协议中有associatedtype 12345678910protocol Runnable &#123; associatedtype Speed var speed: Speed &#123; get &#125;&#125;class Person : Runnable &#123; var speed: Double &#123; 0.0 &#125;&#125;class Car : Runnable &#123; var speed: Int &#123; 0 &#125;&#125; 泛型解决在使用的中编译报错 12345678func get&lt;T : Runnable&gt;(_ type: Int) -&gt; T &#123; if type == 0 &#123; return Person() as! T &#125; return Car() as! T&#125;var r1: Person = get(0)var r2: Car = get(1) 解决方案2:使用some关键字声明一个不透明类型(Opaque Type) 123func get(_ type: Int) -&gt; some Runnable &#123; Car() &#125;var r1 = get(0)var r2 = get(1) some限制只能返回一种类型 123456func get(_ type: Int) -&gt; some Runnable &#123; if type == 0 &#123; return Person() &#125; return Car()&#125; some some除了用在返回值类型上，一般还可以用在属性类型上 1234567protocol Runnable &#123; associatedtype Speed &#125;class Dog : Runnable &#123; typealias Speed = Double &#125;class Person &#123; var pet: some Runnable &#123; return Dog() &#125; &#125; 可选类型的本质是枚举enum 可选类型 本质是有关联值的枚举]]></content>
      <categories>
        <category>iOS</category>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift-xmg11]]></title>
    <url>%2F2019%2F03%2F13%2FiOS%2Fswift-xmg11%2F</url>
    <content type="text"><![CDATA[可选链(Optional Chaining) 如果可选项为nil，调用方法、下标、属性失败，结果为nil 如果可选项不为nil，调用方法、下标、属性成功，结果会被包装成可选项 如果结果本来就是可选项，不会进行再次包装 12345678910111213141516171819class Car &#123; var price = 0 &#125; class Dog &#123; var weight = 0 &#125; class Person &#123; var name: String = "" var dog: Dog = Dog() var car: Car? = Car() func age() -&gt; Int &#123; 18 &#125; func eat() &#123; print("Person eat") &#125; subscript(index: Int) -&gt; Int &#123; index &#125;&#125;var person: Person? = Person() var age1 = person!.age() // Int var age2 = person?.age() // Int? var name = person?.name // String? var index = person?[6] // Int?func getName() -&gt; String &#123; "jack" &#125; // 如果person是nil，不会调用getName() person?.name = getName() 多个?可以链接在一起 如果链中任何一个节点是nil，那么整个链就会调用失败 123456789if let _ = person?.eat() &#123; // ()? print("eat调用成功")&#125; else &#123; print("eat调用失败")&#125;var dog = person?.dog // Dog?var weight = person?.dog.weight // Int? var price = person?.car?.price // Int? 字典 / 数组 取值可选项 12345678910111213141516var scores = ["Jack": [86, 82, 84], "Rose": [79, 94, 81]]scores["Jack"]?[0] = 100scores["Rose"]?[2] += 10scores["Kate"]?[0] = 88var num1: Int? = 5num1? = 10 // Optional(10)var num2: Int? = nilnum2? = 10 // nilvar dict: [String : (Int, Int) -&gt; Int] = [ "sum" : (+), "difference" : (-)]var result = dict["sum"]?(10, 20) // Optional(30), Int? 协议(Protocol) 协议可以用来定义方法、属性、下标的声明，协议可以被枚举、结构体、类遵守(多个协议之间用逗号隔开) 123456 protocol Drawable &#123; func draw() var x: Int &#123; get set &#125; var y: Int &#123; get &#125; subscript(index: Int) -&gt; Int &#123; get set &#125;&#125; 协议中定义方法时不能有默认参数值 默认情况下，协议中定义的内容必须全部都实现 也有办法办到只实现部分内容，以后的课程会讲到 1234protocol Test1 &#123; &#125;protocol Test2 &#123; &#125;protocol Test3 &#123; &#125;class TestClass : Test1, Test2, Test3 &#123; &#125; 协议中的属性123456protocol Drawable &#123; func draw() var x: Int &#123; get set &#125; var y: Int &#123; get &#125; subscript(index: Int) -&gt; Int &#123; get set &#125;&#125; 协议中定义属性时必须用var关键字 实现协议时的属性权限要不小于协议中定义的属性权限 协议定义get、set，用var存储属性或get、set计算属性去实现 协议定义get，用任何属性都可以实现 12345678910111213141516171819202122232425262728293031323334353637383940class Person : Drawable &#123; var x: Int = 0 let y: Int = 0 func draw() &#123; print("Person draw") &#125; subscript(index: Int) -&gt; Int &#123; set &#123; &#125; get &#123; index &#125; &#125;&#125;class Person : Drawable &#123; var x: Int &#123; get &#123; 0 &#125; set &#123; &#125; &#125; var y: Int &#123; 0 &#125; func draw() &#123; print("Person draw") &#125; subscript(index: Int) -&gt; Int &#123; set &#123; &#125; get &#123; index &#125; &#125;&#125;``` ### static、class - 为了保证通用，协议中必须用static定义类型方法、类型属性、类型下标```swfitprotocol Drawable &#123; static func draw()&#125;class Person1 : Drawable &#123; class func draw() &#123; print("Person1 draw") &#125;&#125;class Person2 : Drawable &#123; static func draw() &#123; print("Person2 draw") &#125;&#125; mutating 只有将协议中的实例方法标记为mutating 才允许结构体、枚举的具体实现修改自身内存 类在实现方法时不用加mutating，枚举、结构体才需要加mutating 如果协议方法前不加mutating，枚举/结构体 实现该方法不能加mutating 1234567891011121314151617protocol Drawable &#123; mutating func draw()&#125;class Size : Drawable &#123; var width: Int = 0 func draw() &#123; width = 10 &#125;&#125;struct Point : Drawable &#123; var x: Int = 0 mutating func draw() &#123; x = 10 &#125; &#125; CaseIterable 让枚举遵守CaseIterable协议，可以实现遍历枚举值 12345678910111213141516171819202122232425262728293031enum Season : CaseIterable &#123; case spring, summer, autumn, winter&#125;let seasons = Season.allCasesprint(seasons.count) // 4for season in seasons &#123; print(season)&#125; // spring summer autumn winter``` ### CustomStringConvertible - 遵守CustomStringConvertible、 CustomDebugStringConvertible协议，都可以自定义实例的打印字符串- print调用的是CustomStringConvertible协议的description- debugPrint、po调用的是CustomDebugStringConvertible协议的debugDescription ```swiftclass Person : CustomStringConvertible,CustomDebugStringConvertible &#123; var age: Int var name: String init(age: Int, name: String) &#123; self.age = age self.name = name &#125; var description: String &#123; "age=\(age), name=\(name)" &#125; var debugDescription: String &#123; "debug_person_\(age)" &#125; &#125;var p = Person(age: 10, name: "Jack")print(p) // age=10, name=JackdebugPrint(person) // debug_person_0 Any、AnyObject Swift提供了2种特殊的类型:Any、AnyObject Any:可以代表任意类型(枚举、结构体、类，也包括函数类型) AnyObject:可以代表任意类类型(在协议后面写上: AnyObject代表只有类能遵守这个协议)/ 只能用于类 123456789101112var stu: Any = 10stu = "Jack"stu = Student()// 创建1个能存放任意类型的数组 // var data = Array&lt;Any&gt;() var data = [Any]() data.append(1) data.append(3.14)data.append(Student()) data.append("Jack") data.append(&#123; 10 &#125;) is、as?、as!、as is用来判断是否为某种类型，as用来做强制类型转换 as Any 因为是必定成功的，所以不用as? as! 12345678910111213141516171819202122232425262728293031protocol Runnable &#123; func run() &#125; class Person &#123; &#125;class Student : Person, Runnable &#123; func run() &#123; print("Student run") &#125; func study() &#123; print("Student study") &#125;&#125;var stu: Any = 10print(stu is Int) // truestu = "Jack"print(stu is String) // true stu = Student()print(stu is Person) // true print(stu is Student) // true print(stu is Runnable) // truevar stu: Any = 10(stu as? Student)?.study() // 没有调用study stu = Student()(stu as? Student)?.study() // Student study (stu as! Student).study() // Student study (stu as? Runnable)?.run() // Student runvar data = [Any]() data.append(Int("123") as Any)var d = 10 as Doubleprint(d) // 10.0 X.self、X.Type、AnyClass X.self是一个元类型(metadata)的指针，metadata存放着类型相关信息 X.self属于X.Type类型 如果是类，类前面8个字节就是类型信息，每个类都有一个类型信息，隐藏的基类：Swift._SwiftObject 1234567891011121314151617class Person &#123; &#125;class Student : Person &#123; &#125;var perType: Person.Type = Person.self var stuType: Student.Type = Student.self perType = Student.selfvar anyType: AnyObject.Type = Person.self anyType = Student.selfpublic typealias AnyClass = AnyObject.Type var anyType2: AnyClass = Person.selfanyType2 = Student.selfvar per = Person()var perType = type(of: per) // Person.self print(Person.self == type(of: per)) // true 元类型的应用123456789101112131415class Animal &#123; required init() &#123; &#125; &#125; class Cat : Animal &#123; &#125;class Dog : Animal &#123; &#125;class Pig : Animal &#123; &#125;func create(_ clses: [Animal.Type]) -&gt; [Animal] &#123; var arr = [Animal]() for cls in clses &#123; arr.append(cls.init()) &#125; return arr &#125;print(create([Cat.self, Dog.self, Pig.self])) Self Self一般用作返回值类型，限定返回值跟方法调用者必须是同一类型(也可以作为参数类型) 12345678910111213141516171819protocol Runnable &#123; func test() -&gt; Self&#125;class Person : Runnable &#123; required init() &#123; &#125; func test() -&gt; Self &#123; type(of: self).init() &#125; &#125;class Student : Person &#123; &#125;var p = Person()// Personprint(p.test())var stu = Student()// Studentprint(stu.test())]]></content>
      <categories>
        <category>iOS</category>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift-xmg10]]></title>
    <url>%2F2019%2F03%2F12%2FiOS%2Fswift-xmg10%2F</url>
    <content type="text"><![CDATA[初始化器 类、结构体、枚举都可以定义初始化器 类有2种初始化器:指定初始化器(designated initializer)、便捷初始化器(convenience initializer) 每个类至少有一个指定初始化器，指定初始化器是类的主要初始化器 n 默认初始化器总是类的指定初始化器 类偏向于少量指定初始化器，一个类通常只有一个指定初始化器 初始化器的相互调用规则 指定初始化器必须从它的直系父类调用指定初始化器 便捷初始化器必须从相同的类里调用另一个初始化器 便捷初始化器最终必须调用一个指定初始化器 12345678// 指定初始化器 init(parameters) &#123; statements &#125;// 便捷初始化器convenience init(parameters) &#123; statements &#125; 两段式初始化 Swift在编码安全方面是煞费苦心，为了保证初始化过程的安全，设定了两段式初始化、 安全检查 两段式初始化 第1阶段:初始化所有存储属性 外层调用指定\便捷初始化器 分配内存给实例，但未初始化 指定初始化器确保当前类定义的存储属性都初始化 指定初始化器调用父类的初始化器，不断向上调用，形成初始化器链 第2阶段:设置新的存储属性值 从顶部初始化器往下，链中的每一个指定初始化器都有机会进一步定制实例 初始化器现在能够使用self(访问、修改它的属性，调用它的实例方法等等) 3 最终，链中任何便捷初始化器都有机会定制实例以及使用self 安全检查 指定初始化器必须保证在调用父类初始化器之前，其所在类定义的所有存储属性都要初始化完成_ 指定初始化器必须先调用父类初始化器，然后才能为继承的属性设置新值 便捷初始化器必须先调用同类中的其它初始化器，然后再为任意属性设置新值 初始化器在第1阶段初始化完成之前，不能调用任何实例方法、不能读取任何实例属性的值，也不能引用self 直到第1阶段结束，实例才算完全合法 重写 当重写父类的指定初始化器时，必须加上override(即使子类的实现是便捷初始化器) 如果子类写了一个匹配父类便捷初始化器的初始化器，不用加上override 因为父类的便捷初始化器永远不会通过子类直接调用，因此，严格来说，子类无法重写父类的便捷初始化器 自动继承 1 如果子类没有自定义任何指定初始化器，它会自动继承父类所有的指定初始化器 2 如果子类提供了父类所有指定初始化器的实现(要么通过方式1继承，要么重写) 子类自动继承所有的父类便捷初始化器 3 就算子类添加了更多的便捷初始化器，这些规则仍然适用 4 子类以便捷初始化器的形式重写父类的指定初始化器，也可以作为满足规则2的一部分 required 用required修饰指定初始化器，表明其所有子类都必须实现该初始化器(通过继承或者重写实现) 如果子类重写了required初始化器，也必须加上required，不用加override 123456789class Person &#123; required init() &#123; &#125; init(age: Int) &#123; &#125;&#125;class Student : Person &#123; required init() &#123; super.init() &#125;&#125; 父类的属性在它自己的初始化器中赋值不会触发属性观察器，但在子类的初始化器中赋值会触发属性观察器 1234567891011121314151617181920212223class Person &#123; var age: Int &#123; willSet &#123; print("willSet", newValue) &#125; didSet &#123; print("didSet", oldValue, age) &#125; &#125; init() &#123; self.age = 0 &#125;&#125;class Student : Person &#123; override init() &#123; super.init() self.age = 1 &#125;&#125;// willSet 1// didSet 0 1var stu = Student() 可失败初始化器 类、结构体、枚举都可以使用init?定义可失败初始化器 123456789class Person &#123; var name: String init?(name: String) &#123; if name.isEmpty &#123; return nil &#125; self.name = name &#125;&#125; 之前接触过的可失败初始化器 1234567var num = Int("123")public init?(_ description: String)enum Answer : Int &#123; case wrong, right&#125;var an = Answer(rawValue: 1)// options 不允许同时定义参数标签、参数个数、参数类型相同的可失败初始化器和非可失败初始化器 可以用init!定义隐式解包的可失败初始化器 可失败初始化器可以调用非可失败初始化器，非可失败初始化器调用可失败初始化器需要进行解包 如果初始化器调用一个可失败初始化器导致初始化失败，那么整个初始化过程都失败，并且之后的代码都停止执行 可以用一个非可失败初始化器重写一个可失败初始化器，但反过来是不行的 反初始化器(deinit) deinit叫做反初始化器，类似于C++的析构函数、OC中的dealloc方法 当类的实例对象被释放内存时，就会调用实例对象的deinit方法 123456789101112131415class Person &#123; deinit &#123; print("Person对象销毁了") &#125;&#125;class Student:Person &#123; deinit &#123; print("Student对象销毁了") &#125;&#125;func test()&#123; var p1 = Person() var s1 = Student()&#125;test() // 函数执行完成之后回释放局部变量 deinit不接受任何参数，不能写小括号，不能自行调用 父类的deinit能被子类继承 子类的deinit实现执行完毕后会调用父类的deinit]]></content>
      <categories>
        <category>iOS</category>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift-xmg09]]></title>
    <url>%2F2019%2F03%2F11%2FiOS%2Fswift-xmg09%2F</url>
    <content type="text"><![CDATA[方法 实例方法 通过实例对象调用 类方法 通过类型调用，用static/class 调用mutating 结构体/枚举 是值类型，默认情况下，值类型的属性不能被自身的实例方法修改，用mutating关键字修饰，允许修改。 1234567struct Point &#123; var x = 0.0, y = 0.0 mutating func moveBy(deltaX: Double, deltaY: Double) &#123; x += deltaX y += deltaY // self = Point(x: x + deltaX, y: y + deltaY)&#125; &#125; 在func前面加个@discardableResult，可以消除:函数调用后返回值未被使用的警告 1234567891011121314struct Point &#123; var x = 0.0, y = 0.0 @discardableResult mutating func moveX(deltaX: Double) -&gt; Double &#123; x += deltaX return x &#125;&#125;@discardableResultfunc get() -&gt; Int &#123; return 10 &#125;get() 下标 使用subscript可以给任意类型(枚举、结构体、类)增加下标功能，有些地方也翻译为:下标脚本 subscript的语法类似于实例方法、计算属性，本质就是方法(函数) 123456789101112131415161718192021222324252627class Point &#123; var x = 0.0, y = 0.0 subscript(index: Int) -&gt; Double &#123; set &#123; if index == 0 &#123; x = newValue &#125; else if index == 1 &#123; y = newValue &#125; &#125; get &#123; if index == 0 &#123; return x &#125; else if index == 1 &#123; return y &#125; return 0 &#125; &#125; &#125;var p = Point()p[0] = 11.1p[1] = 22.2print(p.x) // 11.1print(p.y) // 22.2print(p[0]) // 11.1print(p[1]) // 22.2 subscript中定义的返回值类型决定了 get方法的返回值类型 set方法中newValue的类型 subscript可以接受多个参数，并且类型任意 subcript() 可以没有set,但必须要有get方法 subscript 可以是对象方法，也可以是类型方法（static subscript） 接收多个参数的下标 1234567891011121314151617181920212223242526class Grid &#123; var data = [ [0, 1, 2], [3, 4, 5], [6, 7, 8] ] subscript(row: Int, column: Int) -&gt; Int &#123; set &#123; guard row &gt;= 0 &amp;&amp; row &lt; 3 &amp;&amp; column &gt;= 0 &amp;&amp; column &lt; 3 else &#123; return &#125; data[row][column] = newValue &#125; get &#123; guard row &gt;= 0 &amp;&amp; row &lt; 3 &amp;&amp; column &gt;= 0 &amp;&amp; column &lt; 3 else &#123; return 0 &#125; return data[row][column] &#125; &#125; &#125;var grid = Grid()grid[0, 1] = 77grid[1, 2] = 88grid[2, 0] = 99print(grid.data) 继承 值类型(枚举、结构体)不支持继承，只有类支持继承 没有父类的类，称为:基类 / Swift并没有像OC、Java那样的规定:任何类最终都要继承自某个基类 子类可以重写父类的下标、方法、属性，重写必须加上override关键字 继承的额内存结构 继承是把父类的变量，在子类中都保存一份 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Animal &#123; var age = 0&#125;class Dog : Animal &#123; var weight = 0&#125;class ErHa : Dog &#123; var iq = 0&#125;let a = Animal()a.age = 10 print(Mems.size(ofRef: a)) // 32 /* 0x00000001000073e0 0x0000000000000002 0x000000000000000a 0x0000000000000000 */let d = Dog()d.age = 10d.weight = 20print(Mems.size(ofRef: d)) // 32 /* 0x0000000100007490 0x0000000000000002 0x000000000000000a 0x0000000000000014 */let e = ErHa()e.age = 10e.weight = 20e.iq = 30print(Mems.size(ofRef: e)) // 48 /* 0x0000000100007560 0x0000000000000002 0x000000000000000a 0x0000000000000014 0x000000000000001e 0x0000000000000000 */ 重写实例方法/下标 override 关键字，子类方法中调用父类方法用 super 123456789class Cat : Animal &#123; override func speak() &#123; super.speak() print("Cat speak") &#125; override subscript(index: Int) -&gt; Int &#123; return super[index] + 1 &#125; &#125; class修饰的类型方法、下标，允许被子类重写 被static修饰的类型方法、下标，不允许被子类重写 重写实例属性/类型属性 子类可以将父类的属性(存储、计算)重写为计算属性 子类不可以将父类属性重写为存储属性 只能重写var属性，不能重写let属性 重写时，属性名、类型要一致 子类重写后的属性权限 不能小于 父类属性的权限 - 如果父类属性是只读的，那么子类重写后的属性可以是只读的、也可以是可读写的 如果父类属性是可读写的，那么子类重写后的属性也必须是可读写的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Circle &#123; var radius: Int = 0 var diameter: Int &#123; set &#123; print("Circle setDiameter") radius = newValue / 2 &#125; get &#123; print("Circle getDiameter") return radius * 2 &#125; &#125; &#125;class SubCircle : Circle &#123; override var radius: Int &#123; set &#123; print("SubCircle setRadius") super.radius = newValue &gt; 0 ? newValue : 0 &#125; get &#123; print("SubCircle getRadius") return super.radius &#125; &#125; override var diameter: Int &#123; set &#123; print("SubCircle setDiameter") super.diameter = newValue &gt; 0 ? newValue : 0 &#125; get &#123; print("SubCircle getDiameter") return super.diameter &#125; &#125; &#125;&#125; &#125;circle = SubCircle()// SubCircle setRadiuscircle.radius = 6// SubCircle getDiameter // Circle getDiameter // SubCircle getRadius // 12 print(circle.diameter)// SubCircle setDiameter// Circle setDiameter// SubCircle setRadiuscircle.diameter = 20// SubCircle getRadius// 10print(circle.radius) 重写属性观察器 可以在子类中为父类属性(除了只读计算属性、let属性)增加属性观察器 12345678910111213141516171819202122232425262728class Circle &#123; var radius: Int = 1 &#123; willSet &#123; print("Circle willSetRadius", newValue) &#125; didSet &#123; print("Circle didSetRadius", oldValue, radius) &#125; &#125; &#125;class SubCircle : Circle &#123; override var radius: Int &#123; willSet &#123; print("SubCircle willSetRadius", newValue) &#125; didSet &#123; print("SubCircle didSetRadius", oldValue, radius) &#125; &#125; &#125;var circle = SubCircle()circle.radius = 10// SubCircle willSetRadius 10 // Circle willSetRadius 10// Circle didSetRadius 1 10 // SubCircle didSetRadius 1 10 重写计算属性的属性观察器 先调用oldvalue super.get -&gt; willset-&gt; super.set -&gt; didset(中有radius)之前调用 super.get 1234567891011121314151617181920212223242526272829class Circle &#123; var radius: Int &#123; set &#123; print("Circle setRadius", newValue) &#125; get &#123; print("Circle getRadius") return 20 &#125; &#125; &#125;class SubCircle : Circle &#123; override var radius: Int &#123; willSet &#123; print("SubCircle willSetRadius", newValue) &#125; didSet &#123; print("SubCircle didSetRadius", oldValue, radius) &#125; &#125; &#125;var circle = SubCircle()circle.radius = 10// Circle getRadius// SubCircle willSetRadius 10 // Circle setRadius 10// Circle getRadius// SubCircle didSetRadius 20 20 final 被final修饰的方法、下标、属性，禁止被重写 被final修饰的类，禁止被继承]]></content>
      <categories>
        <category>iOS</category>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift-xmg08]]></title>
    <url>%2F2019%2F03%2F10%2FiOS%2Fswift-xmg08%2F</url>
    <content type="text"><![CDATA[属性存储属性 在创建类和结构体时b必须为所有的存储属性设置一个合适的初始化值。 可以在初始化器为存储属性设置一个初始值 也可以在定义存储属性的时候给定默认值 类似成员变量这个概念 存储在实例的内存中 结构体。类中可以定义存储属性，枚举中不能定义存储属性计算属性 本质时函数/方法 不占用实例的内存 枚举，结构体，类都可以定义计算属性 计算属性 实现set /get 方法 存储属性只能用var,不能用let 因为 let代表常量，值时不变的，但是计算属性的值时可能发生变换的 只读计算属性，只有get,没有set 12345678910struct Circle &#123; var radius: Double var diameter: Double &#123; set(newDiameter) &#123; radius = newDiameter / 2 &#125; get &#123; radius * 2 &#125; &#125;&#125; 枚举rawValue原理 枚举原始值rawValue的本质是:只读计算属性 12345678910111213enum TestEnum : Int &#123; case test1 = 1, test2 = 2, test3 = 3 var rawValue: Int &#123; switch self &#123; case .test1: return 10 case .test2: return 11 case .test3: return 12 &#125; &#125; &#125; 延迟加载属性 lazy 使用lazy可以定义一个延迟存储属性，在第一次用到属性的时候才会进行初始化 lazy属性必须是var，不能是let let必须在实例的初始化方法完成之前就拥有值 如果多条线程同时第一次访问lazy属性 无法保证属性只被初始化1次 当结构体包含一个延迟存储属性时，只有var才能访问延迟存储属性 因为延迟属性初始化时需要改变结构体的内存 属性观察袭 willSet / didSet willSet会传递新值，默认叫newValue didSet会传递旧值，默认叫oldValue 在初始化器中设置属性值不会触发willSet和didSet 在属性定义时设置初始值也不会触发willSet和didSet inout 再次研究传入地址值，但传入谁的地址值是有区别。 存储属性， 无willset / didset等的直接传入地址，改掉 有willset / didset的将变量的值，存储到局部变量的值，传入test 函数，在函数内改变地址中数值，再将局部变量调用 willset /didset 来改变变量的值， 计算属性，作为inout传入参数 先调用get 方法，返回一个局部变量地址值 将局部变量地址值 传入函数 将函数的内的计算结果 存入局部变量地址 调用set 方法，将局部变量值 引入 ，执行set函数 inout 本质 如果实参有物理内存地址，且没有设置属性观察器 p 直接将实参的内存地址传入函数(实参进行引用传递) 如果实参是计算属性 或者 设置了属性观察器 采取了Copy In Copy Out的做法 调用该函数时，先复制实参的值，产生副本【get】 将副本的内存地址传入函数(副本进行引用传递)，在函数内部可以修改副本的值 函数返回后，再将副本的值覆盖实参的值【set】 总结:inout的本质就是引用传递(地址传递) 类型属性 可以通过static 定义类型属性 如果时累，也可以使用class 关键字 类型属性细节 不同于存储实例属性，你必须给存储类型属性设定初始值 因为类型没有像实例那样的init初始化器来初始化存储属性 存储类型属性默认就是lazy，会在第一次使用的时候才初始化 就算被多个线程同时访问，保证只会初始化一次 存储类型属性可以是let 枚举类型也可以定义类型属性(存储类型属性、计算类型属性) 单例模式 123456789101112 public class FileManager &#123; public static let shared = FileManager() private init() &#123; &#125;&#125;public class FileManager &#123; public static let shared = &#123; // .... // .... return FileManager() &#125;() private init() &#123; &#125;&#125;]]></content>
      <categories>
        <category>iOS</category>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift-xmg07]]></title>
    <url>%2F2019%2F03%2F09%2FiOS%2Fswift-xmg07%2F</url>
    <content type="text"><![CDATA[分析函闭包表达式的内存布局下面的函数 fn = getFn() fn 此时的内存布局12345678910111213func getFn()-&gt;Int-&gt;Int&#123; var num = 0 fun plus(_ i:Int)&#123; num += i return num &#125; return plus&#125;var fn = getFn() fn(1) // 1 fn(2) // 3 fn(3) // 6 fn(4) // 10 fn 变量 16个字节 前八个字节 是存储找到 plus 地址。后八个字节存储的是堆空间内存地址 前8个字节 存储的是函数地址 后八个字节是申请的堆内存地址，var num = 0 申请了24个字节，8个存储地址信息，再8个存储引用计数，再8字节存储Int类型的1，如果堆空间的地址值是adr,那adr + 0x10 就是number的地址值 执行fn(1)汇编 rax，rdx 是getFn() 的返回值， mov $0x1,%edi 讲参数 1 赋值给edi call *%rax 间接调用存储的plus函数,取出 rax 存储的函数地址，调用函数。 plus函数，实际传入了2个参数，一个是1，一个是堆内存的地址值。 当执行num += i 的时候，先取出num的值0x10(%rdx) 汇编指令： add 0x10(%rdx),%rcx | movq %rcx,(%rax) num 开辟 堆内存的时机？ 在调用getFn() 中 return plus 函数之前。 如果num 是全局变量，plus 中的不再申请堆内存空间。不需要捕获，不是闭包。 分配堆空间的目的是 延长生命周期。 分析下面函数的内存 函数返回一个元祖，2个函数，每个函数都引用了num1,num2 123456789101112131415161718192021typealias Fn = (Int) -&gt; (Int, Int) func getFns() -&gt; (Fn, Fn) &#123; var num1 = 0 var num2 = 0 func plus(_ i: Int) -&gt; (Int, Int) &#123; num1 += i num2 += i &lt;&lt; 1 return (num1, num2) &#125; func minus(_ i: Int) -&gt; (Int, Int) &#123; num1 -= i num2 -= i &lt;&lt; 1 return (num1, num2) &#125; return (plus, minus)&#125;let (p, m) = getFns()p(5) // (5, 10)m(4) // (1, 2)p(3) // (4, 8)m(2) // (2, 4) 调用一次getFns，只分配一次堆空间 num1,num2, plus 和 minus 共用。 但 不是num1 num2公用一个堆空间，（不是占用 8 + 8 + 2*8 = 32字节）； 是num1独自占一块内存24个字节，num2独自占用24个字节。 相当于 一个对象的2个引用类型变量，独自的指针类型，和引用计数。 2次alloc，分别申请numb1的内存，numb2 的内存 自动闭包 @autoclosure 为了避免与期望冲突，使用了@autoclosure的地方最好明确注释清楚:这个值会被推迟执行 @autoclosure 会自动将 20 封装成闭包 { 20 } @autoclosure 只支持 () -&gt; T 格式的参数 n@autoclosure 并非只支持最后1个参数 空合并运算符 ?? 使用了 @autoclosure 技术 有@autoclosure、无@autoclosure，构成了函数重载]]></content>
      <categories>
        <category>iOS</category>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift-xmg06]]></title>
    <url>%2F2019%2F03%2F08%2FiOS%2Fswift-xmg06%2F</url>
    <content type="text"><![CDATA[引用类型的赋值操作 栈空间 / 堆空间值类型。引用类型的let 值类型如果定义为let, 值类型的对象不能修改，其成员变量也不能修改 引用类型如果定义为let, 引用类型对象不能修改，其堆区的成员变量可以修改 内存不能修改，值类型内存不能修改，引用类型 对象指针所在的内存不能修改 string 结构体 let 定义为不能修改append Arrary let 定义不能修改数组中的每一个值对象在堆中是申请过程 Class.__allocating_init() _swift_allocObject swift_slowAlloc malloc 在mac 和iOS 中malloc 函数申请的内存 是16的倍数 通过class_getInstanceSize可以得知，类对象至少需要占用多少内存123456789class Point&#123; var x = 11 var y = 12 var flag = false&#125;// 33 40 48 1.实际占用的大小是 8(x) + 8(y) + 1(flag) + 8(指针类型) + 8(引用计数) = 33个2.但是因为内存8对齐，需要 8 *5 = 40个 最少需要40个3.又因为malloc申请的内存需要16的倍数，40 =&gt; 3*16 = 48个 嵌套类型 enum 定义在struct内部 定义在枚举，结构体，类内部的函数叫做方法 方法占用对象内存吗？不占用。 方法，本质是函数，存放在代码段。 代码段，全局变量，堆空间， 局部变量（栈空间） 闭包表达式 一个函数和它所捕获的常量，变量环境组合起来，称为闭包。 一般指定义在函数内部的函数 一般它捕获的是外层函数的局部变量/常量 12345&#123; (入参数) -&gt; 返回值 in 函数体代码 &#125;var fn = &#123; (v1:Int,v2:Int) -&gt; Int in retutn v1 + v2&#125; 尾随闭包 数组排序 12345678910111213141516func getFn()-&gt;Int-&gt;Int&#123; var num = 0 fun plus(_ i:Int)&#123; num += i return num &#125; return plus&#125;var fn = getFn() fn(1) // 1 fn(2) // 3 fn(3) // 6 fn(4) // 10注：num 是局部变量，但是在函数内部使用，被捕获，在堆区申请内存 存放num局部变量；会被延长生命周期，值会累加。 可以把闭包想象成一个类的实例对象， 内存在堆空间。 捕获的局部变量/常量就是对象的成员，存储属性 组成闭包的函数就是类内部定义的方法]]></content>
      <categories>
        <category>iOS</category>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift-xmg05]]></title>
    <url>%2F2019%2F03%2F07%2FiOS%2Fswift-xmg05%2F</url>
    <content type="text"><![CDATA[结构体和类 Bool Int Array String Dictionary 常见类型都是结构体 初始化器 所有的结构体都有一个编译器自动生成的初始化器，传入所有的成员，初始化所有成员。 如果定义的成员A已经赋值，初始化器可以不用参数 来初始化A 如果成员是可选项，初始化器也可以不用穿值 如果自定义了初始化器，编译器不再生成，init(x:Int,y:Int) 初始化器汇编结构体的内存大小类 编译器不为类生成传入成员值的初始化器。 成员的初始化 是在这个初始化器中完成的。 如果类的所有成员都在定义的时候指定了初始值，编译器会为类生成无参数的初始化器。 会生成一个无参数的初始化器，但是定义的时候成员值要赋值 初始化。 类和结构体的本质区别 结构体是值类型，（枚举也是值类型） 类是引用类型（指针类型） 函数调用 内存在哪里？ 栈区 值类型，在函数内部定义，那就在栈区。 如果是引用类型，在函数内部定义，size对象的内存地址存储在栈空间，size内部的值，存储在堆区。 size(width,height) 存储在堆区，占32个字节， 第一个8 ，存储指向类型信息 第二个8 ，存储引用计数 第三个8，存储width 第四个8，存储height 汇编验证 结构体调用的是callq 类调用的是__allocting_init() 向堆空间申请内存 swift_allocObject swift_slowAlloc symobl stub for:malloc 在libsystem_malloc.dylib malloc_zone_malloc malloc_size(&amp;p)来获取指针P执行的堆空间有多大 结构体的内存所在，是由在那个位置定义结构体决定的 在函数内部定义结构体对象，就在栈区 在类外面，全局，在代码数据区（全局区） 在类中定义，就在堆区 类指针根据在那创建的跟着变化 在数据区，栈区，堆区。但是类中的属性方法等内存都在堆区 值类型 是直接将所有的内容拷贝一份如果copy操作，是属于深拷贝 全局变量，程序运行，内存地址只有一个的。程序已启动，代码地址已固定 值类型的赋值操作（copy On Whrite） 为了提升性能，String，Arrary,Dictionary,Set采用了Copy On Write ; 当仅当有写操作的时候，才会真正执行拷贝操作。 var p1 = Point(x:10,y:20) p1 = Point(x:11,y:12) 直接覆盖内存地址 引用类型 引用类型赋值给var let 或者给函数传参数，是将内存地址拷贝。 指向同一个文件，属于浅拷贝。 movq %rax,0x78cd(%rip) // c= getA() rax一般作为函数的返回值 0x78cd(%rip)，rip + 一个固定值 是全局变量。]]></content>
      <categories>
        <category>iOS</category>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift-xmg04]]></title>
    <url>%2F2019%2F03%2F06%2FiOS%2Fswift-xmg04%2F</url>
    <content type="text"><![CDATA[枚举的内存结构 见上个文档swift03.md 汇编指令 汇编语言的种类 8086汇编 x86汇编 x64汇编 ARM汇编(嵌入式，移动设备) x86,x64汇编根据编译器的不同，有2种书写格式 Intel:Windows派系 AT&amp;T：Unix派系 AT&amp;T汇编，iOS模拟器 ARM汇编，iOS真机 常见的汇编指令 项目 AT&amp;T Intel 说明 寄存器 %rax rax 操作数顺序 movq %rax,%rdx mov rdx,rax 将rax的值赋值给rdx 常数/立即数 movq $3,%rax movq $0x10,%rax mov rax,3mov rax,0x10 将3赋值给rax将0x10赋值给rax 内存赋值 movq %0xa,0x1ff7(%rip) mov qword ptr [rip + 0x1ff7],0xa 将0xa赋值给地址为（rip + 0x1ff7）的内存空间 取内存地址 leaq -0x18(%rbp),%rax lea rax,[rbp-0x18] 将(rbp-0x18) 这个地址赋值给rax jmp指令 jmp *%rdxjmp*(%rax)jmp 0x4028031 jmp rdx jmp [rax] jmp 0x4028031 call和jmp方法类似，但是jmp 直接跳转走，call调用函数，会返回。 操作数长度 movl movb leaw,leaq mov lea b = byte 8位 ；s = short 16/32位；w = word 16位；l = long 32/64位； q = quad 64位；t = ten bytes 80位 寄存器 %rax,%rbx,%rcx,%rdx,%rsi,%rdi,%rbp,%rsp (8个) %r8,%r9,%r10,%r11,%r12,%r13,%r14,%r15 (8个) 寄存器的具体作用 %rax,常作为函数的返回值使用 %rdi,%rsi,%rcx,%rdx,%r8,%r9 常作为存放函数的参数 %rsp,%rbp 常用与栈操作 (%rip) rip值得是下一条指令地址 lldb 常用指令 读取寄存器的值 regsiter read/格式 regsiter read/x 修改寄存器的值 register write 寄存器名称 数值 register write rax 0 读取内存的值 x/数量-格式-字节大小 内存地址 x/3xw 0x0000010 修改内存的值 memory write 内存地址 数值 memory write 0x0000010 10 x/3xw格式 x 是16进制，f是浮点 ，d是10进制 x/3xw字节大小 b byte 1字节 h half word 2字节 w word 4字节 g giant word 8字节 expression 表达式 po 表达式 po/x $rax po (int)$rax 断点调试指令 源码单步运行 跳过子函数 thread step-over | next | n 源码单步运行 进入子函数 thread step-in | step | s 汇编代码单步运行 跳过子函数 thread step-inst-over | nexti | ni 汇编代码单步运行 进入子函数 thread step-inst | stepi | si 直接执行当前函数的所有代码 返回到上一个函数 thread-step-out | finish]]></content>
      <categories>
        <category>iOS</category>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift-xmg03]]></title>
    <url>%2F2019%2F03%2F05%2FiOS%2Fswift-xmg03%2F</url>
    <content type="text"><![CDATA[1补充 @inline 1234567891011@inline(never) 永远不会内联，即时开启了编译器优化@inline(never) func test()&#123; print("never inline")&#125;@inline(__always) 开启编译器优化后，即时代码很长，(递归函数调用，动态派发的函数除外)，也会内联@inline(__always) func test()&#123; print("always inline")&#125; inout输入输出函数 2枚举基本用法 enum case; 一般枚举的名字大写，枚举项小写； 123enum Direction &#123; case north,south,east,west&#125; 关联值 123456789101112131415enum Date &#123; case digit(year: Int, month: Int, day: Int) case string(String)&#125;var date = Date.digit(year:2019,month:9,day:10)date = .string("2019-09-10") // 如果确定了枚举类型，可以省略枚举name，直接使用点 .string()swich pwd &#123; case let .number(n1,n2,n3,n4): print("number is ",n1,n2,n3,n4) case let .gesture(str): print("gestur is ",str)&#125; 原始值 定义枚举的时候指定类型，定义枚举项的时候定义 默认值，是原始值 123456789enum Grage:String &#123; case prefet = "A" case great = "B" case good = "C" case bad = "D"&#125;// 使用默认值print(Grage.prefet.rawValue) 隐式原始值;如果 原始值类型是Int，String，swift会自动分配原始值 1234567enum Direction:String &#123; case north,south,east,west&#125;// 默认字符串本身print(Direction.north.rawValue) // "north"// Int类型的，默认是从0开始，如果第一个给了原始值1，后面开始递增1 递归枚举 需要在枚举name之前，或者需要递归的枚举项之前 加上关键字 indirect 1234567891011121314151617enum ArithExpr &#123; case number(Int) indirect case sum(ArithExpr, ArithExpr) indirect case difference(ArithExpr, ArithExpr)&#125;// 使用func calucate(_ expr: ArithExpr) -&gt; Int &#123; switch expr &#123; case let .number(value) retutn value case let .sum(left,right): retutn calucate(left) + calucate(right) case let . difference(left,right) return calucate(left) - calucate(right) &#125;&#125; 枚举占用的内存 使用MemoryLayout 来获取数据类型占用的内存大小 枚举有关联值，有原始值 是不一样的内存大小，有区别。 12345678910111213141516171819202122232425262728293031 1.有关联值的情况 enum Password&#123; case number(Int,Int,Int,Int) case other &#125; MemoryLayout.stride // 40,分配占用的空间大小 MemoryLayout.size // 33，实际用到的空间大小 MemoryLayout.alignment // 8，对其参数 var p1 = Password. number(1,2,3,4) var p2 = Password. number(2,2,3,4) var p3 = Password. number(3,2,3,4) var p4 = Password. number(4,2,3,4) var p5 = Password. number(5,2,3,4) // p1-p5 参数不同，代表不同的值，需要把关联的值存储到枚举的内存中，占用4*8 = 32个字节 // Password.other存放不覆盖.number空间，只占一个字节，所以是 32 + 1 = 33 // 4*8 + 1 == 33个字节，又因为偏移量是8 ，不够8，补8，实际分配内存402.有原始值的情况enum Grage:String &#123; case prefet = "A" case great = "B" case good = "C" case bad = "D"&#125;占用内存大小是1，与Sting，Int类型没有关系。var a = Grage. prefetvar b = Grage. prefetvar c = Grage. prefetvar d = Grage. prefet其实是一个东西，枚举中不具体存值，只存一个标记，占用1个字节 3 可选项 var name: String? = nil 强制解包! 可选绑定 if let guard let while lt num = Int(&quot;323a&quot;),num &lt; 0 {} 空合并运算符?? 隐式解包，在定义类型后面 加上感叹号! 多重可选项 var num1 :Int? = 10 var num2:Int?? = num1 var num3:Int?? = 10 可以使用LLDB 查看，frame variable -R 或者 fr v -R 查看区别]]></content>
      <categories>
        <category>iOS</category>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift-xmg02]]></title>
    <url>%2F2019%2F03%2F04%2FiOS%2Fswift-xmg02%2F</url>
    <content type="text"><![CDATA[1.流程控制123while repeat while去掉了age++,age-- (1)for循环 闭区间运算符 a…b ;a&lt;= 取值 &lt;= b for j in 0...3 半开区间运算符 a.. for 区间运算符用在数组上 1234let names = ["1","2","3","4"]for name in names[0...3]&#123; print(name)&#125; 单侧区间 让区间朝一个方向尽可能远【2…】;[…2];[..&lt;2] 区间类型 123let rang1:CloseRange&lt;Int&gt; = 1...3let range2:Range&lt;Int&gt; = 1..&lt;3let range3:PartialRangeThrough&lt;Int&gt; = ...5 字符。字符串也能使用区间运算符，但默认不能用在for-in中 从‘\0’到‘～’ 囊括了所有的要用到的ASCII字符 12 let characterRange:CloseRange&lt;Character&gt; = "\0"..."~"characterRange.contains("G"). // true (2)带间隔的区间值12345let hours = 11let hourInterval = 2for tickMark in stride(from:4, through:hours, by:hourInterval)&#123; print(tickMark) // 4,6,8,10&#125; (3)Switch case 1: default 后面不能写大括号 默认可以不写break，并不会贯穿到后面的条件 需要强制贯穿，fallthrough 需要保证能处理所有的情况；条件不全的话，需要default； 如果不想做任何事，加个break即可 复合条件，支持character, string 可以加fallthrough 可以case：1，2 用逗号分隔多个条件 区间匹配，元组匹配 case 1..&lt;5;case 12..&lt;100 case (0,0) ; case(-2…2, -2…2) 值绑定： case(let x,0): ; case(0, let y) where case let (x,y) where x == y : for numner in numbers where num &gt; 0 {} 标签语句outer outer: for i in 1...4 { for k in 1...4 { if k == 3 { continue outer; } if i == 3 { break outer; } print("i === \(i), K == \(k)") } } 2.函数 参数标签 内 外 用下划线省略标签 默认参数值 func setNames(name:String = &quot;nobody&quot;) C++ 的 默认值，只能从右边开始，做多设置四个。按顺序对应。 可变参数 （_ numbers:Int...） 一个函数只能有个一个可变参数，紧跟在可变参数参数后年的参数不能省略 参数标签。（可变参数入参是逗号，如果之后省略参数标签，会省略） swift自带的print函数 print(items:Any..., separator:String,termnator:String) 输入输出参数 inout;可以在函数内部，修改外部实参数的值；本质是地址传递 定义的时候func add(_ num: inout Int){} 调用的时候 add(&amp;number) 只能传入可以多次赋值的，变量，数组中的元素； 交换两个值，可以定义一个函数 inout；也可以利用元组交换 （1）函数重载 函数名相同， 参数个数不同 || 参数类型不同 || 参数标签不同； 返回值类型，与函数重载无关； （2）内联函数 将函数展开成函数体； debug默认不是，release是。在budding setting 中 搜索 optimization ,设置debug optimize for speed 那些不会内联 函数体比较长 包含递归调用 包含动态派发 （3）函数类型 定义函数类型的变量 函数类型作为函数参数 函数类型作为函数的返回值 typealias 用来给类型起别名 typealias Date = (year: Int, month: Int, day: Int) Void 就是空元组() public typealias Void = ()]]></content>
      <categories>
        <category>iOS</category>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Weex应用笔记1]]></title>
    <url>%2F2019%2F03%2F03%2FVue%2FWeex%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[开发中遇到的动态调试，打包，发包，资源。weex 与原生的交互等 开发调试静态调试远程调试热更新打包资源字体/图片等Weex 调用原生方法；并回调原生调用weex方法刷新控制器的封装navigator 跳转指定的weex.js文件]]></content>
      <categories>
        <category>Weex</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Weex学习笔记3]]></title>
    <url>%2F2019%2F03%2F02%2FVue%2FWeex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%2F</url>
    <content type="text"><![CDATA[学习目标 Weex 常用的组件 ；和原生的交互；原生调用Weex组件；封装原生组件； Weex 内置模块 按需导入animation 动画组件 js-animation 可以对组件执行一系列的变换。位置平移 / 大小缩放 / 角度旋转 / 背景色 / 透明度渐变等 12345678910111213141516animation.transation( ref1, &#123; styles:&#123; transform:&apos;translate(200px, 100px)&apos;, background:&apos;#ff0000&apos; &#125;, duration:800, timeFunction:&apos;ease&apos;, needLayout:false, delay:0, &#125;, function()&#123; modal.toast(&#123;message:&apos;animation finished&apos;&#125;) &#125;) animation.transation(ref1,options,callback) ref 是执行动画的对象 options 动画执行参数对象 styles duration 延迟执行的时候 ms delay 延迟时间 ms timeFunction linear；ease-in; ease-out ;ease-in-out; cubic-bezier(x1, y1, x2, y2) callback 动画执行完成之后回调 styles 中支持动画的属性 width height backgroundColor opacity transformOrigin transformOrigin定义变化过程的中心点，如transformOrigin: x-axis y-axis 参数 x-axis 可能的值为 left、center、right、长度值或百分比值， 参数 y-axis 可能的值为 top、center、bottom、长度值或百分比。 默认值为center center transform 可选值: translate, translateX ,translateY ; rotateX , rotateY ; perspective; scale, scaleX, scaleY clipBoard 获取设置剪切板内容 只支持 字符串，适用于iOS Android 平台 getString(@callback) 获取剪贴板字符串 setString(@text) 设置剪贴板字符串 12345const clipboard = weex.requireModule(&apos;clipboard&apos;)clipboard.setString(this.tobecopied)clipboard.getString(ret =&gt; &#123; this.message = &apos;text from clipboard:&apos; + ret.data&#125;) dom weex节点操作 scrollToElement / getComponetRect / addRule / getLayoutDirection scrollToElement(ref,options) options:{offset:0, animated:true} offset：0 如果ref 下面还有超过屏幕显示不全，会滚动到ref下，ref 在顶部；如果ref下够现实一屏，会把最后一条滑动到最底部位置，显示出ref组件 getComponentRect(ref, callback) 获取某个元素 View 的外框 ; 12345678910111213141516171819const result = dom.getComponentRect(this.$refs.box, option =&gt; &#123; console.log(&apos;getComponentRect:&apos;, option) this.size = option.size&#125;)console.log(&apos;return value:&apos;, result)this.returnValue = result// 回调的数据，返回的数据是一样的。&#123; result: true, size: &#123; bottom: 60, height: 15, left: 0, right: 353, top: 45, width: 353 &#125;&#125; getLayoutDirection(ref, callback) 12345678const element = this.$refs[&apos;kkk&apos;][0];dom.getLayoutDirection(element, function(ret) &#123; console.log(ret.result);&#125;);// 返回的值ret = &#123; &quot;result&quot;: &quot;rtl&quot;,&#125; addRule Weex 提供 DOM.addRule 以加载自定义字体 123456789101112131415161718const domModule = weex.requireModule(&apos;dom&apos;)domModule.addRule(&apos;fontFace&apos;, &#123; &apos;fontFamily&apos;: &quot;iconfont2&quot;, &apos;src&apos;: &quot;url(&apos;http://at.alicdn.com/t/font_1469606063_76593.ttf&apos;)&quot;&#125;);@fontFace 协议名称，不可修改。@fontFamily font-family的名称。@src 字体地址，url(&apos;&apos;) 是保留字段，其参数如下: http. 从HTTP请求加载, url(&apos;http://at.alicdn.com/t/font_1469606063_76593.ttf&apos;) https. 从HTTPS请求加载, url(&apos;https://at.alicdn.com/t/font_1469606063_76593.ttf&apos;) local, Android ONLY. 从assets目录读取 url(&apos;local://foo.ttf&apos;), foo.ttf 是文件名在你的assets目录中. file. 从本地文件读取 url(&apos;file://storage/emulated/0/Android/data/com.alibaba.weex/cachehttp:__at.alicdn.com_t_font_1469606063_76593.ttf&apos;) data. 从base64读取, url(&apos;data:font/ truetype;charset=utf-8;base64,AAEAAAALAIAAAwAwR1NVQrD+....&apos;), globalEvent 用于监听持久性事件 定位仪 陀螺仪等 内置的全局事件 WXApplicationDidBecomeActiveEvent 应用被前台时候触发 WXApplicationWillResignActiveEvent 应用 将要刮起的时候触发 触发全局事件 1234567android:Map&lt;String,Object&gt; params=new HashMap&lt;&gt;();params.put(&quot;key&quot;,&quot;value&quot;);mWXSDKInstance.fireGlobalEventCallback(&quot;geolocation&quot;, params);ios:[weexInstance fireGlobalEvent:@&quot;geolocation&quot; params:@&#123;@&quot;key&quot;:@&quot;value&quot;&#125;]; 常用的API addEventListener(eventName,callBack) 1234var globalEvent = weex.requireModule('globalEvent');globalEvent.addEventListener("geolocation", function (e) &#123; console.log("get geolocation")&#125;); removeEventListener(eventName) 12var globalEvent = weex.requireModule(&apos;globalEvent&apos;);globalEvent.removeEventListener(&quot;geolocation&quot;); meta setViewport 模块可用于声明单个页面的元信息，通常是一些页面级别的配置，如容器的显示宽度 (viewport) 等。默认情况下，应用无需修改此配 setViewport Weex 容器默认的宽度 (viewport) 是 750px，通过 setViewport 方法可以改变页面的显示宽度，仅对当前页面生效。 只有在页面渲染开始之前设置 viewport 才会生效。 也就是说，setViewport 方法只能在入口文件中使用，而且要在 new Vue(…) 之前调用；如果是在组件中使用，就只有在渲染到该组件的时候才会执行相应的代码，此时页面已经处于渲染过程中，设置 viewport 将不会再生效。 宽度和高度的单位默认是 px，暂不支持其他单位 setViewport(options) {width:640,roundOffDeviation:false} roundOffDeviation 仅用于android，true，忽略小数点造成的误差，默认是true。false 是不忽略，精确度高点。 modal 展示消息的API toast / alert / confirm prompt toast(options) options：message弹出的提示内容；duration持续时间 12345var modal = weex.requireModule(&apos;modal&apos;)modal.toast(&#123; message:&apos;toastMesaage&apos;, duration:1 // s&#125;) alert(options，@callBack) option:message弹出的提示内容，okTitle:确认按钮上的文字；callBack用户完成之后的回调 1234567var modal = weex.requireModule(&apos;modal&apos;)modal.alert(&#123; message:&apos;提示确定弹框&apos;, okTitle:&apos;确定&apos;&#125;,function()&#123; console.log(&apos;点击了确定之后回调&apos;)&#125;) confirm(options,@callBack) 确认框用于使用户可以验证或者接受某些信息。当确认框出现后，用户需要点击确定或者取消按钮才能继续进行操作 1234567891011121314options: message, string，警告框内显示的文字信息 okTitle, string，确认按钮上显示的文字信息 cancelTitle, string，取消按钮上显示的文字信息@callback,function， 用户操作完成后的回调，参数是按下按钮上的文字信息 参数result, string, 用户按下的按钮文字信息var modal = weex.requireModule(&apos;modal&apos;)modal.confirm(&#123; message: &apos;Do you confirm ?&apos;, duration: 0.3&#125;, function (value) &#123; console.log(&apos;confirm callback&apos;, value)&#125;) prompt(options,@callback) 带输入框的 取消，确定 弹框；当提示框出现后，用户需要输入某个值，然后点击确认或取消按钮才能继续操作 1234567891011121314@options message, string，警告框内显示的文字信息 okTitle, string，确认按钮上显示的文字信息 cancelTitle, string，取消按钮上显示的文字信息@callback, function，用户操作完成后的回调 res.result：用户按下的按钮上的文字信息 res.data：用户输入的文字信息var modal = weex.requireModule(&apos;modal&apos;)modal.prompt(&#123; message: &apos;This is a prompt&apos;, duration: 0.3&#125;, function (value) &#123; console.log(&apos;prompt callback&apos;, value)&#125;) navigator 导航栏 iOS/Android 的 navigator 模块就是用来实现类似的效果的。除了前进、回退功能，该模块还允许我们指定在切换页面的时候是否应用动画效果 push 把一个weex页面的URL； 压入栈操作指定跳转的动画；指定跳转完毕的回调函数 1234567var navigator = weex.requireModule(&apos;navigator&apos;)navigator.push(&#123; url:&apos;http://dotwe.org/raw/dist/519962541fcf6acd911986357ad9c2ed.js&apos;, animated:&apos;true&apos;&#125;,event=&gt;&#123; console.log(&apos;callback: &apos;, event &#125;)&#125;) pop 是否需要动画，完成之后的回调 123456var navigator = weex.requireModule(&apos;navigator&apos;)navigator.pop(&#123; animated:&apos;false&apos;&#125;,event=&gt;&#123; console.log(&apos;callback: &apos;, event &#125;)&#125;) picker 用于数据选择，日期选择，时间选择 pick(options, callback[options])pickerDate(options, callback[options]))pickerTime(options, callback[options])) 12345678910111213141516171819202122232425262728293031323334 const picker = weex.requireModule(&apos;picker&apos;) methods: &#123; // 数据选择 pick () &#123; picker.pick(&#123; items: [&apos;Apple&apos;, &apos;Banana&apos;, &apos;Orange&apos;] &#125;, event =&gt; &#123; if (event.result === &apos;success&apos;) &#123; this.value = event.data &#125; &#125;) &#125;, // 日期选择 pickDate () &#123; picker.pickDate(&#123; value: this.value &#125;, event =&gt; &#123; if (event.result === &apos;success&apos;) &#123; this.dateValue = event.data &#125; &#125;) &#125;, // 时间选择 pickTime () &#123; picker.pickTime(&#123; value: this.timeValue &#125;, event =&gt; &#123; if (event.result === &apos;success&apos;) &#123; this.timeValue = event.data &#125; &#125;) &#125;&#125; pick(options, callback[options]) option index:默认选中的选项 items 数据源数组 textColor 一行文字颜色 selectionColor 选择文字的颜色 confirmTitle 右侧确认文字 cancelTitle 左侧取消文字 confirmTitleColor 确认文字颜色 cancelTitleColor 取消文字颜色 title 中间标题 默认是空 titleColor 标题的文字颜色 titleBackgroundColor 标题的背景色 callback result 字符串 success cancel error data 选择的内容 index，选择的index pickDate(options, callback[options]) option value 必填选中的值，格式是‘yyyy-MM-dd’ 默认选择的时间，空传空字符串 默认是当前年月日 max 可选最大值 min 可选最小值 callback result 字符串 success cancel error data 选择的值 date 的字符，格式为 yyyy-MM-dd, 仅成功确认的时候存在 pickTime(options, callback[options]) option value：必选，time 格式为 HH:mm callback result 字符串 success cancel error data 选择的值 date 的字符，格式为 HH:mm, 仅成功确认的时候存在 storage storage是一个在前端比较常用的模块可以对本地数据进行存储、修改、删除，并且该数据是永久保存的，除非手动清除或者代码清除。 但是，storage 模块有一个限制就是浏览器端（H5）只能存储小于5M的数据，因为在 H5/Web 端的实现是采用 HTML5 LocalStorage API。而 Android 和 iOS 这块是没什么限制的。 storage 常用在一些被用户经常查询，但是又不频繁更新的数据，比如搜索历史、用户的订单列表等。搜索历史一般情况都是作为本地数据存储的，因此使用 storage 比较合适。而用户订单列表是需要本地存储和服务端器检索配合的场景。当一个用户下单后，会经常查阅个人的订单列表。但是，订单的列表数据不是频繁更新的，往往只有在收到货品时，才更新“已签收”，其余平时的状态是“已发货”。因此，可以使用 storage 存储订单列表，可以减少服务器的压力，例如减少 SQL 查询或者缓存的压力。当用户查看订单详情的时候，再更新数据状态 setItem(key,value,callback) key 存储的健 不允许事null和空字符串 value 存贮的值 不允许存储null和空字符串 callback(e) result === ‘success’;e.data undefined 表示存储成功 getItem(key,callback) key 取出的健 不允许事null和空字符串 callback(e) result === ‘success’;e.data获取对应的键值字符串 removeItem(key, callback) key要删除的值的名称 callback(e) result === ‘success’;e.data 为undefined 表示删除成功 length(callback) callback(e) result === ‘success’;e.data 为存储项的长度 e.result：表示操作是否成功，如果成功返回 “success” e.data：当前已存储项的数量 getAllKeys(callback) e.result：表示操作是否成功，如果成功返回 “success” e.data：所有键名组成的数组 12345678910111213141516171819202122232425262728293031323334methods: &#123; // 存储 setItem () &#123; storage.setItem(&apos;name&apos;, &apos;Hanks&apos;, event =&gt; &#123; this.state = &apos;set success&apos; console.log(&apos;set success&apos;) &#125;) &#125;, // 取值 getItem () &#123; storage.getItem(&apos;name&apos;, event =&gt; &#123; console.log(&apos;get value:&apos;, event.data) this.state = &apos;value: &apos; + event.data &#125;) &#125;, // 删除一个key值 removeItem () &#123; storage.removeItem(&apos;name&apos;, event =&gt; &#123; console.log(&apos;delete value:&apos;, event.data) this.state = &apos;deleted&apos; &#125;) &#125;, // for循环取出所有的存储值 getAll () &#123; storage.getAllKeys(event =&gt; &#123; // modal.toast(&#123; message: event.result &#125;) if (event.result === &apos;success&apos;) &#123; modal.toast(&#123; message: &apos;props: &apos; + event.data.join(&apos;, &apos;) &#125;) &#125; &#125;) &#125;&#125; stream 网络 模块提供了基本的网络请求能力，例如 GET 请求、POST 请求等，用于在组件的生命周期内与服务端进行交互 fetch(options, callback, progressCallback) options method HTTP 请求方法 ‘GET/POST/PUT/DELETE/PATCH/HEAD’ , url headers HTTP 请求头 type 响应类型 ‘json / text / jsonp’ body 请求体 注意： body为JSON字符串；get不能用body； 默认 Content-Type 是 application/x-www-form-urlencoded。 如果你需要通过 POST 发送 json 数据， 需要将 Content-Type 设为 application/json callback(respon) status, number, 返回的状态码 ok, boolean, 如果状态码在 200-299 之间就为 true statusText, string, 状态描述文本 data, string, 返回的数据，如果请求类型是 json 和 jsonp，则它就是一个 object ，否则是一个 string。 headers, object, rHTTP 响应头 progressCallbak readyState, number, 当前状态，1: 请求连接中；2: 返回响应头中；3: 正在加载返回数据 status, number, 返回的状态码 length number, 已经接受到的数据长度. 你可以从响应头中获取总长度 statusText, string, 状态描述文本 headers. object, HTTP 响应头 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129const stream = weex.requireModule('stream');var GET_URL_JSONP = 'http://jsfiddle.net/echo/jsonp/?callback=anything&amp;result=content_in_response';var GET_URL = 'http://httpbin.org/get';var POST_URL = 'http://httpbin.org/post';var PUT_URL = 'http://httpbin.org/put';var DELETE_URL = 'http://httpbin.org/delete';var HEAD_URL = 'http://httpbin.org/status/418';var PATCH_URL = 'http://httpbin.org/patch'; //1.GET -JOSNP stream.fetch(&#123; method: 'GET', url: GET_URL_JSONP, type:'jsonp' &#125;, function(ret) &#123; if(!ret.ok)&#123; me.getJsonpResult = "request failed"; &#125;else&#123; console.log('get:'+ret); me.getJsonpResult = JSON.stringify(ret.data); &#125; &#125;,function(response)&#123; console.log('get jsonp in progress:'+response.length); me.getJsonpResult = "bytes received:"+response.length; &#125;); //2.GET-JSON stream.fetch(&#123; method: 'GET', url: GET_URL, type:'json' &#125;, function(ret) &#123; if(!ret.ok)&#123; me.getResult = "request failed"; &#125;else&#123; console.log('get:'+ret); me.getResult = JSON.stringify(ret.data); &#125; &#125;,function(response)&#123; console.log('get in progress:'+response.length); me.getResult = "bytes received:"+response.length; &#125;); // POST-JSON stream.fetch(&#123; method: 'POST', url: POST_URL, type:'json' &#125;, function(ret) &#123; if(!ret.ok)&#123; me.postResult = "request failed"; &#125;else&#123; console.log('get:'+JSON.stringify(ret)); me.postResult = JSON.stringify(ret.data); &#125; &#125;,function(response)&#123; console.log('get in progress:'+response.length); me.postResult = "bytes received:"+response.length; &#125;); // PUT-JSON stream.fetch(&#123; method: 'PUT', url: PUT_URL, type:'json' &#125;, function(ret) &#123; if(!ret.ok)&#123; me.putResult = "request failed"; &#125;else&#123; console.log('get:'+JSON.stringify(ret)); me.putResult = JSON.stringify(ret.data); &#125; &#125;,function(response)&#123; console.log('get in progress:'+response.length); me.putResult = "bytes received:"+response.length; &#125;); // DELETE-JSON stream.fetch(&#123; method: 'DELETE', url: DELETE_URL, type:'json' &#125;, function(ret) &#123; if(!ret.ok)&#123; me.deleteResult = "request failed"; &#125;else&#123; console.log('get:'+JSON.stringify(ret)); me.deleteResult = JSON.stringify(ret.data); &#125; &#125;,function(response)&#123; console.log('get in progress:'+response.length); me.deleteResult = "bytes received:"+response.length; &#125;); // HEAD—JSON stream.fetch(&#123; method: 'HEAD', url: HEAD_URL, type:'json' &#125;, function(ret) &#123; if(ret.statusText !== 'I\'m a teapot')&#123; me.headResult = "request failed"; &#125;else&#123; console.log('get:'+JSON.stringify(ret)); me.headResult = ret.statusText; &#125; &#125;,function(response)&#123; console.log('get in progress:'+response.length); me.headResult = "bytes received:"+response.length; &#125;); // PATCH-JSON stream.fetch(&#123; method: 'PATCH', url: PATCH_URL, type:'json' &#125;, function(ret) &#123; if(!ret.ok)&#123; me.patchResult = "request failed"; &#125;else&#123; console.log('get:'+JSON.stringify(ret)); me.patchResult = JSON.stringify(ret.data); &#125; &#125;,function(response)&#123; console.log('get in progress:'+response.length); me.patchResult = "bytes received:"+response.length; &#125;); webview 提供一系列web组件接口 goBack、goForward 和 reload，一般与 组件一起使用，在 Weex 页面内渲染 web 页面 goBack 后退 参数是需要后退的web组件 goForward 前进 参数是需要前进的web组件 reload 刷新 参数是需要刷新的web组件 123456789101112131415161718192021222324252627282930313233343536373839404142监听函数 onPageFinish ，通过返回的参数，有历史记录 才能进行前进后退等 &lt;web ref="webview" style="width: 730px; height: 500px" src="https://vuejs.org" @pagestart="onPageStart" @pagefinish="onPageFinish" @error="onError" @receivedtitle="onReceivedTitle"&gt;&lt;/web&gt;const webview = weex.requireModule('webview');goBack: function() &#123; webview.goBack(this.$refs.webview);&#125;,goForward: function() &#123; webview.goForward(this.$refs.webview);&#125;,reload: function() &#123; webview.reload(this.$refs.webview);&#125;,onPageStart: function(e) &#123; this.pagestart = e.url;&#125;,onPageFinish: function(e) &#123; this.pagefinish = e.url; this.canGoBack = e.canGoBack; this.canGoForward = e.canGoForward; if (e.title) &#123; this.title = e.title; &#125;&#125;,onError: function(e) &#123; this.error = url;&#125;,onReceivedTitle: function(e) &#123; this.title = e.title;&#125; webSocket websocket是一种创建持久的连接，API 导入模块 var ws = weex.requireModule(&#39;webSocket&#39;) 创建连接 ws.WebSocket(&#39;ws://echo.websocket.org&#39;,&#39;&#39;) WebSocket(url, protocol) 第一个参数是URL 第二个参数是协议protocol 发送数据 ws.send(&#39;some message&#39;) send(data) data 是字符串类型 关闭连接 ws.close() close(code, reason) code:关闭连接的状态号 reason 关闭连接的理由 监听有连接收到 ws.onopen = function(event){} 该事件表明这个连接已经准备好接受和发送数据。onopen 接受一个函数作为 EventListener，这个监听器会接受一个 type 为 “open” 的事件对象。 监听消息 ws.onmessage = function(event){} 当有消息到达的时触发。onmessage 接受一个函数作为 EventListener，这个监听器会接受一个 type 为 “message” 的事件对象 event.data 是接收到的数据 监听关闭连接 ws.onclose=function(event){} 当连接关闭时触发。onclose 接受一个函数作为 EventListener，这个监听器会接受一个 type 为 “close” 的事件对象。 event.code 关闭状态码 event.reason 关闭的原因 event.wasClean 是否完全关闭 监听错误 ws.onerror=function(event){} 当错误发生时触发。onerror 接受一个函数作为 EventListener，这个监听器会接受一个 type 为 “error” 的事件对象 event.data 错误的信息 1234567891011121314151617181920212223242526272829303132333435363738var websocket = weex.requireModule('webSocket')connect:function() &#123; websocket.WebSocket('ws://echo.websocket.org',''); var self = this; self.onopeninfo = 'connecting...' websocket.onopen = function(e)&#123; self.onopeninfo = 'websocket open'; &#125; websocket.onmessage = function(e)&#123; self.onmessage = e.data; &#125; websocket.onerror = function(e)&#123; self.onerrorinfo = e.data; &#125; websocket.onclose = function(e)&#123; self.onopeninfo = ''; self.oncloseinfo = 'closed'; self.onerrorinfo = e.code; &#125; &#125;, send:function(e) &#123; var input = this.$refs.input; input.blur(); websocket.send(this.txtInput); this.sendinfo = this.txtInput; &#125;, close:function(e) &#123; websocket.close(); &#125;, oninput: function(event) &#123; this.txtInput = event.value; &#125;,]]></content>
      <categories>
        <category>Weex</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Weex学习笔记2]]></title>
    <url>%2F2019%2F03%2F02%2FVue%2FWeex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%2F</url>
    <content type="text"><![CDATA[学习目标 Weex 常用的组件 ；和原生的交互；原生调用Weex组件；封装原生组件； Weex 内置组件a标签 实现页面之间跳转 不可以在组件内直接写文字，是和Vue 区别，需要在text标签内写入文字 href 属性跳转界面是一个weex界面 1234567&lt;a href="http://dotwe.org/raw/dist/a5e3760925ac3b9d68a3aa0cc0298857.bundle.wx"&gt; &lt;text&gt;Jump&lt;/text&gt;&lt;/a&gt;&lt;a href="http://emas-ha-remote-log-poc.oss-cn-beijing.aliyuncs.com/eweex/app/biz-docs-com-mod/upload/271ccdca-db41-423d-981c-c7c6751ba479/show_1.js"&gt; &lt;text&gt;主会场&lt;/text&gt;&lt;/a&gt; div标签 -通用容器 随意嵌套，div 可以嵌套div ,建议最高14层，多了影响性能；div中不可以直接添加文文本，文本在text组件中添加 text组件 渲染文本 不支持子组件 头尾空白的空格 会被过滤，使用动态添加内容 不会被过滤 文字高度的计算规则比较复杂，但大致上遵循以下优先级进行计算，排在前面的优先级最高。 文字节点的max-height/min-height样式。 文字节点的flex属性且文字的父节点上有flex-direction:column样式。 文字节点的height样式。 文字节点的align-items:stretch如果文字父节点有 flex-direction:row样式。 文字内容和文字本身的样式。 其他相关CSS属性 自定义字体 支持ttf / woff自定义字体 word-break 换行 在android上 会遇见不一致的情况 中文/日文/韩文(即 CJK 文字)与其他文字混合排布时，在 CJK 文字和其他文件相交区域可能会遇到 word-break 不一致的现象。-全角非 JCK 文字和半角非 CJK 文字混合时，全角和半角相交的地方可能会遇到 word-break 不一致的现象 image 图片组件 image组件属性 不支持子组件 必须指定 width / height / src placeholder 在下载过程中显示缩略图 resize 值可为：contain 完全装入 / cover 完全占满，会超出父视图 / stretch 拉伸按照父视图比例拉伸变形 src quality 值可为：original/normal/low/high/auto autoBitmapRecycle 安卓滚动超出屏幕是否回收相关内存 值：true false，默认是true 网络图片 / iOS Android 第三方图片管理 Weex 没有内置的图片库，因为一些开源项目如 SDWebImage 和Picasso已经能很好的解决这个问题， 所以在使用 之前，请在 native 侧先接入相应的 adapter 或者 handler。 本地图片 iOS android路径 image下载本地 save方法 1234567aimag.save(result =&gt; &#123; if (result.succcess)&#123; // 保存成功 &#125;else&#123; // 保存失败 &#125;&#125;) 监听图片load事件 handleLoad(event) / event.success / event.size(natureWidth/natureHeight) image 性能优化 / 懒加载 / list滑动 1234567891.正常写法&lt;image style="width:500px;height:500px" src="https://vuejs.org/images/logo.png"&gt;&lt;/image&gt;2.占位placeholder &lt;image src="http://www.example.com/test.png" placeholder="https://cdn.dribbble.com/users/79978/screenshots/3892720/bliss_club.png" style="width:500px;height:400px"&gt;&lt;/image&gt;3. list 组件 长列表 cell 不允许 scroller list 相同向的相互嵌套，因为会滚动冲突，要显示设置宽高， 属性 show-scrollbar 是否显示滚动条 loadmoreoffset 触发上拉加载的垂直偏移距离 offset-accuracy 滚动的距离是多少，触发onscroll 方法 pagingEnable 是否强制分页，默认是false scrollable 是否允许滚动 true/false 子组件 只能是下面四个组件，或者fix定位的组件。 cell 重用机制 header 滑到顶部 可以吸附顶部 refresh 下拉刷新 loading 上拉加载 事件 loadmore事件 触发之后 ，加载下一页，网络请求，拼接数据 scroll 默认 offset-accuracy 为10 ，每滑动10px出发一次 scroll事件， 事件对象 handleScroll(event) / event.contentSize.width/height / event.contentOffset.x/y 扩展 scrollToElement(node,options) 滚动到指定cell， 代码 12345678&lt;list class="list" offset-accuracy=100 show-scrollbar=false @loadmore="loadmore"@scroll="scroll" &gt; &lt;cell class="cell" v-for="num in lists"&gt; &lt;div class="panel"&gt; &lt;text class="text"&gt;&#123;&#123;num&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/cell&gt;&lt;/list&gt; cell 组件 用于list / recycler / waterfall中 keep-scroll-position true/false 控制cell加入列表中，滚动位置是否不变 insert-animation none/default 插入cell的动画 delete-animation none/default 删除cell的动画 recycle 是否启用cell重用机制 大量的cell，iOS上默认是true，如果设置false，会占用大量内存。android上默认是true，设置false，可以避免image text数据重新绑定 loading组件 1234&lt;loading @loading="onloading" :display="loadinging ? 'show' : 'hide'"&gt; &lt;text&gt;Loading&lt;/text&gt; &lt;loading-indicator&gt;&lt;/loading-indicator&gt;&lt;/loading&gt; display：show/hide 通过onloading方法 设置显示，加载网络请求之后，设置隐藏 refresh组件 1234&lt;refresh @refresh="onrefresh" @pullingdown="onpullingdown" :display="refreshing ? 'show' : 'hide'"&gt; &lt;text&gt;Refreshing ...&lt;/text&gt; &lt;loading-indicator&gt;&lt;/loading-indicator&gt;&lt;/refresh&gt; display：show/hide 通过onrefresh方法 设置显示，加载网络请求之后，设置隐藏 @refresh 是下拉完成触发，@pullingdown 是拖拽中触发 recycle-list 组件 具有回收 复用的能力 大幅优化内存 和渲染性能 recycle-list 结合cell-slot 作为子节点。 可以使用switch / case 对不同类的cell 进行分类显示 recycle-list属性 for / switch for 循环的是内部节点，不是当前节点。key 绑定在内部节点上 switch 是数据源list中一个对象的某个属性 cell-slot属性 case / default / key case 是对象的值，采用对应的cell-slot 1234567891011121314151617181920212223241.switch 是根据数据源list中一个对象的某个属性，case是对象的值，采用对应的cell-slot&lt;recycle-list for=&quot;(item, i) in longList&quot; switch=&quot;type&quot;&gt; &lt;cell-slot case=&quot;A&quot;&gt; &lt;text&gt;- A &#123;&#123;i&#125;&#125; -&lt;/text&gt; &lt;/cell-slot&gt; &lt;cell-slot case=&quot;B&quot;&gt; &lt;text&gt;- B &#123;&#123;i&#125;&#125; -&lt;/text&gt; &lt;/cell-slot&gt;&lt;/recycle-list&gt;&lt;template&gt; &lt;recycle-list class=&quot;list&quot; for=&quot;(item, i) in floors&quot; switch=&quot;type&quot;&gt; &lt;cell-slot case=&quot;floor&quot; :key=&quot;i&quot;&gt; &lt;div class=&quot;floor&quot;&gt; &lt;text class=&quot;title&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/text&gt; &lt;text class=&quot;desc&quot; lines=&quot;2&quot;&gt;&#123;&#123;item.desc&#125;&#125;&lt;/text&gt; &lt;div class=&quot;image-section&quot;&gt; &lt;image class=&quot;image&quot; :src=&quot;source&quot; v-for=&quot;(source, i) in item.pictures&quot; :key=&quot;i&quot; /&gt; &lt;/div&gt; &lt;text class=&quot;comment&quot;&gt;&#123;&#123;item.count&#125;&#125; 人说好&lt;/text&gt; &lt;/div&gt; &lt;/cell-slot&gt; &lt;/recycle-list&gt;&lt;/template&gt; cell-slot 唯一子组件 scroller 滚动视图 支持上拉加载，下拉刷新。&lt;refresh&gt;&lt;loading&gt; 属性 show-scrollbar 是否显示滚动条 scroll-direction 设置滚动方向 loadmoreoffset 出发loadmore 时间的垂直距离 offset-accuracy 出发scroll时间的距离频率 scrollToBegin 内容改变时 是否自动滚动到顶部，默认是true 事件 loadmore 如果滚动到底部将会立即触发这个事件 scroll 列表发生滚动时将会触发该事件 scrollstart 列表开始滚动时触发 scrollend 列表结束滚动时触发 事件对象 handleScroll(event) / event.contentSize / event.width / event.height / event.contentOffset / event.x / event.y 扩展 scrollToElement(node, options) node 是节点name；option可以设置{offset:20} 滚动到某个元素 偏移20 嵌套scroller 点击左右切换 电梯效果 12345678910111213141516171819202122232425262728293031323334353637383940411.scroller 的事件，scroll scrollstart scrollend&lt;scroller class=&quot;list&quot; @scroll=&quot;scroll&quot; @scrollstart=&quot;scrollStart&quot; @scrollend=&quot;scrollEnd&quot;&gt; &lt;div class=&quot;row&quot; v-for=&quot;row in rows&quot; :key=&quot;row.id&quot;&gt; &lt;text class=&quot;text&quot;&gt;&#123;&#123;row.name&#125;&#125;&lt;/text&gt; &lt;/div&gt;&lt;/scroller&gt;&lt;scroller class=&quot;wrapper&quot;&gt; &lt;div class=&quot;floor&quot; v-for=&quot;(name, index) in floors&quot; :ref=&quot;&apos;floor&apos;+name&quot;&gt; &lt;text class=&quot;floor-title&quot;&gt;- &#123;&#123;name&#125;&#125; -&lt;/text&gt; &lt;div class=&quot;goods&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;scroller class=&quot;elevator&quot; scroll-direction=&quot;horizontal&quot; show-scrollbar=&quot;false&quot;&gt; &lt;text class=&quot;elevator-title&quot;&gt;主要会场：&lt;/text&gt; &lt;div class=&quot;elevator-item&quot; v-for=&quot;(name, index) in floors&quot; :ref=&quot;&apos;item&apos;+index&quot; @click=&quot;go2floor($event, &apos;floor&apos;+name)&quot;&gt; &lt;text class=&quot;item-text&quot; :ref=&quot;&apos;text&apos;+index&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/scroller&gt;&lt;/scroller&gt; 2.go2floor($event, &apos;floor&apos;+name) 控制着本层的左右切换，并控制上层scroller的子视图滚动到顶部 &lt;script&gt; go2floor: function(event, refId) &#123; // 获取点击的横向tab const target = event.target; // 获取点击的纵向关联组件 const ref = this.$refs[refId]; const el = ref ? ref[0] : null; // 控制横向的滑动到可见区域 -300 位置 dom.scrollToElement(target, &#123;offset: -300&#125;); if (el) &#123; // 滑动到垂直可见区域，偏移-60 dom.scrollToElement(el, &#123;offset: -60&#125;); &#125; &#125; &lt;/script&gt; slider 组件 轮播图 一个页面中加载多个图片，循环播放 子组件 可以是任何组件作为slider的子组件 属性 auto-play 自动循环播放，默认是false interval 轮播间隔 默认3000ms index 设置默认显示的第几个页面 offset-x-accuracy 触发scroll事件滚动的频率 show-indicators 是否显示指示器 infinite 是否可以无限轮播 scrollable 是否允许手势切换页面，默认true keep-index android 是否数据源变化之后，index保持不变 forbid-slide-animation iOS默认是开启动画，使用该属性可以强制关闭切换时的动画 样式 通用样式 事件 通用事件外 change / scroll 事件 change(event)当轮播图下表改变时，触发change事件，参数有index，下标 scroll 当发生滚动的时候出发，参数offsetXRatio 当前图片的偏移比例 [-1,1] 实例 12345678910111213141516171819202122indicator 作为slider的子组件&lt;slider class="slider" interval="3000" auto-play="true"&gt; &lt;div class="frame" v-for="img in imageList"&gt; &lt;image class="image" resize="cover" :src="img.src"&gt;&lt;/image&gt; &lt;/div&gt; &lt;indicator class="indicator"&gt;&lt;/indicator&gt;&lt;/slider&gt;// 设置整体颜色background-color； 指示点半径item-size ； 指示器的颜色item-color ； 指示器选中的颜色item-selected-color &lt;css&gt; .indicator &#123; position: absolute; left: 0; right: 0; bottom: 0; height: 60px; background-color: rgba(0, 0, 0, 0); item-color: #ddd; item-selected-color: rgb(0, 180, 255); &#125;&lt;/css&gt; input 输入框组件 用来接收用户的字符串输入，不支持click方法，有input 方法，change方法替代，不支持子组件 属性 type 控件的类型 text / date / time / datetime / email / passworld / tel / url / number value 默认内容 placeholder 占位符 不能有回车或换行 autofocus 是否自动聚焦 return-key-type 回车类型 default / go / next / search / send / done singleline 控制内容 是否显示1行 maxlength 数值类型采用maxlength 控制输入的最大长度 max-length 控制输入内容的的最大长度 字符串长度，中英文占位都为1 max date类型的时候 选择最大时间 min date类型的时候，选择的最小时间 upriseOffset 弹出的键盘挡住输入框的时候 输入框会自动向上，upriseOffset 是设置键盘 与滑动之后的输入框间距 默认是20 hideDoneButton 隐藏键盘上的完成按钮 默认是false 样式 placeholder-color 占位符的颜色 伪类 :active :focus :disable :enable 事件 支持通用事件 input 输入中不断触发handleInput(value) change 输入完成之后触发handleChange(value) focus 获取焦点的时候触发 handelFocus() blur 失去焦点的时候触发handleBlur() return 用户输入右下角的回车触发 handleReturn(value,returnType) keyboard 当键盘弹出 隐藏的时候触发 handleKeboard(isshow,keyboardSize) 组件方法 focus() 让组件聚焦 blur() 让组件失去焦点 setSelectionRange(selectionStart,selectionEnd) 设置文本选区 getSelectionRange(function(params){}) 获取文本选区 setTextFormatter(params) 对输入的内容进行 进行正则匹配 123456789101112formatRule 格式化匹配的正则表达式formatReplace 格式化匹配后用于替换的内容recoverRule 从格式化后的内容还原原始内容的正则表达式recoverReplace 还原原始内容时用于替换的内容this.$refs.input1.setTextFormatter(&#123; formatRule: &quot;/(\\d&#123;4&#125;)(?!$)/g&quot;, formatReplace: &quot;$1#&quot;, recoverRule: &quot;/#/g&quot;, recoverReplace: &quot;&quot; &#125;) 示例 12345678910&lt;input class=&quot;input&quot; type=&quot;date&quot;/&gt;&lt;input class=&quot;input&quot; type=&quot;time&quot; /&gt;&lt;input class=&quot;input&quot; type=&quot;text&quot; placeholder=&quot;default&quot; return-key-type=&quot;default&quot; /&gt;&lt;input class=&quot;input&quot; type=&quot;text&quot; placeholder=&quot;go&quot; return-key-type=&quot;go&quot; /&gt;&lt;input class=&quot;input&quot; type=&quot;text&quot; placeholder=&quot;next&quot; return-key-type=&quot;next&quot; /&gt;&lt;input class=&quot;input&quot; type=&quot;text&quot; placeholder=&quot;search&quot; return-key-type=&quot;search&quot; /&gt;&lt;input class=&quot;input&quot; type=&quot;text&quot; placeholder=&quot;send&quot; return-key-type=&quot;send&quot; /&gt;&lt;input class=&quot;input&quot; type=&quot;text&quot; placeholder=&quot;done&quot; return-key-type=&quot;done&quot; /&gt;&lt;input ref=&quot;widget&quot; class=&quot;input&quot; type=&quot;text&quot; @focus=&quot;handleFocus&quot; @blur=&quot;handleBlur&quot; @return=&quot;handleReturn&quot; /&gt; textarea 支持多行输入 支持input所有的事件，属性 样式 属性 row 控制输入的行数 waterfall 瀑布流 /collectionView? 类似iOS 多行 collectionview控制瀑布流 子组件 只能是四种组件 和 fix定位组件 refresh header cell loading 属性 show-scrollbar 是否显示出现滚动条 column-count 控制显示的列数 auto:根据column-width一列宽自动显示；number column-width 一列的宽度 auto:根据column-count自动分割；number column-gap 列之间的间隙 默认是32 left-gap 左侧cell与边框的间距 right-gap 右侧cell与边框的间距 事件 支持所有的通用事件；click；longpress；appear;disappear 实例 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;waterfall class=&quot;page&quot; ref=&quot;waterfall&quot; :column-width=&quot;columnWidth&quot; :column-count=&quot;columnCount&quot; :column-gap=&quot;columnGap&quot; :show-scrollbar=&quot;showScrollbar&quot; :scrollable=&quot;scrollable&quot; @scroll=&quot;recylerScroll&quot; @loadmore=&quot;loadmore&quot; loadmoreoffset=3000 &gt; &lt;refresh class=&quot;refresh&quot; @refresh=&quot;onrefresh&quot; @pullingdown=&quot;onpullingdown&quot; :display=&quot;refreshing ? &apos;show&apos; : &apos;hide&apos;&quot;&gt; &lt;loading-indicator class=&quot;indicator&quot;&gt;&lt;/loading-indicator&gt; &lt;text class=&quot;refreshText&quot;&gt;&#123;&#123;refreshText&#125;&#125;&lt;/text&gt; &lt;/refresh&gt; &lt;header class=&quot;stickyHeader&quot; &gt; &lt;div v-if=&quot;stickyHeaderType === &apos;none&apos;&quot; class=&quot;stickyWrapper&quot;&gt; &lt;text class=&quot;stickyText&quot;&gt;Header&lt;/text&gt; &lt;/div&gt; &lt;/header&gt; &lt;cell v-for=&quot;(item, index) in items&quot; :key=&quot;item.src&quot; class=&quot;cell&quot; ref=&quot;index&quot;&gt; &lt;div class=&quot;item&quot; @click=&quot;onItemclick(item.behaviour, index)&quot; @appear=&quot;itemAppear(item.src)&quot; @disappear=&quot;itemDisappear(item.src)&quot;&gt; &lt;text v-if=&quot;item.name&quot; class=&quot;itemName&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/text&gt; &lt;image class=&quot;itemPhoto&quot; :src=&quot;item.src&quot;&gt;&lt;/image&gt; &lt;text v-if=&quot;item.desc&quot; class=&quot;itemDesc&quot;&gt;&#123;&#123;item.desc&#125;&#125;&lt;/text&gt; &lt;text v-if=&quot;item.behaviourName&quot; class=&quot;itemClickBehaviour&quot;&gt; &#123;&#123;item.behaviourName&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/cell&gt; &lt;header class=&quot;footer&quot; ref=&quot;footer&quot;&gt; &lt;text class=&quot;stickyText&quot;&gt;Footer&lt;/text&gt; &lt;/header&gt; &lt;div ref=&quot;fixed&quot; class=&quot;fixedItem&quot; @click=&quot;scrollToNext&quot;&gt; &lt;text class=&quot;fixedText&quot;&gt;bot&lt;/text&gt; &lt;/div&gt; &lt;/waterfall&gt;&lt;/template&gt; video 嵌入视频内容 text是唯一合法子组件 属性 src 内嵌指向的URL play-status 设置播放状态 ‘play’ ；‘pause’ auto-play 是否默认播放 默认是false poster 制定视频首图的图片链接 controls 是否显示回放控制面板 值‘controls’；‘nocontrols’ 默认显示‘controls’ 样式 默认支持所有通用样式 事件 start 当 playback 的状态是 Playing 时触发。 pause 当 playback 的状态是 Paused 时触发。 finish 当 playback 的状态是 Finished 时触发。 fail 当 playback 状态是 Failed 时触发 示例 1234567891011121314151617&lt;div&gt; &lt;video class=&quot;video&quot; :src=&quot;src&quot; autoplay controls @start=&quot;onstart&quot; @pause=&quot;onpause&quot; @finish=&quot;onfinish&quot; @fail=&quot;onfail&quot;&gt;&lt;/video&gt; &lt;text class=&quot;info&quot;&gt;state: &#123;&#123;state&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;div&gt; &lt;video class=&quot;video&quot; :src=&quot;src&quot; :play-status=&quot;state&quot;&gt;&lt;/video&gt; &lt;text class=&quot;btn&quot; @click=&quot;onclick&quot;&gt;&#123;&#123;state === &apos;pause&apos; ? &apos;播放&apos; : &apos;暂停&apos; &#125;&#125;&lt;/text&gt; &lt;/div&gt; onclick (event) &#123; const currState = this.state; console.log(currState); this.state = currState === &apos;pause&apos; ? &apos;play&apos; : &apos;pause&apos;; &#125; web 网页组件 用于在 WEEX 页面中显示由 src 属性指定的网页内容 不支持嵌套任何组件；必须指定宽高，否则不会起作用 属性 src 事件 appear;disappear;pagestart;pagefinish;error;receivedtitle; pagestart会在开始加载的时候调用 pagefinish会在web加载完成之后调用 error加载失败调用 receivedtitle加载web标题变化之后调用，android平台支持 借助webview module，对网页前进后退，刷新操作 示例 123456789101112131415161718192021222324252627282930313233343536373839&lt;div class=&quot;wrapper&quot;&gt; &lt;web @pagestart=&quot;onPageStart&quot; @pagefinish=&quot;onPageFinish&quot; @error=&quot;onError&quot; src=&quot;https://www.taobao.com/&quot;&gt; &lt;/web&gt; &lt;/div&gt; methods: &#123; goBack: function() &#123; var webview = weex.requireModule(&apos;webview&apos;); webview.goBack(this.$refs.webview); &#125;, goForward: function() &#123; var webview = weex.requireModule(&apos;webview&apos;); webview.goForward(this.$refs.webview); &#125;, reload: function() &#123; var webview = weex.requireModule(&apos;webview&apos;); webview.reload(this.$refs.webview); &#125;, onPageStart: function(e) &#123; this.pagestart = e.url; &#125;, onPageFinish: function(e) &#123; this.pagefinish = e.url; this.canGoBack = e.canGoBack; this.canGoForward = e.canGoForward; if (e.title) &#123; this.title = e.title; &#125; &#125;, onError: function(e) &#123; this.error = url; &#125;, onReceivedTitle: function(e) &#123; this.title = e.title; &#125; &#125; richtext 富文本 富文本组件 可以内嵌span a image,也可以被前面三个嵌套；span a 标签 是行内标签，image被显示为display:inline-block;循环嵌套不能超过255层，超过会被忽略子组件a 标签 在iOS上恒定是blue 样式，android上无限制 ；image 必须指定width，height； 属性 子节点的属性 image的属性 src图片链接； pseudo-ref. 开发者指定的索引，会被传给回调方法 itemclick a标签的属性 href 链接 span标签不支持任何属性，文本需要包在span里面，例&lt;span&gt;Hello World&lt;/span&gt; 样式 富文本和三种子组件拥有的样式 span/a /richtext：color，font-family，font-size, font-style, font-width, line-height; 不可被继承的background-color span text-decoration: none | underline | line-through, 默认值是 none richtext lines: 最大行数，必须为正数 image width / height 事件 支持所有的通用样式 和 itemclick， itemclick触发时机； image被点击；没有任何父级a节点；image的pseude-ref作为参数回传，可进行判断 示例 123456789101112131415161718192021222324 &lt;div&gt; &lt;richtext @itemclick=&quot;listener&quot; style=&quot;color:red;text-overflow:ellipsis&quot;&gt; &lt;span&gt;link&lt;/span&gt; &lt;a href=&quot;http://t.cn?_wx_tpl=http://g.tbcdn.cn/ali-wireless-h5/res/0.0.16/hello.js&quot;&gt; &lt;image style=&quot;width:150; height:150&quot; src=&quot;https://img.alicdn.com/tps/i2/TB1hRb1IXXXXXX3XVXXXQaP.pXX-87-87.jpeg&quot; pseudo-ref=&quot;22&quot;&gt;&lt;/image&gt; &lt;span style=&quot;font-size:42;color:#FF5400;&quot;&gt;TAOBAO&lt;/span&gt; &lt;/a&gt; &lt;image style=&quot;width:300; height:300&quot; src=&quot;http://www.fresher.ru/manager_content/images2/kadry-veka/big/2-1.jpg&quot; pseudo-ref=&quot;23&quot;&gt;&lt;/image&gt; &lt;span&gt;继承Transition继承Transition继承Transition继承Transition继承Transition继承Transition继承Transition继承Transition继承Transition&lt;/span&gt; &lt;/richtext&gt;&lt;/div&gt;methods: &#123; listener: function (foo) &#123; var modal = weex.requireModule(&apos;modal&apos;); modal.toast(&#123; &apos;message&apos;: &apos;My pseudoRef is&apos;+foo.pseudoRef, &apos;duration&apos;: 3 &#125;); &#125;&#125;]]></content>
      <categories>
        <category>Weex</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Weex学习笔记1]]></title>
    <url>%2F2019%2F03%2F02%2FVue%2FWeex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[学习目标 Weex 常用的组件 ；和原生的交互；原生调用Weex组件；封装原生组件； 公用参数1.Weex WXEnvironment 环境变量 weex.config.env === WXEnvironment paltform 设备类型 iOS android web weexVersion Weex SDK 版本 appName appVersion osName iOS / Android deviceModel 设备型号 deviceWidth 设置宽 deviceHeight 设备高 2.document 当前页面的文档模型对象 可以操作创建DOM数中元素 不建议再开发页面的时候使用 3.requireModule 引入模块简单使用 引入模块 可以引入原生模块 / weex 内置的模块 1weex.requireModule(name:string):Object | void; 有返回值，可以为undefined 12345678910template 中&lt;text @click='modaltext'&gt;点击弹框提示&lt;/text&gt;script中 const modal = weex.requireModule('modal')modaltext()&#123; modal.toast(&#123; message:'测试2秒', duration:2,&#125;) 4.supports 检测是否支持某个功能 可以检测某个功能在当前环境中是否可用 weex.supports(@{type}/{name})type 为component时检测组件是否存在；type是module时检测模块是否存在 ;name.fun 可以检测模块下有没有某个方法名 12345678910111.检测组件是否存在weex.supports('@component/slider') // trueweex.supports('@components/sliderbar') // false2.检测模块是否存在weex.supports('@module/store') // trueweex.supports('@module/abcdef') // false3.检测模块下是否有某个方法weex.supports('@module/dom.getComponentRect') // trueweex.supports('@module/navigator.jumpToPage') // false 5.isRegisteredModule 检测某个特定模块 / 接口 是否可用 只用于模块检测，组件不适用6.isRegisteredComponent 检测特定组件是否可用， 只用于组件检测，模块不适用12345weex.isRegisteredModule(moduleName: string, methodName: string): booleanweex.isRegisteredComponent(componentName: string): boolean weex.isRegisteredModule('stream') // trueweex.isRegisteredComponent('div') // true 组件 通用样式/通用事件1.通用样式 weex 支持的所有通用样式 盒模型 weex 和模型是border-box 宽高 = (content宽高 + padding + border) 12345671.只支持overflow:hidden2.width/ height / padding 3.border-style 统一设置 或 给四个边分别设置border-top-style (solid / dashed / dotted)4.border-width 统一设置 或 分别设置上下左右 border-top-width5.border-color 统一设置 或 分别设置四边 border-top-color6.border-radius 统一设置 或 分别设置四边 border-top-radius7.margin 外边距 Flexbox weex中唯一且默认的布局模型 默认display:flex 123456789101.direction 决定文字方向和flex容器的基线方向 从左到右ltr，从右到左rtf2.flex-direction :column / column-reverse / row / row-reverse column 从上到下 column-reverse 从下到上；row 横线展示，与direction结合显示，ltr:leftToRight 从左到右显示3.flex-wrap 决定是一行显示还是多行显示 nowrap(不换行一行显示) / wrap(换行显示) / wap-reverse (换行但是方向 和direction相反)4.justify-content:定义了在主轴上处理空白逻辑 flex-start / flex-end / center / space-between flex-start 默认上排在前面 / flex-end 排在后面 / center 居中两边留白 / space-between 两边对其 中间空白均分5.align-items 定义在纵轴上如何显示 flex-start(上对齐) / flex-end(下对齐) / center(中间对齐) / stretch(默认值 充满高度)6.flex flex: 2 子类根据flex 权重分享父控件的空间 定位 支持position 设置position之后，可以设置top / bottom / left / right 121.position relative(相对) / absolute(绝对) / fixed(相对窗口) / sticky(滚动到页面之外会固定到页面顶) 2. weex 不支持 z-index，后面的会覆盖之前的 Transition 动画 CSS的属性值可以使用Transition 进行layoutanimation 123451.transition-property 过度动画的属性名width/height/top/bottom/left/right/opacity/background-color/transform2.transition-duration 过度动画的持续时间3.transition-delay 动画延迟4.transition-timing-function 描述执行动画的过度曲线 默认是ease /ease-in/ease-out/ ease-in-out/linear 1234567891011121314&lt;style scoped&gt; .panel &#123; margin: 10px; top:10px; align-items: center; justify-content: center; border: solid; border-radius: 10px; transition-property: width, height, background-color; transition-duration: 0.3s; transition-delay: 0s; transition-timing-function: cubic-bezier(0.25, 0.1, 0.25, 1.0); &#125;&lt;/style&gt; Transform 位移动画/ 旋转动画/ 缩放动画 1234567891011121314translate位移 / scale缩放 / rotate旋转1.位移 translate() / translateX(x) / translateY(y) 2.缩放 scale() / scaleX(x) / scaleY(y)3.旋转 rotate() / rotateX() / rotateY()4.透视 perspective()5.transform-origin(0/10%/top/left/right/bottom) 设置元素变形的锚点.transform &#123; align-items: center; transform: translate(150px, 200px) rotate(20deg); transform-origin: 0 -250px; border-color:red; border-width:2px;&#125; 伪类 active focus disable enable 所有组件都支持 active 但是只有input 支持focus disable enable / 优先级 css 权重优先级 线性渐变 通过background-image设置线性渐变 12341.三个参数，位置，开始颜色，结束颜色background-image:linear-gradient(to top, #a80077, #66ff00)位置参数 ：to right / to left / to top / to bottom / to bottom right(右下) / to top left(左上) 阴影(box-shadow) 只支持iOS，android使用图片代替 12345678910111213141516171819202122box-shadow:inset,x-offset,y-offset,radius,colorinset :默认外边框。设置inset之后是设置内边框radius: 值越大，边缘越模糊，阴影模糊效果.box1 &#123; box-shadow: 20px 10px rgb(255, 69, 0);&#125;.box2 &#123; box-shadow: 20px 10px 5px rgba(255, 69, 0, 0.8);&#125;.box3 &#123; box-shadow: inset 20px 10px 5px rgba(255, 69, 0, 0.8);&#125;.box4 &#123; box-shadow: inset 20px 10px 5px rgb(255, 69, 0);&#125;.box5 &#123; box-shadow:20px 10px 5px black;&#125;.box6 &#123; box-shadow:20px 10px 5px #008B00;&#125; 文本样式 text input richtext 公用的文本样式 1234567891011color: red / #EEE / #FF0000 / rgba(255, 0, 0, 0.5) / rgb(255, 0, 0)font-size:12font-style:normal / italicfont-weight:normal / bold / 100 - 900 / normal 是400 ，bold 是700；iOS支持7种，andriod支持400 / 700 两种text-decoration: none / underline / line-through text-align: left / center / rightfont-family :平台默认字体，可设置自定义字体text-overflow:clip(裁剪) / ellipsis(省略号)lines:3 最大文本行数line-height:文字高度 CSS单位 weex 中只支持px为单位; 2.通用事件 click 点击事件 input/switch组件 没有click时间，change方法 或input事件 事件对象 handleClick(event) / event.type:click / event.target / event.timestamp longpress长按事件 用户长按会触发 事件对象handleLongpress(event) / event.type:longpress / event.target / event.timestamp Appear 组件显示到屏幕上 当这个组件的状态在屏幕上显示时 调用 事件对象handleAppear(evevnt) / event.type:appear / event.target / event.timestamp / event.direction :up dowm Disappear 滑出屏幕出发 绑定了disappear事件，当组件滑出屏幕的时候触发事件。 事件对象 handleDisappear(event) / event.type:disappear / event.target / event.timestamp / event.direction:up dowm stopPropagation 组织native事件进行冒泡传递 结合shouldStopPropagationInterval / shouldStopPropagationInitResult 属性来控制 shouldStopPropagationInitResult 默认初始化false/true的结果。 shouldStopPropagationInterval 默认数字类型，控制touch频率，减少JS和Native通信次数，提升流畅性 1234567891011121314151617181920212223242526272829303132 在iOS设备上 禁止冒泡。 &lt;list class="list" show-scrollbar="false" @stoppropagation="Env.platform === 'iOS' ? false : true" shouldStopPropagationInterval="1000000" shouldStopPropagationInitResult="false"&gt; &lt;/list&gt; &lt;scroller class="home" @scroll="scrollHandler" show-scrollbar=false&gt; &lt;div class="menu"&gt; &lt;div class="menuPanel" @swipe="swipeEvent" :style="&#123; left: activeTab * -750 + 'px'&#125;"&gt; &lt;!-- 杭务公告 --&gt; &lt;div class="menuContent"&gt; &lt;div class="contentList"&gt; &lt;list class="list" show-scrollbar="false" @stoppropagation="Env.platform === 'iOS' ? false : true" shouldStopPropagationInterval="1000000" shouldStopPropagationInitResult="false"&gt; &lt;cell class="listPanel" v-for="(list, index) in lists1" :key="index" :ref="'hwgg' + index"&gt; &lt;div class="circle_dot"&gt;&lt;/div&gt; &lt;text class="listTitle"&gt;&#123;&#123;index&#125;&#125;&#123;&#123;list.title&#125;&#125;&lt;/text&gt; &lt;text class="listTime"&gt;&#123;&#123;list.showtime.split('-').join('.')&#125;&#125;&lt;/text&gt; &lt;/cell&gt; &lt;/list&gt; &lt;/div&gt; &lt;div class="loadMoreFirst"&gt; &lt;text class="loadMoreTxt"&gt;&#123;&#123;loadMore1 === 1 ? '更多' : '点击收起'&#125;&#125;&lt;/text&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/scroller&gt; Page 通过viewappear / viewdisappear提供页面的状态管理 viewappear 事件会在页面就要显示或配置的任何页面动画被执行前触发，例如，当调用 navigator 模块的 push 方法时，该事件将会在打开新页面时被触发。 viewdisappear 事件会在页面就要关闭时被触发。 与组件的 appear 和 disappear 事件不同的是，viewappear 和 viewdisappear 事件关注的是整个页面的状态，所以它们必须绑定到页面的根元素上。 特殊情况下，这两个事件也能被绑定到非根元素的body组件上，例如wxc-navpage组件 事件对象 handleAppear(e,name) / handleDisappear(e,name) / e.type / e.target / e.timestamp 12345678910111213&lt;div class="btn block" @appear="(e) =&gt; &#123; handleAppear(e, 'block1'); &#125;" @disappear="(e) =&gt; &#123; handleDisappear(e, 'block1') &#125;"&gt; &lt;text class="btn-text"&gt;block1&lt;/text&gt;&lt;/div&gt;&lt;div class="btn block" @appear="(e) =&gt; &#123; handleAppear(e, 'block2'); &#125;" @disappear="(e) =&gt; &#123; handleDisappear(e, 'block2') &#125;"&gt; &lt;text class="btn-text"&gt;block2&lt;/text&gt;&lt;/div&gt; 事件冒泡 捕获 / 冒泡 weex 0.13版本冒泡 默认是不开启冒泡事件，需要在根元素开启bubble=true 阻止冒泡 event.stopPropagation ；影响范围，当前元素和父级之前的元素，子类元素不影响。 bubble=true 是全局开关，全部开启，全部关闭 手势 Touch / Pan / Swipe / LongPress 只需要在组件上监听手势即可 touchstart/ touchend / touchmove / stopPropagation Pan 拖动 ，精确性差于touch panstar / panend/ panmove / horizontalpan / verticalpan (0.10+) Swipe 轻扫 一次联系的滑动出发一次swipe事件 返回direction滑动方向 longPress 在触摸点联系 500ms之上出发 changedTouches 一组手势对象的数组 其中一个对象含有 identifier / pagex / pageY / screenX / screenY / force 通信跨页面通信 BroadcastChannel(‘name’) 同源跨页面通信，逆向传值 同级别传值 子传父。初步理解先监听后发送。 1234567891011121.父监听广播const channe1 = new BroadcastChannel('hl-le')channel.onmessage = function (event) &#123; console.log(event.data)&#125;2.子组件触发事件 发送消息const channe1 = new BroadcastChannel('hl-le')channel.postMessage('apuedmessage')3.传入的参数是指针地址，没有深拷贝。如果传入的数组，接收方修改数组，发送方的值也会跟着改变 Android接口 / Weex通信iOS接口 / Weex通信JSServer JS生命周期 提供创建 刷新 销毁生命周期]]></content>
      <categories>
        <category>Weex</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[weex环境配置]]></title>
    <url>%2F2019%2F03%2F01%2FVue%2FWeex%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[1.配置weex 1，按照官网 npm i weex-toolkit@beta -g 12345678npm WARN deprecated socks@1.1.10: If using 2.x branch, please upgrade to at least 2.1.6 to avoid a serious bug with socket data flow and an import issue introduced in 2.1.0/usr/local/bin/weex -&gt; /usr/local/lib/node_modules/weex-toolkit/bin/weex.js&gt; spawn-sync@1.0.15 postinstall /usr/local/lib/node_modules/weex-toolkit/node_modules/spawn-sync&gt; node postinstall+ weex-toolkit@2.0.0-beta.5added 204 packages from 200 contributors, removed 3052 packages, updated 46 packages and moved 74 packages in 48.03s 2查看安装好的版本 weex -v 123456789101112131415161718192021222324Start installing Core, please wait ...✔ Installed 1 packages✔ Linked 392 latest versions✔ Run 0 scriptsdeprecate @weex-cli/core@2.0.0-beta.5 › metalsmith@2.3.0 › gray-matter@2.1.1 › coffee-script@^1.12.4 CoffeeScript on NPM has moved to "coffeescript" (no hyphen)deprecate @weex-cli/core@2.0.0-beta.5 › npminstall@3.20.2 › urllib@2.33.0 › proxy-agent@2.3.1 › socks-proxy-agent@3.0.1 › socks@^1.1.10 If using 2.x branch, please upgrade to at least 2.1.6 to avoid a serious bug with socket data flow and an import issue introduced in 2.1.0Recently updated (since 2019-03-13): 5 packages (detail see file /Users/maylover/.wx/core/node_modules/.recently_updates.txt) Today: → @weex-cli/core@latest(2.0.0-beta.5) (11:24:56) 2019-03-18 → @weex-cli/core@2.0.0-beta.5 › inquirer@6.2.2 › strip-ansi@^5.0.0(5.2.0) (16:46:18) 2019-03-17 → @weex-cli/core@2.0.0-beta.5 › handlebars@^4.0.11(4.1.1) (05:29:12) 2019-03-16 → @weex-cli/core@2.0.0-beta.5 › chrome-opn@1.0.1 › opn@^5.4.0(5.5.0) (14:10:14) → @weex-cli/core@2.0.0-beta.5 › handlebars@4.1.1 › uglify-js@^3.1.4(3.4.10) (02:25:03)✔ All packages installed (433 packages installed from npm registry, used 34s(network 34s), speed 253.01kB/s, json 393(699.53kB), tarball 7.81MB)Start checking Core, please wait ...compelied, cost 34.676s? May weex-toolkit anonymously report usage statistics to improve the tool over time? Yes? Which npm registry you perfer to use? taobao2.0.0-beta.5 3.查看weex 命令 weex –help。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566Weex Cli| Synopsis | Usage || ------------------ | --------------------------------------------------------------------- || General | $ weex &lt;Command&gt; [Command Parameters] [--command &lt;Options&gt;] |# General Commands| Command | Description || ----------------------------- | ----------------------------------------------------------------------------------------------------- || help &lt;Command&gt; | Shows additional information about the commands in the terminal. || doctor | Checks your system for configuration problems which might prevent the Weex CLI from working properly. || repair &lt;Command&gt; | Repair cli dependencies or the core. || install &lt;Package&gt; | Install plugin for the Weex Cli. || uninstall &lt;Package&gt; | Uninstall plugin for the Weex Cli. |# Project Development Commands| Command | Description || ------------------------------------- | --------------------------------------------- || create &lt;template-name&gt; [project-name] | Create a weex project. || debug &lt;file|folder&gt; | Start weex debugger. || compile [source] [target] | Compile .we/.vue file. || preview [file|folder] | Preview a weex page. || platform | Manage ios/android platforms. || platform add &lt;Platform&gt; | Add ios/android platform. || platform remove &lt;Platform&gt; | Remove ios/android platform. || platform list | List ios/android platform. || platform update &lt;Platform&gt; | Update ios/android platform. || plugin | Manage weex plugins. || plugin add &lt;Plugin&gt; | Add weex ios/android/web plugin. || plugin remove &lt;Plugin&gt; | Remove weex ios/android/web plugin. || plugin install &lt;Platform&gt; | Install plugin for specified platform. || plugin create [plugin] | Create a weex plugin template. || run &lt;Platform&gt; | Build android/ios application and run. || build &lt;Platform&gt; | Build android/ios application for production. || lint &lt;file|folder&gt; | Lint codes and generate code report. |# Device Commands| Command | Description || ----------------- | ----------------------------------------------------------- || device run | Choose one simulator to run. || device list | Lists all recognized connected physical or virtual devices. |# Configuration Commands| Command | Description || ------------------------ | --------------------------------- || config | Configure Weex Toolkit settings. || config set &lt;key&gt; &lt;value&gt; | Set key-value. || config get &lt;key&gt; | Get value by key. || config list [--json] | List key-value as string or json. || config delete &lt;key&gt; | Delete key-value by key. |# Third Part Commands| Command | Description || ----------------- | --------------------- |# Global Options| Option | Description || ---------------- | ------------------------------------------------------ || --help, -h | Prints help about the selected command in the console. || --version | Prints the client version. | 4.创建一个新项目 weex create firstweex 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778✔ Installed 1 packages✔ Linked 151 latest versions✔ Run 0 scriptsdeprecate @weex-cli/generator@2.0.0-beta.3 › metalsmith@2.3.0 › gray-matter@2.1.1 › coffee-script@^1.12.4 CoffeeScript on NPM has moved to "coffeescript" (no hyphen)Recently updated (since 2019-03-13): 2 packages (detail see file /Users/maylover/.wx/modules/node_modules/.recently_updates.txt) 2019-03-17 → @weex-cli/generator@2.0.0-beta.3 › handlebars@^4.0.11(4.1.1) (05:29:12) 2019-03-16 → @weex-cli/generator@2.0.0-beta.3 › handlebars@4.1.1 › uglify-js@^3.1.4(3.4.10) (02:25:03)✔ All packages installed (163 packages installed from npm registry, used 9s(network 9s), speed 257.93kB/s, json 152(255.73kB), tarball 2.12MB)Start checking package, please wait ...compelied, cost 9.653s? Project name firstweex? Project description A weex project? Author yutao &lt;ytxinguan035@163.com&gt;? Select weex web render lts? Babel compiler (https://babeljs.io/docs/plugins/#stage-x-experimental-presets) stage-0? Use vue-router to manage your view router? (not recommended) Yes? Use ESLint to lint your code? No? Pick an ESLint preset none? Set up unit tests No? Should we run `npm install` for you after the project has been created? (recommended) npm# Installing project dependencies ...# ========================npm WARN deprecated babel-preset-es2015@6.24.1: ???? Thanks for using Babel: we recommend using babel-preset-env now: please read babeljs.io/env to update! npm WARN deprecated browserslist@1.7.7: Browserslist 2 could fail on reading Browserslist &gt;3.0 config used in other tools.npm ERR! Unexpected end of JSON input while parsing near '...cc56bc9d1a87f9e857e60'npm ERR! A complete log of this run can be found in:npm ERR! /Users/maylover/.npm/_logs/2019-03-20T07_32_14_226Z-debug.logSuccess! Created firstweex at /Users/maylover/firstweexInside that directory, you can run several commands: npm start Starts the development server for you to preview your weex page on browser You can also scan the QR code using weex playground to preview weex page on native npm run dev Open the code compilation task in watch mode npm run ios (Mac only, requires Xcode) Starts the development server and loads your app in an iOS simulator npm run android (Requires Android build tools) Starts the development server and loads your app on a connected Android device or emulator npm run pack:ios (Mac only, requires Xcode) Packaging ios project into ipa package npm run pack:android (Requires Android build tools) Packaging android project into apk package npm run pack:web Packaging html5 project into `web/build` folder npm run test Starts the test runnerTo get started: cd firstweex npm startEnjoy your hacking time!mayloverdeMacBook-Pro:~ maylover$ 5.cd 到目录下，npm statr 报错 121.解决办法：npm cache clean --force2.重新 npm start 启动web服务 2.配置weex ios 环境 cd platforms/ios 下，执行pod install 将安装podfile 中的SDK commond + r 执行模拟器运行。 3.配置weex andriod 环境 weex platform add android weex run android 会报错；下载了Android Studio 装了SDK 但是没有下载模拟器 1Error: &#123;"ErrorMemory":"ErrorMemory","type":"ANDROID_EMULATOR_NOT_FIND","message":"Not find android emulator!"&#125; 下载Android Studio 之后，会提示安装SDK，直接安装，不需要翻墙，网速很慢 3-5个小时 之后打开platform 中的android 项目，会进行进度条编译 下载gradle-2.14.1 很慢 3-5 个小时 坑1 gradle-2.14.1-all 文件会很慢 12因为Android Studio 3.0使用的gradle版本是gradle-4.4-all，而wanandroid-weex项目中使用的是gradle-2.14.1-all版本，所以，如果在本地没有这个包，会显示在下载状态，除非翻墙下载，不然会很慢，可以在这里gradle-2.14.1-all ，密码是：3noj。 安装模拟器 选择一个device 安装模拟器下载 ，多次下载错误，网络原因，3次尝试之后安装成功 2天 1点击手机按钮，弹出选择设备，选择设备，下载。 修改 weex 项目中代码后，weex run android。 目前终端会提示Building APP - this may take a few seconds 一直在转。猜测是拷贝中那个地方有问题 继续打开 Android Studio run 选择模拟器就可以跑起来了。]]></content>
      <categories>
        <category>Weex</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-web01-Java]]></title>
    <url>%2F2019%2F01%2F02%2FAndroid%2FAndroid-web01%2F</url>
    <content type="text"><![CDATA[1.开发环境搭建 需要JDK 和Android studio2.Android 架构 5个部分 四个主要层 从下向上 Linux内核层 linux kernel 程序库安卓程序库，libraries 安卓运行时 android runtime 应用框架 application framework 应用程序；Applications ###（1）linux 内核层，提供基本的系统功能：进程 内存 设备管理 网络，大量设备的驱动 ###（2.1）程序库 webkit ;libc库 ；SQLite 数据库，视频播放，音频播放的库等。网络安全的SSL库 android 程序库 专门未android开发的基于JAVA的程序库； android.app 提供程序模型的访问 android.content 程序间的；程序组件间的；内容访问，发布，消息传递等 android.database 包含sqllite 数据库管理类 android.opengl OpenGL ES 3.0 图像渲染API 的接口 android.os 提供APP 访问标注操作系统的能力；包括消息，系统服务，进程间通信 android.text 在设备上渲染和操作文字 android.view 用户界面的基本模块 android.widget 与设置的用户组件组合；比如按钮，标签，列表，布局管理，单选按钮等； android.webkit 提供内置web浏览能力 ###（2.2）android 运行时；提供给 Dalvik虚拟机 关键组件 类似于java虚拟机；但是专门为android 提供设计和优化； 可以在java中运行linux核型功能；多线程 内存管理；每一个android程序 都有一个android虚拟机进程； ###（3）应用框架 - 提供许多高级的服务。 活动管理者 控制应用程序生命周期 和 活动栈 内容提供者 允许程序之间的发布；分享数据 资源管理者 提供对非代码嵌入资源的访问；字符串 颜色设置。用户界面布局 通知管理者 允许程序 显示对话框通知给用户 视图系统 可扩展的视图集合。用于创建用户界面###（4）所有的apk 文件被安装这一层次。包括通讯录等 3.android 应用程序组件分四类 Activities / Services / Broadcast Receivers / Content Providers ###(1)Activities 一个活动标识一个具有用户界面的单一屏幕；12class MyActivities extends Activity &#123;&#125; ###(2)services 服务运行在后台 执行耗时操作的组件12public class MyServices extends Service&#123;&#125; ###(3)Broadcast Receivers广播接收器 简单的响应从其他应用程序 或者系统内发出的广播消息； 12public class MyReceiver extends BroadcastReceiver&#123;&#125; ###(4) Content Providers 内容提供组件 请求一个应用程序 到另一个应用程序的提供数据 这些请求类由ContentResolver来处理，这些数据 可以能来自 文件系统，数据库。 12public class MyContentProvider extends ContentProvider&#123;&#125; ###(5)其他组件 Fragments 代表活动的一个行为 或者是一个活动界面 Views 绘制在界面上的元素，按钮 文字等 Layouts 控制屏幕的格式。显示视图外观的继承关系； intents 组件之间的消息连线 Resources 外部元素 例如字符串资源 常量资源 一些图片等 Manifest 应用程序的配置文件 4.Android 应用目录分析 src 文件夹 包含项目中的所有 java 文件；默认情况下 包含MainActivity.java 程序其中执行 gen 文件夹 编译器生成的.R 文件； src/main/res 存放资源文件 src/main/res/values 存放一系列资源的XML 文件；字符串和颜色的定义 src/main/res/layout 存放用户定义界面的布局文件 src/main/res/drawable 存放公用组件的布局文件 src/main/res/drawable-xxhdpi 存放不同分辨率下的图片文件 src/main/AndroidManifest.xml 应用程序的清单文件，描述应用程序的基础特性，定义各种组件。 java文件，被Dalvik虚拟机 转化成可执行文件 12345678910111213141516171819package com.example.helloworld;import android.os.Bundle;import android.app.Activity;import android.view.Menu;import android.view.MenuItem;import android.support.v4.app.NavUtils;public class MainActivity extends Activity&#123; @Override public void onCreat(Bundle savedInstanceState)&#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) &#125; @Override public boolean onCreateOptionsMenu(Menu menu)&#123; getMenuInflater().infalte(R.menu.activity_menu,menu) return true &#125;&#125; Manifest文件；无论什么组件，都需要在此文件中声明；是Android系统 和APP 之间的接口；一个默认的文件如下 1234567891011121314151617181920212223242526272829303132&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.example.helloworld" android:versionCode="1" android:versionName="1.0"&gt; &lt;uses-sdk android:minSdkVersion="8" android:targetSdkVersion="22"/&gt; &lt;application android:icon="@drawable/ic_launcher" android:lable="@string/app_name" android:theme="@style/Apptheme"&gt; &lt;activity android:name=".MainActivity" android:lable="@string/title_activity_main"&gt; &lt;intent-filter&gt; &lt;action andriod:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt;说明：1.application标签之间是应用程序相关的组件。andnroid:icon属性指出位于res/drawable-xxhdpi下面的应用程序图标。这个应用使用drawable文件夹下名为ic_launcher.png的图片。2.activity 标签用于指定一个活动，android:name属性指定一个Activity类子类的全名。android:label属性指定用于活动名称的字符串。可以使用标签来指定多个活动。3.intent-filter action被命名为android.intent.action.MAIN，表明这个活动被用做应用程序的入口。4.intent-filter category被命名为android.intent.category.LAUNCHER，表明应用程序可以通过设备启动器的图标来启动。5.@string指的是strings.xml .因此，@string/app_name指的是定义在strings.xml中的app_name，实际为"Hello World"。 strings.xml文件在res/value文件夹下 123456&lt;resources&gt; &lt;string name="app_name"&gt;HelloWorld&lt;/string&gt; &lt;string name="hello_world"&gt;Hello world!&lt;/string&gt; &lt;string name="menu_settings"&gt;Settings&lt;/string&gt; &lt;string name="title_activity_main"&gt;MainActivity&lt;/string&gt;&lt;/resources&gt; R 文件 如MainActivity.java的和资源如strings.xml之间的胶水。 Layout文件 布局。 1234567891011121314151617181920&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_centerHorizontal="true" android:layout_centerVertical="true" android:padding="@dimen/padding_medium" android:text="@string/hello_world" tools:context=".MainActivity" /&gt;&lt;/RelativeLayout&gt;注：1. layout_width match_parent / wrap_content 2. layout_centerHorizontal3. layout_conterVertical 5.资源访问 Resource项目中需要用到的各种各样的资源 ；位图 ，颜色，布局定义，用户界面字符串，动画等 一般都放置在res文件夹下 目录 资源类型 anim/ 定义动画属性的XML文件 通过 R.amin.XX 访问 color/ 定义颜色列表的xml 通过R.color.XX 访问 drawable/ 图片文件 通过R.drawable.image1**访问 layout/ 定义布局，通过R.layout menu/ 定义程序菜单的XML文件，比如选项菜单，上下文菜单，子菜单等 被保存在res/menu 下，通过R.menu.xx访问 raw/ 任意的文件 以他们的原始形式保存 需要根据名为R.raw.filename的资源ID，通过调用Resource.openRawResource()来打开raw文件。 values/ 包含简单的xml文件； arrays.xml代表数组资源，通过R.array类访问； integers.xml代表整数资源，通过R.integer类访问； bools.xml代表布尔值资源，通过R.bool类访问； colors.xml代表颜色资源，通过R.color类访问; dimens.xml代表维度值，通过R.dimen类访问； strings.xml代表字符串资源，通过R.string类访问； styles.xml代表样式资源，通过R.style类访问 xml/ 可以通过调用Resources.getXML()来在运行时读取任意的XML文件。可以在这里保存运行时使用的各种配置文件 ###(1) 替代资源 不同文件夹位置，会优先找替代的文件夹 需要为不同的屏幕分辨率提供替代的图片资源。drawable / drawable-hdpi / drawable-xxhdpi 下面是另外一个例子，指定默认语言的布局和阿拉伯语言的替代布局。layout / layout-ar ###(2) 访问资源 在xml文件中使用 (1)在xml 中使用 12345678910111213141.在res/values/string.xml中定义 一个颜色 和文字需要给每个标签定义name，方便取用&lt;resources&gt; &lt;color name="oper_red"&gt;#f00&lt;/color&gt; &lt;string name="hello"&gt; Hello !&lt;/string&gt;&lt;/resources&gt;2.在布局文件中使用&lt;EditText xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="fill_parent" android:layout_height="fill_parent" android:textColor="@color/oper_red" android:text="@string/hello" /&gt; ###(3) 访问资源 在Java代码中 使用图片 1234561.访问 res/drawable/myimage.png，并将其设置到 ImageView 上这里第一行代码用 R.id.myimageview 来在布局文件中获取定义为 myimageview 的 ImageView。第二行用 R.drawable.myimage 来获取在 res/ 的 drawable 子目录下名为 myimage 的图片ImageView aimageV = (ImageView) findViewById(R.id.myImageView)aimageV.setImageResource(R.drawable.myimage) 使用颜色 / 文字 1231.在 ID 为 msg 的 TextView 对象上使用资源 ID 来设置文本TextView atetx = (TextView) findViewById(R.id.msg)atex.setText(R.strng.hello) 使用布局文件xml 1234561.考虑如下定义的布局 res/layout/activity_main.xml2.代码将为活动加载这个布局，onCreate() 方法中如下：public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main_activity);&#125; 6.Activity 生命周期（1）调用顺序 唤起系统，到展示界面 launched-&gt; oncreate() -&gt; onStart() -&gt; onResume() -&gt; running… A界面上 点击按钮 push B界面出现 onPause() -&gt; onStoped() -&gt; onDestory B 界面上点了返回按钮 状态从onPause onPause() -&gt; onResume() -&gt; running… B 界面上点了按钮，pushA界面 onStop() -&gt; onRestart() -&gt; onStart() -&gt; onResume() -&gt; running… （2）方法含义 onCreate() 第一个触发，第一次创建的调用 onStart() 用户可见的时候调用 onResume() 用户可以交互的时候调用 onPause() 无法接受用户输入，不执行任何代码。当前A被暂停，上一个B将要被回复的时候时调用 ；当其他Activity 活到焦点的时候 A 调用 onStop() 不可见的时候调用 onDestory() 被系统销毁之前调用 onRestart() 被停止之后，重新打开的时候调用 7.Service 服务 服务是一个后台运行的组件，执行长时间运行且不需要用户交互的任务。即使应用被销毁也依然可以工作。服务基本上包含两种状态 Started 通过startService() 状态是started，一旦启动，就可以在后台无限运行，即时启动它的组件已经被销毁 Bound 当通过bindService()绑定过之后，。则服务是bound状态； bound状态的服务，提供了一个客户服务器接口；允许组件和服务之间进行交互，发送请求，获取结果 甚至通过IPC 进行跨进程之间通信 ###(1)Service生命周期 startService() -&gt; onCreate() -&gt; onStart() -&gt; servicerunning… -&gt; onDestory() bindService() -&gt; onCreate() -&gt; onBind() -&gt; Clineng…. onUnbind() - onDestory() onUnbind() -&gt; onRebind() (2)生命周期方法 创建服务，是要创建一个继承Service的基类 onStartCommand() 其他组件 通过startService() 来请求启动服务；如果实现该方法，有责任在工作完成时通过 stopSelef() stopService() 来停止服务 onBind() 当其他组件通过bindService() 来绑定服务时，系统调用该方法；实现该方法，允许绑定 返回Binder；不允许绑定 返回nil; Binder对象来提供一个接口，以便客户与服务通信 onUnbind() 当客户中断所有的服务发布的特殊接口的时候，系统调用该方法 onRebind() 当客户端与服务联连，并且是上次是用过onUnbind通知断开连接的 onCreat() 第一次创建的时候，要求执行一次性安装 onDestory() 服务不再有，或者被销毁的时候，系统调用该方法，需要实现该方法来清理的任何资源。如线程，已注册的监听器，接收器等。 ###(3)代码实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.runoob.androidservices;import android.app.Service;import android.os.IBinder;import android.content.Intent;import android.os.Bundle;public class HelloService extends Service &#123; /** 标识服务如果被杀死之后的行为 */ int mStartMode; /** 绑定的客户端接口 */ IBinder mBinder; /** 标识是否可以使用onRebind */ boolean mAllowRebind; /** 当服务被创建时调用. */ @Override public void onCreate() &#123; o&#125; /** 调用startService()启动服务时回调 */ @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; return mStartMode; &#125; /** 通过bindService()绑定到服务的客户端 */ @Override public IBindepublic IBinder onBind(Intent intent) &#123; r; &#125; /** 通过unbindService()解除所有客户端绑定时调用 */ @Override public boolean onUnbind(Intent intent) &#123; return mAllowRebind; &#125; /** 通过bindService()将客户端绑定到服务时调用*/ @Override public void onRebind(Intent intent) &#123; &#125; /** 服务不再有用且将要被销毁时调用 */ @Override public void onDestroy() &#123; &#125;&#125; ###(4)创建自己的Android服务 1.在MainActivity.java中实现 两个按钮 startService() stopService() 方法 点击触发service的方法 12345678910// Method to start the servicepublic void startService(View view) &#123; startService(new Intent(getBaseContext(), MyService.class));&#125;// Method to stop the servicepublic void stopService(View view) &#123; stopService(new Intent(getBaseContext(), MyService.class));&#125; 2.创建MyService.java 并实现服务相关的方法 1234567891011121314151617181920212223242526272829package com.runoob.androidservices;import android.app.Service;import android.content.Intent;import android.os.IBinder;import android.widget.Toast;public class MyService extends Service &#123; @Override public IBinder onBind(Intent arg0) &#123; return null; &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; // Let it continue running until it is stopped. Toast.makeText(this, "服务已经启动", Toast.LENGTH_LONG).show(); return START_STICKY; &#125; @Override public void onDestroy() &#123; super.onDestroy(); Toast.makeText(this, "服务已经停止", Toast.LENGTH_LONG).show(); &#125;&#125; 3.在Manifest.xml中定义service标签 1&lt;service android:name=".MyService" /&gt; 4在布局xml中增加两个按钮，停止开始服务 12345678910111213141516171819202122&lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:id="@+id/button2" android:text="启动服务" android:onClick="startService" android:layout_below="@+id/imageButton" android:layout_centerHorizontal="true" /&gt;&lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="停止服务" android:id="@+id/button" android:onClick="stopService" android:layout_below="@+id/button2" android:layout_alignLeft="@+id/button2" android:layout_alignStart="@+id/button2" android:layout_alignRight="@+id/button2" android:layout_alignEnd="@+id/button2" /&gt; 8.Broadcast Receiever 广播接收器 广播 ：事件/意图 可以通知其他应用，本应用已安装 有一些数据可以供他们用； 创建广播接收器/注册广播接收器 (1)创建广播 / 接受消息 创建继承BroadcastReceiver 的子类 重写onReceive方法 123456public class MyReceiver extends BroadcastReceiver &#123; @override public void onReceive(Context context,Intent intent)&#123; Toast.makeText(context,Intent Detected.", Toast.LENGTH_LONG).show()) &#125;&#125; (2)注册广播/注册广播的意图 在Manifest.xml 中，注册定义的MyReciver ,并在意图过滤中监听系统分BOOT_COMPLETED 12345678&lt;application&gt; &lt;receiver android:name="MyReceiver"&gt; &lt;intent-filter&gt; &lt;action andriod:name="andriod.intent.action.BOOT_COMPLETED"&gt; &lt;/action&gt; &lt;/intent-filter&gt; &lt;/receiver&gt;&lt;/application&gt; (3)系统的意图类型 事件常量 描述 android.intent.action.BATTERT_CHANGED 电池充电状态；级别；和其他信息 android.intent.action.BATTERT_LOW 低电量 android.intent.action.BATTERY_OKAY 在低电量之后 现在好了 android.intent.action.BOOT_COMLETED 系统启动完成后广播一次 android.intent.action.BUG_REPORT 显示报告bug的活动 android.intent.action.CALL 执行呼叫数据指定的某人 android.intent.action.CALL_BUTTON 用户点击呼叫按钮拨号按钮。或其他拨号的合适界面 android.intent.action.DATE_CHANGED 日期发生更改 android.intent.action.REBOOT 设备重启 （4）广播自定义的意图 在activity 中 创建一个方法broadcastIntent，按钮点击执行这个方法 broadcastIntent 中 创建意图，sendBroadcast(intet)发送意图 在manifest.xml 中注册自定义的意图 123456发送通知public void broadcastIntent(View view)&#123; Intent intent = new Intent(); intent.setAction("com.runoob.CUSTOM_INTENT"); sendBroadcast(intent);&#125; 1234567891011注册通知&lt;application android:icon="@drawable/ic_launcher" android:label="@string/app_name" android:theme="@style/AppTheme" &gt; &lt;receiver android:name="MyReceiver"&gt; &lt;intent-filter&gt; &lt;action android:name="com.runoob.CUSTOM_INTENT"&gt; &lt;/action&gt; &lt;/intent-filter&gt; &lt;/receiver&gt;&lt;/application&gt; 12345678910111213接受通知，弹框package com.runoob.broadcastreceiver;import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;import android.widget.Toast;public class MyReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context, "检测到意图。", Toast.LENGTH_LONG).show(); &#125;&#125; 9.Content Provider 内容提供者 在应用程序间共享数据 可以查询，编辑它的内容，使用 insert()， update()， delete() 和 query() 来添加或者删除内容。多数情况下数据被存储在 SQLite 数据库。 需要实现 ContentPrivider 的子类 需要实现一系列的API。 12public class MyProvider extends ContentPrivider&#123;&#125; (1)内容URI 下面格式 &lt;prefix&gt;://&lt;authority&gt;/&lt;data_type&gt;/&lt;id&gt; | content://contacts/people/5 prefix: 前缀 固定为content:// authority 授权 一般为包名， 系统的通讯录时contacts， 第三方的App：cn.programmer.statusprovider data_type 这个特殊的内容提供者中的数据的类型 id 这个指定特定的请求记录 (2)创建内容创造者 在MainActivity中增加两个方法，插入，查询。按钮触发 1234567891011121314151617181920212223 public void onClickName(View view)&#123; ContentValues values = new ContentValues() values.put(StudentProvider.Name,'lili') values.put(StudentProvider.GRADE,'98') Uri uri = getContentResolver().inser(StudentProvider.CONTEN_URI,value) (getBaseContent(),uri.toString(),Toast.LENGTH_LONG).show()&#125;public void onClickReadStdents(View view)&#123; String URL = "content://com.example.provider.College/students"; Uri students = Uri.parse(URL) Cursor c = manageQuery(students,null,null,null,'name') if(c.moveToFirst())&#123; do&#123; var st_id = c.getString(c.getColumnIndex(StudentProvider._ID)) var st_name = c.getString(c.getColumnIndex(StudentProvider.NAME)) var st_grade = c.getString(c.getColumnIndex(StudentProvider.GRADE)) Tost.makeText(this,(st_id + st_name + st_grade),Tost.LENGTH_SHORT).show() &#125;while (c.moveToNext()); &#125;&#125; 在StudentsProvider.java 实现数据库代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236package com.runoob.contentprovider;import java.util.HashMap;import android.content.ContentProvider;import android.content.ContentUris;import android.content.ContentValues;import android.content.Context;import android.content.UriMatcher;import android.database.Cursor;import android.database.SQLException;import android.database.sqlite.SQLiteDatabase;import android.database.sqlite.SQLiteOpenHelper;import android.database.sqlite.SQLiteQueryBuilder;import android.net.Uri;import android.text.TextUtils;public class StudentsProvider extends ContentProvider &#123; static final String PROVIDER_NAME = "com.example.provider.College"; static final String URL = "content://" + PROVIDER_NAME + "/students"; static final Uri CONTENT_URI = Uri.parse(URL); static final String _ID = "_id"; static final String NAME = "name"; static final String GRADE = "grade"; private static HashMap&lt;String, String&gt; STUDENTS_PROJECTION_MAP; static final int STUDENTS = 1; static final int STUDENT_ID = 2; static final UriMatcher uriMatcher; static&#123; uriMatcher = new UriMatcher(UriMatcher.NO_MATCH); uriMatcher.addURI(PROVIDER_NAME, "students", STUDENTS); uriMatcher.addURI(PROVIDER_NAME, "students/#", STUDENT_ID); &#125; /** * 数据库特定常量声明 */ private SQLiteDatabase db; static final String DATABASE_NAME = "College"; static final String STUDENTS_TABLE_NAME = "students"; static final int DATABASE_VERSION = 1; static final String CREATE_DB_TABLE = " CREATE TABLE " + STUDENTS_TABLE_NAME + " (_id INTEGER PRIMARY KEY AUTOINCREMENT, " + " name TEXT NOT NULL, " + " grade TEXT NOT NULL);"; /** * 创建和管理提供者内部数据源的帮助类. */ private static class DatabaseHelper extends SQLiteOpenHelper &#123; DatabaseHelper(Context context)&#123; super(context, DATABASE_NAME, null, DATABASE_VERSION); &#125; @Override public void onCreate(SQLiteDatabase db) &#123; db.execSQL(CREATE_DB_TABLE); &#125; @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; db.execSQL("DROP TABLE IF EXISTS " + STUDENTS_TABLE_NAME); onCreate(db); &#125;&#125;@Overridepublic boolean onCreate() &#123; Context context = getContext(); DatabaseHelper dbHelper = new DatabaseHelper(context); /** * 如果不存在，则创建一个可写的数据库。 */ db = dbHelper.getWritableDatabase(); return (db == null)? false:true;&#125;@Overridepublic Uri insert(Uri uri, ContentValues values) &#123; /** * 添加新学生记录 */ long rowID = db.insert( STUDENTS_TABLE_NAME, "", values); /** * 如果记录添加成功 */ if (rowID &gt; 0)&#123; Uri _uri = ContentUris.withAppendedId(CONTENT_URI, rowID); getContext().getContentResolver().notifyChange(_uri, null); return _uri; &#125; throw new SQLException("Failed to add a record into " + uri);&#125;@Overridepublic Cursor query(Uri uri, String[] projection, String selection,String[] selectionArgs, String sortOrder) &#123; SQLiteQueryBuilder qb = new SQLiteQueryBuilder(); qb.setTables(STUDENTS_TABLE_NAME); switch (uriMatcher.match(uri)) &#123; case STUDENTS: qb.setProjectionMap(STUDENTS_PROJECTION_MAP); break; case STUDENT_ID: qb.appendWhere( _ID + "=" + uri.getPathSegments().get(1)); break; default: throw new IllegalArgumentException("Unknown URI " + uri); &#125; if (sortOrder == null || sortOrder == "")&#123; /** * 默认按照学生姓名排序 */ sortOrder = NAME; &#125; Cursor c = qb.query(db, projection, selection, selectionArgs,null, null, sortOrder); /** * 注册内容URI变化的监听器 */ c.setNotificationUri(getContext().getContentResolver(), uri); return c; &#125; @Override public int delete(Uri uri, String selection, String[] selectionArgs) &#123; int count = 0; switch (uriMatcher.match(uri))&#123; case STUDENTS: count = db.delete(STUDENTS_TABLE_NAME, selection, selectionArgs); break; case STUDENT_ID: String id = uri.getPathSegments().get(1); count = db.delete( STUDENTS_TABLE_NAME, _ID + " = " + id + (!TextUtils.isEmpty(selection) ? " AND (" + selection + ')' : ""), selectionArgs); break; default: throw new IllegalArgumentException("Unknown URI " + uri); &#125; getContext().getContentResolver().notifyChange(uri, null); return count; &#125; @Override public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) &#123; int count = 0; switch (uriMatcher.match(uri))&#123; case STUDENTS: count = db.update(STUDENTS_TABLE_NAME, values, selection, selectionArgs); break; case STUDENT_ID: count = db.update(STUDENTS_TABLE_NAME, values, _ID + " = " + uri.getPathSegments().get(1) + (!TextUtils.isEmpty(selection) ? " AND (" +selection + ')' : ""), selectionArgs); break; default: throw new IllegalArgumentException("Unknown URI " + uri ); &#125; getContext().getContentResolver().notifyChange(uri, null); return count; &#125; @Override public String getType(Uri uri) &#123; switch (uriMatcher.match(uri))&#123; /** * 获取所有学生记录 */ case STUDENTS: return "vnd.android.cursor.dir/vnd.example.students"; /** * 获取一个特定的学生 */ case STUDENT_ID: return "vnd.android.cursor.item/vnd.example.students"; default: throw new IllegalArgumentException("Unsupported URI: " + uri); &#125; &#125;&#125; 在manifest中 添加&lt;provider&gt; 标签 12345&lt;application &lt;provider android:name="StudentsProvider" android:authorities="com.example.provider.College" &gt; &lt;/provider&gt;&lt;/application&gt; 10 Fragment 碎片 时activity 的一部分，模块化设计 ；拥有自己的生命周期；可以添加和移除；可以实现有action，但没有用户界面的组件； 继承Fragment 创建子类； (1) 生命周期 onAttach(): 碎片实例被关联到活动实例。碎片和活动还没有完全初始化。通常，你在该方法中获取到活动的引用，在碎片将来的初始化工作中被使用。 onCreate(): 当创建碎片时，系统调用该方法。你需要初始化一些碎片的必要组件。这些组件是当碎片被暂停、停止时需要保留的，以便被恢复。 onCreateView(): 当碎片将要第一次绘制它的用户界面时系统调用该方法。为了绘制碎片的UI，你需要从该方法中返回一个代表碎片根布局的View组件。如果该碎片不提供用户界面，直接返回null。 onActivityCreated: 当宿主活动被创建，在onCreateView()方法之后调用该方法。活动和碎片实例与活动的视图层级被创建。这时，视图可以通过findViewById()方法来访问。在这个方法中，你可以实例化需要Context对象的对象。 onStart(): 碎片可见时调用该方法。 onResume(): 碎片可交互时调用该方法。 onPause(): 当首次表明用户将要离开碎片时系统调用该方法。通常，这里你需要提交任何的会超出用户会话的持久化的变化。 onStop(): 碎片将要被停止时调用。 onDestroyView(): 调用该方法后，碎片将要被销毁。 onDestroy(): 该方法被用来清理碎片的状态。但在Android平台并不保证一定被调用。 11 意图 / 过滤器Intent-filter（1）Intent使用 发送邮件 Intent.ACTION_SEND 12345Intent email = new Intent(Intent.ACTION_SEND, Uri.parse("mailto:"));email.putExtra(Intent.EXTRA_EMAIL, recipients);email.putExtra(Intent.EXTRA_SUBJECT, subject.getText().toString());email.putExtra(Intent.EXTRA_TEXT, body.getText().toString());startActivity(Intent.createChooser(email, "Choose an email client from...")); 打开浏览器 Intent.ACTION_WEB_SEARCH 1234String q = "https://www.runoob.com";Intent intent = new Intent(Intent.ACTION_WEB_SEARCH );intent.putExtra(SearchManager.QUERY, q);startActivity(intent); 活动，服务，广播接收器都有独立的机制来传递意图 Context.startActivity():意图传递给该方法，用于启动一个新的活动或者让已存在的活动做一些新的事情 Context.startService():意图传递给该方法，将初始化一个服务，或者新的信息到一个持续存在的服务 Context.sendBroadcast():意图传递给该方法，信息将传递到所有对此感兴趣的广播接收器 （2）Intent对象 包括 name / action / data / category / extras / mark name 通过setCompents() / setClass() / setClassName()设置 ;通过getCompents()获取 action 通过 setAction() 方法来设置，通过 getAction() 方法来读取 data 只是一个数据类型(如元类型属性)，一条 URI ，或者同时包括数据类型和 URI 。 URI 则由不同部分的属性来指定。 setData() 方法只能以 URI 来指定数据， setType() 只能以元类型指定数据， setDataAndType() 可以同时指定 URI 和元类型。 URI 通过 getData() 读取， 类型通过 getType() 读取 category addCategory() 方法为意图对象添加类别，removeCategory() 方法删除之前添加的类别，getCategories() 获取所有被设置到意图对象中的类别。 extras 附加数据 通过 putExtras() 方法设置，getExtras() 方法读取 (3)Intent 类型 显示意图；隐式意图； 显式意图 ：显式意图用于连接应用程序的内部世界，假设你需要连接一个活动到另外一个活动，我们可以通过显示意图，下图显示通过点击按钮连接第一个活动到第二个活动。 1234// 通过指定类名的显式意图Intent i = new Intent(FirstActivity.this, SecondAcitivity.class);// 启动目标活动startActivity(i); 隐式意图:这些意图没有为目标命名，组件名称的域为空。隐式意图经常用于激活其他应用程序的组件 1234Intent read1=new Intent();read1.setAction(android.content.Intent.ACTION_VIEW);read1.setData(ContactsContract.Contacts.CONTENT_URI);startActivity(read1); 目标组件接收到意图，可以使用getExtras()方法来获取由源组件发送的附加数据 12345// 在代码中的合适位置获取包对象Bundle extras = getIntent().getExtras();// 通过键解压数据String value1 = extras.getString("Key1");String value2 = extras.getString("Key2"); (4) 两个按钮”启动浏览器”和”启动电话” java 代码 监听按钮 12345678910111213141516171819b1=(Button)findViewById(R.id.button);b1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent i = new Intent(android.content.Intent.ACTION_VIEW, Uri.parse("https://www.runoob.com")); startActivity(i); &#125;&#125;);b2=(Button)findViewById(R.id.button2);b2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent i = new Intent(android.content.Intent.ACTION_VIEW,Uri.parse("tel:9510300000")); startActivity(i);&#125;&#125;); manifest.xml配置意图 1234567&lt;activity android:name="com.runoob.intentfilter.MainActivity"android:label="@string/app_name" &gt;&lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt;&lt;/intent-filter&gt;&lt;/activity&gt; 有一系列的 Android 检查测试： 过滤器 &lt;intent-filter&gt; 需要列出一个或者多个的动作，不能为空； 过滤器至少包含一个 元素，否则将阻塞所有的意图。 如果多个动作被提到，Android 在调用活动前尝试匹配其中提到的一个动作。 过滤器 &lt;intent-filter&gt; 可能列出0个，1个或者多个类别。 如果没有类别被提到，Android 通过这个测试， 如果有多个类别被提及，意图通过类型测试，每个意图对象的分类必须匹配过滤器中的一个分类。 每个 元素可以指定一个 URI 和一个数据类型(元媒体类型)。这里有独立的属性， 如 URI 中的每个部分：模式，主机，端口和路径。 意图包含有 URI 和类型，只有它的类型匹配了过滤器中列出的某个类型，则通过数据类型部分的测试。 （5）举例 activity.java button 点击 12345678910111213141516171819202122232425262728293031// 通过View动作启动浏览器b1=(Button)findViewById(R.id.button);b1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent i = new Intent(android.content.Intent.ACTION_VIEW,Uri.parse("https://www.runoob.com")); startActivity(i); &#125;&#125;);// 通过Launch动作启动浏览器b2=(Button)findViewById(R.id.button2);b2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent i = new Intent("com.runoob.intentfilter.LAUNCH",Uri.parse("https://www.runoob.com")); startActivity(i); &#125;&#125;);// 异常情况b3=(Button)findViewById(R.id.button3);b3.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent i = new Intent("com.runoob.intentfilter.LAUNCH",Uri.parse("https://www.runoob.com")); startActivity(i); &#125;&#125;); manifest.xml配置 12345678910111213141516171819202122232425262728&lt;application android:allowBAppCompat="xxxx" android:icon="@drawable/ic_launcher" android:label="@string/app_name" android:theme="@style/Base.Theme.AppCompat" &gt; &lt;activity android:name="com.runoob.intentfilter.MainActivity" android:label="@string/app_name" &gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name="com.runoob.intentfilter.CustomActivity" android:label="@string/app_name"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.VIEW" /&gt; &lt;action android:name="com.runoob.intentfilter.LAUNCH" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;data android:scheme="http" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt;&lt;/application&gt;]]></content>
      <categories>
        <category>Android</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试题(2)]]></title>
    <url>%2F2019%2F01%2F01%2F%E9%9D%A2%E8%AF%95%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98(2)%2F</url>
    <content type="text"><![CDATA[整理1 1、prototype和proto的关系是什么？ （1）js在创建对象的时候，都有一个叫做proto的内置属性，用于指向创建它的函数对象的原型对象prototype; （2）构造函数、原型和实例关系：每个构造函数都有一个原型对象，原型对象包含一个指向构造函数的指针（constructor），而实例则包含一个指向原型对象的内部指针（proto）。 （3）函数是js中的一等公民，js在创建对象的时候，都有一个叫做proto的内置属性，用于指向创建它的函数对象的原型对象prototype。 只有函数有prototype, 当你创建一个函数时，js会自动为这个函数加上prototype属性，值是一个空对象。 (5)简而言之prototype是构造函数用来被自己的实例继承的原型，而proto是实例用来继承父类原型的载体 12345678function Person(name) &#123;this.name = name&#125;var person1 = new Personconsole.log(person1.__proto__ === Person.prototype) // trueconsole.log(Object.getPrototypeOf(person1) === person1.__proto__) // trueconsole.log(person1.prototype === person1.__proto__) // falseconsole.log(Object.getPrototypeOf(Person) === Person.__proto__) // trueconsole.log(Person.prototype===Person.__proto__) // falseconsole.log(person1.constructor === Person) // true 2、meta viewport原理是什么？ viewport是一种超越 html 元素的存在，当没有为 html 设置宽度的时候，html 的宽度继承于 viewport设置的宽度 viewport的原理在于： 先将页面渲染在一个width为显示设备默认尺寸的viewport上，如肾6Plus为980px； 然后将viewport等比例缩放至整个手机屏幕上；viewport就是连接手机屏幕和页面的中间层 想象一下，如果没有中间层，直接将一个页面宽度为980px的直接缩放至320px，那么里面的DOM节点将会进行重绘，很有可能导致排版错乱； viewport的作用是将所有的DOM节点先绘在宽度为980px的viewport上，然后整个viewport统一缩放，这样就能保证排版的正确性； 12345678910111213141516171819202122232425262728 &lt;meta name="viewport" content="width=device-width"&gt; 一个完整的viewport属性的设置为： &lt;meta name="viewport" content="width=device-width,initial-scale=1,no-scalable=no"&gt; 这样就会自动计算你的设备宽度了; /**1.获取包含滚动条尺寸的浏览器完整内部尺寸*2.获取用户实际的看到的视口大小（即发送缩放后的可视区域大小|visual viewport 大小）默认等于viewport大小*/window.innerHeightwindow.innerWidth /**1.设置的viewport大小*/document.documentElement.clientHeightdocument.documentElement.clientWidth/**1.HTML 文档大小*/document.documentElement.offsetHeightdocument.documentElement.offsetWidth/**1.设备大小*/screen.Heightscreen.width 3、域名收敛是什么？ 域名收敛：就是将静态资源放在一个域名下。减少DNS解析的开销 域名发散：是将静态资源放在多个子域名下，就可以多线程下载，提高并行度，使客户端加载静态资源更加迅速 域名发散是pc端为了利用浏览器的多线程并行下载能力。 而域名收敛多用与移动端，提高性能，因为dns解析是是从后向前迭代解析，如果域名过多性能会下降，增加DNS的解析开销。 4、float和display:inline-block的区别是什么？ 用display:inline-block;来实现水平列表比用float方式更容易控制，需要注意的是前者会由空格符带来边距影响。 inline-block默认是底部对齐的，要让两个元素顶部对齐，需要加上一句：veritcal-align:top; inline-block 的宽度可以自行设置的，而inline的自行设置宽度是无效的。 inline-block: 水平排列一行，即使元素高度不一，也会以高度最大的元素高度为行高，即使高度小的元素周围留空，也不回有第二行元素上浮补位。可以设置默认的垂直对齐基线。inline-block的元素仍然在仍在文档流中占据位置 float: 让元素脱离当前文档流，呈环绕状排列，如遇上行有空白，而当前元素大小可以挤进去，这个元素会在上行补位排列。默认是顶部对齐。脱离文档流 5、前端优化策略列举 尽量减少http请求个数； 合并图片（如css sprites，内置图片使用数据）、合并CSS、JS(JsCssZip)，这一点很重要，但是要考虑合并后的文件体积 为文件头指定Expires或Cache-Control，已缓存资源不再发起http请求，使内容具有缓存性 避免空的src和href 留意具有这两个属性的标签如link，script，img，iframe等 使用gzip压缩内容 Gzip压缩所有可能的文件类型以来减少文件体积 把CSS放到顶部 ； 把JS放到底部； 将CSS和JS放到外部文件中；精简CSS和JS 避免使用CSS中expression表达式 剔除重复的JS和CSS(代码的复用性) 使AJAX可缓存 尽早刷新输出缓冲 尤其对于css，js文件的并行下载更有意义 使用GET来完成AJAX请求；当使用XMLHttpRequest时，浏览器中的POST方法是一个“两步走”的过程：首先发送文件头，然后才发送数据。在url小于2K时使用GET获取数据时更加有意义 延迟加载；确定页面运行正常后，再加载脚本来实现如拖放和动画，或者是隐藏部分的内容以及折叠内容等 预加载；关注下无条件加载，有条件加载和有预期的加载 尽量减少iframe的个数；虑即使内容为空，加载也需要时间，会阻止页面加载，没有语意，注意iframe相对于其他DOM元素高出1-2个数量级的开销，它会在典型方式下阻塞onload事件，IE和Firefox中主页面样式表会阻塞它的下载 避免404 减少Cookie的大小 优化图像 ；尝试把GIF格式转换成PNG格式；无损压缩图片；精灵图； 6、首屏、白屏时间如何计算？ 白屏时间是指浏览器从响应用户输入网址地址，到浏览器开始显示内容的时间。 白屏时间 = 地址栏输入网址后回车 - 浏览器出现第一个元素 首屏时间是指浏览器从响应用户输入网络地址，到首屏内容渲染完成的时间。首屏时间 = 地址栏输入网址后回车 - 浏览器第一屏渲染完成 影响白屏时间的因素：网络，服务端性能，前端页面结构设计。 影响首屏时间的因素：白屏时间，资源下载执行时间。 将 chrome 网速调为 Fast 3G，然后打开 Performance 工具，点击 “Start profiling and reload page” 按钮 白屏时间： 通常认为浏览器开始渲染 或者解析完 的时间是白屏结束的时间点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;白屏&lt;/title&gt; &lt;script&gt; // 不兼容 performance.timing 的浏览器 window.pageStartTime = Date.now() &lt;/script&gt; &lt;!-- 页面 CSS 资源 --&gt; &lt;link rel="stylesheet" href="xx.css"&gt; &lt;link rel="stylesheet" href="zz.css"&gt; &lt;script&gt; // 白屏结束时间 window.firstPaint = Date.now() // 白屏时间 console.log(firstPaint - performance.timing.navigationStart) &lt;/script&gt;&lt;/head&gt; 白屏时间 = firstPaint - performance.timing.navigationStart || pageStartTime // 首屏时间 由于浏览器对每个页面的 TCP 连接数有限制，使得并不是所有图片都能立刻开始下载和显示。我们只需要监听首屏内所有的图片的 onload 事件，获取图片 onload 时间最大值，并用这个最大值减去 navigationStart 即可获得近似的首屏时间。 &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;首屏&lt;/title&gt; &lt;script&gt; // 不兼容 performance.timing 的浏览器 window.pageStartTime = Date.now() &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;img src="https://lz5z.com/assets/img/google_atf.png" alt="img" onload="load()"&gt; &lt;img src="https://lz5z.com/assets/img/css3_gpu_speedup.png" alt="img" onload="load()"&gt; &lt;script&gt; function load () &#123; window.firstScreen = Date.now() &#125; window.onload = function () &#123; // 首屏时间 console.log(window.firstScreen - performance.timing.navigationStart) &#125; &lt;/script&gt;&lt;/body&gt;// Performance API 计算加载时间function getPerformanceTiming() &#123; var t = performance.timing var times = &#123;&#125; // 页面加载完成的时间，用户等待页面可用的时间 times.loadPage = t.loadEventEnd - t.navigationStart // 解析 DOM 树结构的时间 times.domReady = t.domComplete - t.responseEnd // 重定向的时间 times.redirect = t.redirectEnd - t.redirectStart // DNS 查询时间 times.lookupDomain = t.domainLookupEnd - t.domainLookupStart // 读取页面第一个字节的时间 times.ttfb = t.responseStart - t.navigationStart // 资源请求加载完成的时间 times.request = t.responseEnd - t.requestStart // 执行 onload 回调函数的时间 times.loadEvent = t.loadEventEnd - t.loadEventStart // DNS 缓存时间 times.appcache = t.domainLookupStart - t.fetchStart // 卸载页面的时间 times.unloadEvent = t.unloadEventEnd - t.unloadEventStart // TCP 建立连接完成握手的时间 times.connect = t.connectEnd - t.connectStart return times&#125; 7、解释一下闭包 函数」和「函数内部能访问到的变量」（也叫环境）的总和，就是一个闭包。 8、解释一下作用域链 当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。 9、ajax如何实现，readyState的五种状态的含义？ 12345678910111213141516171819202122232425var xhr = getXmlHttpRequest();xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; //获取成功后执行操作 //数据在xhr.responseText &#125;&#125;;xhr.open("TYPE", "URL", true);xhr.send(""); // 服务响应出错了，但还是返回了信息，这并不是我们想要的结果。打开Fiddler监控，可以看到data.aspx返回的是500响应，但由于只使用readystate做判断，它不理会放回的结果是500还是200，只要响应成功返回了，就执行接下来的javascript代码，结果将造成各种不可预料的错误。所以只使用readyState判断是行不通的。// 事实上，结果却不像预期那样。响应码确实是返回了200，但是总共弹出了3次窗口！第一次是“readyState=2”的窗口，第二次是“readyState=3Test”的窗口，第三次是“readyState=4Test”的窗口。由此，可见onreadystatechange函数的执行不是只在readyState变为4的时候触发的，而是readyState的每次变化都会触发，所以就出现了前面说的那种情况。可见，单独使用status判断也是行不通的。需要同时判断 xhr.readyState === 4 &amp;&amp; xhr.status === 200) readyState 0 未初始化状态：此时，已经创建了一个XMLHttpRequest对象 1 准备发送状态：此时，已经调用了XMLHttpRequest对象的open方法，并且XMLHttpRequest对象已经准备好将一个请求发送到服务器端 2 已经发送状态：此时，已经通过send方法把一个请求发送到服务器端，但是还没有收到一个响应 3 正在接收状态：此时，已经接收到HTTP响应头部信息，但是消息体部分还没有完全接收到 4 完成响应状态：此时，已经完成了HTTP响应的接收 status 1XX 服务器收到请求，需要继续处理。例如101状态码，表示服务器将通知客户端使用更高版本的HTTP协议。 2XX 请求成功。例如200状态码，表示请求所希望的响应头或数据体将随此响应返回。 3XX 重定向。例如302状态码，表示临时重定向，请求将包含一个新的URL地址，客户端将对新的地址进行GET请求。 4XX 客户端错误。例如404状态码，表示客户端请求的资源不存在。 5XX 服务器错误。例如500状态码，表示服务器遇到了一个未曾预料的情况，导致了它无法完成响应，一般来说，这个问题会在程序代码出错时出现。 10、jsonp如何实现？ jsonp是一种跨域通信的手段 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758 首先是利用script标签的src属性来实现跨域。通过将前端方法作为参数传递到服务器端，然后由服务器端注入参数之后再返回，实现服务器端向客户端通信。由于使用script标签的src属性，因此只支持get方法1.一个简单的jsonp实现，其实就是拼接url，然后将动态添加一个script元素到头部。// 定义(function (global) &#123; var id = 0,container = document.getElementsByTagName("head")[0]; function jsonp(options) &#123; if(!options || !options.url) return; var scriptNode = document.createElement("script"), data = options.data || &#123;&#125;, url = options.url, callback = options.callback, fnName = "jsonp" + id++; // 添加回调函数 data["callback"] = fnName; // 拼接url var params = []; for (var key in data) &#123; params.push(encodeURIComponent(key) + "=" + encodeURIComponent(data[key])); &#125; url = url.indexOf("?") &gt; 0 ? (url + "&amp;") : (url + "?"); url += params.join("&amp;"); scriptNode.src = url; // 传递的是一个匿名的回调函数，要执行的话，暴露为一个全局方法 global[fnName] = function (ret) &#123; callback &amp;&amp; callback(ret); container.removeChild(scriptNode); delete global[fnName]; &#125; // 出错处理 scriptNode.onerror = function () &#123; callback &amp;&amp; callback(&#123;error:"error"&#125;); container.removeChild(scriptNode); global[fnName] &amp;&amp; delete global[fnName]; &#125; scriptNode.type = "text/javascript"; container.appendChild(scriptNode) &#125; global.jsonp = jsonp;&#125;)(this);// 使用jsonp(&#123; url : "www.example.com", data : &#123;id : 1&#125;, callback : function (ret) &#123; console.log(ret); &#125;&#125;); 11、怎么处理跨域？ 通过jsonp跨域 document.domain + iframe跨域 location.hash + iframe window.name + iframe跨域 postMessage跨域 跨域资源共享（CORS） nginx代理跨域 nodejs中间件代理跨域 WebSocket协议跨域 12、restful的method解释？ GET 获取资源 POST 新建资源（也可用于更新资源） PUT 更新资源 DELETE 更新资源 13、get和post的区别？ 14、事件模型解释 原始事件模型： 1234 在原始事件模型中（也有说DOM0级），事件发生后没有传播的概念，没有事件流。事件发生，马上处理，完事，就这么简单。 监听函数只是元素的一个属性值，通过指定元素的属性值来绑定监听器。书写方式有两种：&lt;input type=”button” onclick=”func1()” /&gt;document.getElementsByTagName(‘input’)[0].onclick = func1 DOM2事件模型 事件捕获阶段; 事件处理阶段; 事件冒泡阶段 在DOM2级中使用addEventListener和removeEventListener来注册和解除事件 ; addEventListener(‘事件名称’,’事件回调’,’捕获/冒泡’)。 addEventListenr的第一个参数是事件名称，与DOM0级不同的是没有”on“，另外第三个参数代表捕获还是冒泡，true代表捕获事件，false代表冒泡事件。 15、编写一个元素拖拽的插件 这里的过程涉及到三个dom事件：onmousedown,onmousemove,onmouseup。 16、CSS，JS代码压缩，以及代码CDN托管，图片整合 webpack的 UglifyJsPlugin压缩插件 gulp的gulp-uglify,gulp-minify-css模块完成 CDN的关键技术主要有内容存储和分发技术。 (1)节省骨干网带宽，减少带宽需求量 (2)提供服务器端加速，解决由于用户访问量大造成的服务器过载问题； (3)服务商能使用Web Cache技术在本地缓存用户访问过的Web页面和对象，实现相同对象的访问无须占用主干的出口带宽，并提高用户访问因特网页面的相应时间的需求； (4)能克服网站分布不均的问题，并且能降低网站自身建设和维护成本 (5)降低“通信风暴”的影响，提高网络访问的稳定性。 图片整合：减少网站加载时间的最有效的方式之一就是减少网站的HTTP请求数。实现这一目标的一个有效方法就是通过CSS Sprites将多个图片整合到一个图片中，然后再用CSS来定位。缺点可维护性差。 17、如何利用webpack把代码上传服务器以及转码测试？ （1）代码上传： 可以使用sftp-webpack-plugin，但是会把子文件夹给提取出来，不优雅。可以使用gulp+webpack来实现。 （2）转码测试 webpack应用babel来对ES6转码，开启devtool: “source-map” 来进行浏览器测试。应用karma或mocha来做单元测试。 18、项目上线流程是怎样的？ 19、工程化怎么管理的? 12345使用前端构建工具 gulp、grunt、Broccolijavascript JS编译工具Babel、Browserify、Webpack开发辅助工具数据 mock、livereload使用CI集成工具jenkins、Travis CI使用脚手架工具yeoman、create-app 20、webpack 和 gulp对比 webpack打包文件太大怎么办? webpack 把我们所有的文件都打包成一个 JS 文件，这样即使你是小项目，打包后的文件也会非常大。 可以从去除不必要的插件，提取第三方库，代码压缩，代码分割，设置缓存几个方面着手优化。 21、不想让别人盗用你的图片，访问你的服务器资源该怎么处理？ 一是对refer做判断看来源是不是自己的网站，如果不是就拒绝，这个适用范围最大，也很容易破解，因为refer可以伪造。 第二个是通过session校验，如果不通过特定服务生成cookie和session就不能请求得到资源。这个最保险，因为session在后端。 22、精灵图和base64如何选择？ 精灵图 优点 将多个图像加载请求合并为一个请求 弊端 ：难以维护和更新 ；增加内存消耗 base64 优点 ：将多个图像加载请求合并为一个CSS文件请求；轻松更新生成文件 弊端 ： base64编码比原始二进制表示大约大25% ；IE6或IE7不支持 23、webpack怎么引入第三方的库？ 1234567891011121314151617181920212223242526272829303132333435通过npm install安装的包会放在node modules文件夹下;通过CDN引入；通过npm 安装并引入；第三方js文件就在本地(1)可以用webpack的插件：ProvidePlugin，可以理解这个插件的作用就是把第三方库引入，且它的作用域是全局的。例如引入jquerynew webpack.ProvidePlugin(&#123; $: 'jquery', jQuery: 'jquery'&#125;)那么就可以用$和jQuery了，它们两个都表示jquery，需注意的是$和jQuery后面的值（jquery）必须和npm install jquery中的jquery保持一致，不然会找不到。(2) 加载本地存在的js 文件 这时可以用webpack配置中的resolve选项，给jquery指定一个别名，并配置其路径。假如我们的jquery.js文件放在dist文件夹下面resolve:&#123; alias: &#123; $: path.resolve(__dirname, './dist/jquery.js'), jQuery: path.resolve(__dirname, './dist/jquery.js'), &#125;&#125;这样就可以了。（3）除了ProvidePlugin这个插件，还有一个imports-loader可以完成引入第三方库的工作。test来指定哪个文件需要引入第三方库,通过options配置jquery。然后打包后可以看出，打包后的app.js文件变大了。module: &#123; rules: [ &#123; test: path.resolve(__dirname, "./src/app.js"), use: "imports-loader" options:&#123; $:'jquery' &#125; &#125; ] &#125; 24、如果线上出现bug git怎么操作？ 拉一个新分支， 修复bug; 合并到master上 合并到正在开发的分支上 25、用过Nginx吗？都用过哪些？ Nginx是一个http服务器。是一个使用c语言开发的高性能的http服务器及反向代理服务器。Nginx是一款高性能的http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。由俄罗斯的程序设计师Igor Sysoev所开发，官方测试nginx能够支支撑5万并发链接，并且cpu、内存等资源消耗却非常低，运行非常稳定 http服务器。Nginx是一个http服务可以独立提供http服务。可以做网页静态服务器。 虚拟主机。可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机。 基于端口的，不同的端口 基于域名的，不同域名 反向代理，负载均衡。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用nginx做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况。 通过了解Nginx也算是多了一门技术，而且还是挺简单的，使用也比较方便。重点是可以给系统带来很大的性能提升。 26、UIWebView和JavaScript之间是怎么交互的? 12345678原生调用JS [webView stringByEvaluatingJavaScriptFromString:[NSString stringWithFormat:@"var test = &#123;&#125;; (function initialize() &#123; test.showMessageAction = function showMessageAction()&#123; alert('哈哈'); &#125;; &#125;)()"]];JS调用原生 统一方法名goSearchPage ；在原生段实现。JS来调用 let temp1: @convention(block) () -&gt;() = &#123; [weak self] in self?.goSearchPage()&#125;self.theJScontext.setObject(unsafeBitCast(temp1, to: AnyObject.self), forKeyedSubscript: "goSearchPage" as NSCopying &amp; NSObjectProtocol) 27、混合开发桥接api是怎么调用的，需要引入类库嘛?调用的对象是什么? 123456789101112131415161718Hybrid框架结构HyBrid App = H5 App + Native 框架H5App用来实现功能逻辑和页面渲染 Native框架提供WebView和设备接口供H5调用方案一重混合应用，在开发原生应用的基础上，嵌入WebView但是整体的架构使用 原生应用提供，一般这样的开发由Native开发人员和Web前端开发人员组成。Native开发人员会写好基本的架构以及API让Web开发人员开发界面以及大部分的渲染。保证到交互设 计，以及开发都有一个比较折中的效果出来，优化得好也会有很棒的效果。Hybrid App技术发展的早期，Web的运行性能成为主要瓶颈！为解决性能问题Hybrid App走向‘‘重混”。通过多WebView:实现流畅的多页加载和专场动画。使用Navtive UI组件：框架、菜单、日期等。‘‘重混”的优缺点 优点：一提升了运行性能 一增强了交互体验缺点一一Web和Native技术交叉混杂 一需要同时掌握Web和Native技术，学习难度增加 一一个页面有Web组件也有Native组件，编程调试困难需要引入各自需要的各种依赖工具方案二：轻混合应用，使用PhoneGap、AppCan之类的中间件，以WebView作为用 户界面层，以Javascript作为基本逻辑，以及和中间件通讯，再由中间件访问底层API的方 式，进行应用开发。这种架构一般会非常依赖WebView层的性能。随着时代的发展，手机硬件、浏览器技术、无线网络技术都得到了大幅的提升，H5已经可 以支持复杂应用，并拥有良好的运行性能。使用轻混方案的App也越来越多。目前我们要学习的Hybrid App开发就是方案二，使用H5+Js+Native框架开发当前轻 混合应用。Phonegap 引入phonegap.js 或者 cordova.js,对象为 navigator Dcloud引入引入mui.js或者其他的js组件，对象为plus apiloud引入各种第三方插件，对象为api 28、说一下你对支付，推送（远程，本地）的理解 12345678910111213消息的推送主要有两种：一种是本地推送，主要应用在系统的工具中，例如：闹钟，生日提醒等；实现本地推 送需要以下三个步骤，实例化一个本地推送对象设置通知对象的各个属性添加本地推送对象一种是远程消息推送，主要应用联网设备的信息推送，例如：邮件，各种软件的广告 或优惠信息的推送。远程推送比较复杂，需要使用开发者账号进行申请证书，获得实现推送功能的配置文件，所以想要实现远程推送功能，必须要有开发者账号并且生成 配置文件完成证书的申请和Xcode的配置在Demo中注册远程服务对象，并设置其代理找一个简单的App服务器进行消息推送（推荐使用:PushMeBaby, gitup网站上就有）运行 PushMeBaby参考网址：http://blog.csdn.net/u014642572/article/details/26857717 29、什么是代理和通知，写一下他们基本的实现方 1234567891011121314151617181920212223242526272829303132333435代理：“一对一”，对同一个协议，一个对象只能设置一个代理delegate六个步骤：1．声明一个协议,定义代理方法2．遵循协议3．设置一个代理对象4．调用代理方法5．给代理赋值6．实现代理方法注意事项：1．单例对象不能用代理；2．代理执行协议方法时要使用respondsToSelector检查其代理是否符合3．协议(检查对象能否响应指定的消息),以避免代理在回调时因为没有实现方法而造成程序崩溃使用场景：公共接口，方法较多也选择用delegate进行解耦 iOS最常用tableViewDelegate, textViewDelegate iOS有很多例子比如常用的网络库AFNetwork，ASIHTTP库， UlAlertView 类。通知：一对一 一对多 传值四个步骤：1．发送通知2．创建监听者3．接收通知4．移除监听者使用场景：1一很多控制器都需要知道一个事件，应该用通知；2 一相隔多层的两个控制器之间跳转注意事项：1．一旦接收消息的对象多了，就难以控制了，可能有你不希望的对象接收了消息并做了处理2．创建了观察者，在dealloc里面一定要移除；Block : Block是i〇S4.0+和Mac OS X 10.6+引进的对C语言的扩展，用来实现匿名函数的特性。Blocks语法块代码以闭包得形式将各种内容进行传递，可以是代码，可以是数组 无所不能。闭包就是能够读取其它函数内部变量的函数。就是在一段请求连续代码中可以看 到调用参数（如发送请求）和响应结果。所以采用Block技术能够抽象出很多共用函数，提 高了代码的可读性，可维护性，封装性。使用场景：—: 动画二：数据请求回调三：枚举回调四：多线程gcd注意事项：Iblock需要注意防止循环引用 30、UIViewController的生命周期 1234567891．通过alloc init分配内存，初始化controller.2．loadView （loadView方法默认实现[super loadView]如果在初始化controller吋指定了xib文件名，就会根据传入的xib文件名加载对应的xib文件，如果 没传xib文件名，默认会加载跟controller同名的xib文件，如果没找到相关联的xib文件，就会创建一个空白的UIView,然后赋給controller的view）3．viewDidLoad (当loadView创建完view之后，此吋view已经完成加载了，会调用 viewDidLoad方法；一般我会在这里做界面上的初始化操作，比如添加按钮，子视图，等等.）4．viewWillAppear (当view在load完之后，将要显示在屏幕之前会调用这个方法，在重写这些方法吋候最好先调用一下系统的方法之后在做操作。）5．viewDidAppear (当view已经在屏幕上显示出来之后，会调用这个方法，当一个视图被移除屏幕并且销毁的吋候）6．viewWillDisappear (当视图将要从屏幕上移除吋候调用 )7．viewDidDisappear (当视图已经从屏幕上移除吋候调用 )8．Dealloc (view被销毁吋候调用，如果是手动管理内存的话，需要释放掉之前在init和 viewDidLoad中分配的内存（类似alloc,new,copy) ; dealloc方法不能甶我们主动调用，必须等引用计数为0吋候甶系统调用.） 31、rem布局字体太大怎么处理? 1234567891011121314一般情况下我们设置了html根节点的字体大小作为rem单位的一个基本标准，那么我 们可以紧接着在body标签内设置一个字体大小为该应用的基本字体大小针对于一些机型如果一开始就显示的字体不正常，我们可以通过判断机型然后加载不同的样式〈script language=“javascript”&gt;window.onload = function() &#123;alert(“1”);var u = navigator.userAgent;if(u.index〇f(‘Android’) &gt; 一1 || u.indexOf(‘Linux’) &gt; 一1) &#123; //安卓手机alert(“安卓手机”)；&#125; else if(u.index〇f(‘iPhone’) &gt; 一1) &#123; //苹果手机alert(“苹果手机”)；&#125; else if(u.index〇f(‘Windows Phone’) &gt; 一1) &#123; //winphone手机 alert(“winphone 手机”)；&#125;&#125;〈/script&gt; 32、如何调用原生的接口？ 123首先你得选择一个合适的框架作为自己的基础，以Dcloud为例，页面中一定要存在一个事件，plusready, plusready实际上是原生将桥接js注入到页面中的容器，进行任何方法 调用的时候都在plusready之后。所有api方法全部都托管在了一个plus对象中。使用语法 plus.模块名称.具体方法（参数，callback)当我们需要打开系统相册的时候，可以这样做：Gallery模块管理系统相册，支持从相册中选择图片或视频文件、保存图片或视频文 件到相册等功能。通过plus.gallery获取相册管理对象。打开相册plus.gallery.pick进行打开，选取多个图片&#123;multiple:true,maximum:9,system:false&#125; 33、微信支付怎么做？说说流程 123456789101112131．申请微信公众号及支付功能申请：根据公众号申请流程申请即可。2．获取商户支付配置信息及支付测试配置：支付授权目录最多可以配置三个域名，测试授权目录只可以一个，这里需要 注意的是域名大小写必须要网站URL—致，否则会无法通过授权，提示支付请求的 URL不合法。另外，测试支付的微信号必须加到测试白名单，否则无法进行支付测 试。3．H5页面发起支付请求，请求生成支付订单，获取用户授权（获取用户的openid)4．调用统一下单API，生成预付单5．生成JSAPI页面调用的支付参数并签名，注意时间戳timeStamp是32位字符串6．返回支付参数prepay—id,paySign参数的html文本给前端。7．微信浏览器自动调起支付JSAPI接口支付，提示用户输入密码。8．确认支付，输入密码，提交支付。9．步通知商户支付结果，商户收到通知返回确认信息。10．返回支付结果，并发微信消息提示。11．展示支付信息给用户，跳转到支付结果页面。———————————————— 34、混合开发的注意点 12345增强WebView : 原生WebView基本是PC平台浏览器内核的移植，但对于移动场景并不完全适合，各种硬件API得不到HTML5原生支持。因此对于WebView的种种Hack、增强应运而生，甚至出现了基于增强WebView提供第三方服务的。路由：应用内跳转由于加入了 WebView而变得复杂起来，同时由于组件化、模块化带来的问 题，路由也成为人们讨论的重点。缓存：移动网络条件差，为了用户体验，必须要做资源缓存和预加载。通信：即HTML5和Native之间的通信。利用系统提供的桥接API可以实现，不过在应用上还 有着一些坑点和安全问题。———————————————— 35、说说你对手机平台的安装包后缀的理解 1234Android：**apkIos：**ipaWindows： wp7 wp8的是xap wp8.1以后用8.1开发的是appxNodeJS 36、谈谈你对Socket编程的理解，及实现原理，Socket之间是怎么通讯的 12345678910111213141516171819202122232425262728293031A、Socket定义Socket是进程通讯的一种方式，即调用这个网络库的一些API函数实现分布在不同主机的相 关进程之间的数据交换。几个定义： IP地址：即依照TCP/IP协议分配给本地主机的网络地 址，两个进程要通讯，任一进程首先要知道通讯对方的位置，即对方的IP。 端口号：用来辨 别本地通讯进程，一个本地的进程在通讯时均会占用一个端口号，不同的进程端口号不同， 因此在通讯前必须要分配一个没有被访问的端口号。 连接：指两个进程间的通讯链路。B、实现原理在TCP/IP网络应用中，通信的两个进程间相互作用的主要模式是客户/服务器（Client/ Server, C/S)模式，即客户向服务器发出服务请求，服务器接收到请求后，提供相应的服务。 客户/服务器模式的建立基于以下两点： 首先，建立网络的起因是网络中软硬件资源、运算能力和信息不均等，需要共享，从而造就拥有众多资源的主机提供服务，资源较少的客 户请求服务这一非对等作用。 其次，网间进程通信完全是异步的，相互通信的进程间既不存 在父子关系，又不共享内存缓冲区， 因此需要一种机制为希望通信的进程间建立联系，为二 者的数据交换提供同步，这就是基于客户/服务器模式的TCP/IP。C、通讯过程 服务器端：其过程是首先服务器方要先启动，并根据请求提供相应服务： （1)打开一通信 通道并告知本地主机，它愿意在某一公认地址上的某端□(如FTP的端口可能为21)接收客 户请求； （2)等待客户请求到达该端口； （3)接收到客户端的服务请求时，处理该请求并 发送应答信号。接收到并发服务请求，要激活一新进程来处理这个客户请求（如UNIX系统 中用fork、exec)。 新进程处理此客户请求，并不需要对其它请求作出应答。服务完成后， 关闭此新进程与客户的通信链路，并终止。 （4)返回第（2)步，等待另一客户请求。 （5）关闭服务器客户端： （1)打开一通信通道，并连接到服务器所在主机的特定端口； (2)向服务器发服务请求报文，等待并接收应答；继续提出请求… （3)请求结束后关闭通信通道并终止。从上面所描述过程可知：（1）客户与服务器进程的作用是非对称的，因 此代码不同。（2）服务器进程一般是先启动的。只要系统运行，该服务进程一直存在，直到正常或强迫终止。———————————————— 37、WEB应用从服务器主动推送Data到客户端有哪些方式? 123456789一般的服务器Push技术包括：基于AJAX的长轮询（long一polling)方式，服务器Hold—段时间后再返回信息；HTTP Streaming,通过iframe和〈script〉#签完成数据的传输；TCP长连接HTML5新引入的WebSocket，可以实现服务器主动发送数据至网页端，它和HTTP— 样，是一个基于HTTP的应用层协议，跑的是TCP，所以本质上还是个长连接，双向通信， 意味着服务器端和客户端可以同时发送并响应请求，而不再像HTTP的请求和响应。nodejs的http://socket.io，它是websocket的一^^开源实现，对不支持websocket的浏 览器降级成comet / ajax轮询，http://socket.io的良好封装使代码编写非常容易。上述的 1 和2统称为comet技术。———————————————— 38、简述Node.js的适用场景？ 123456789101112IIO 密集而非计算密集的情景；高并发微数据（比如账号系统）的情景。特别是高并发，Node.js 的性能随并发数量的提高而衰减的现象相比其他 server 都有很明显的优势。Bad Use Cases1．CPU heavy apps （高CPU消耗的app）2．Simple CRUD / HTML apps （简单的CRUD / HTML apps）3．NoSQL + Node.js + Buzzword Bullshit （NoSQL + Node.js + 各种扯淡的时髦词汇）Good Use Cases1．JSON API2．Single page apps （单页面app）3．Shelling out to unix tools （对unix工具的脚本化调用）4．Streaming data （流数据）5．Soft Realtime Applications （软件实时程序）———————————————— 39、什么是HTTPS，做什么用的呢？如何开启HTTPS？ 123https是http的加密版本，是在http请求的基础上，采用ssl进行加密传输。加密数据，反劫持，SEO生成私钥与证书，配置nginx,重启nginx看效果 40、你们原来公司如何发送的新消息推送？ 12基于 AJAX 的长轮询（long一polling）方式，服务器Hold一段时间后再返回信息；2．HTTP Streaming 41、如何用NodeJS搭建中间层？ 123456Node层还能轻松实现原来vmcommon,tms (引用淘宝内容管理系统）等需求。Node层要使用什么框架由开发者自己决定。不过推荐使用express + xTemplate的组合， xTemplate能做到前后端公用。怎么用Node大家自己决定，但是令人兴奋的是，我们终于可以使用Node轻松实现我们想要的输出方式 JSON/JSONP/RESTful/HTML/BigPipe/Comet/Socket/同步、异步，想怎么整就怎么整，完全根据你的场景决定。浏览器层在我们这个架构中没有变化，也不希望因为引入Node改变你以前在浏览器中开发的认知。引入Node，只是把本该就前端控制的部分交由前端掌控。———————————————— 42、vue与react的对比,如何选型？从性能，生态圈，数据量，数据的传递上，作比较 1234567891011121314151617181920React和Vue有许多相似之处，它们都有：使用 Virtual DOM提供了响应式（Reactive)和组件化（Composable)的视图组件。将注意力集中保持在核心库，伴随于此，有配套的路由和负责处理全局状态管理的库。性能：到目前为止，针对现实情况的测试中，Vue的性能是优于React的。生态圈Vue.js: ES6+Webpack+unit/e2e+Vue+vue一router+单文件组件+vuex+iVewReact: ES6+Webpack+Enzyme+React+React一router+Redux什么时候选择Vue.js如果你喜欢用（或希望能够用）模板搭建应用，请使用Vue如果你喜欢简单和”能用就行”的东西，请使用Vue如果你的应用需要尽可能的小和快，请使用Vue如果你计划构建一个大型应用程序，请使用React如果你想要一个同时适用于Web端和原生App的框架，请选择React如果你想要最大的生态圈，请使用React———————————————— 43、vue slot是做什么的? 1简单来说，假如父组件需要在子组件内放一些D〇M，那么这些DOM是显示、不显示、在哪 个地方显示、如何显示，就是slot分发负责的活。 44、vue和angular的优缺点以及适用场合? 45、vue路由实现原理? 1234以官方仓库下examples/basic基础例子来一点点具体分析整个流程。和流程相关的主要需要关注点的就是components、history目录以及create一matcher.js、 create一route一map.js、index.js，install.js。从入口，作为插件，实例化VueRouter,实例化History,实例化Vue, defineReactive定 义_route, router一link和router一view组件等几个方面展开分析———————————————— 46、你们vue项目是打包了一个js文件，一个css文件，还是有多个文件？ 47、vue遇到的坑，如何解决的？ 1Vue1.0升级2.0有很多坑:生命周期；路由中引入静态js，全局组件，全局变量，全局 function; v一for循环的key, value值互换了位置，还有track一by; filter过滤器；遍历数组时， key值不能做model;父子通信等。 48、vue的双向绑定的原理，和angular的对比 1234在不同的MWM框架中，实现双向数据绑定的技术有所不同。AngulaJS采用‘‘脏值检测”的方式，数据发生变更后，对于所有的数据和视图的绑定关系进 行一次检测，识别是否有数据发生了改变，有变化进行处理，可能进一步引发其他数据的改 变，所以这个过程可能会循环几次，一直到不再有数据变化发生后，将变更的数据发送到视 图，更新页面展现。如果是手动对ViewModel的数据进行变更，为确保变更同步到视图， 需要手动触发一次‘‘脏值检测”。VueJS则使用ES5提供的〇bject.defineProperty()方法，监控对数据的操作，从而可以自 动触发数据同步。并且，由于是在不同的数据上触发同步，可以精确的将变更发送给绑定的 视图，而不是对所有的数据都执行一次检测。———————————————— 49、vue-cli，脚手架 12安装：$ npm instaH 一g vue一cli使用：$ vue init &lt;template一name&gt; &lt;project一name&gt; 50、Vue里面router-link在电脑上有用，在安卓上没反应怎么解决？ 1Vue路由在Android机上有问题，babel问题，安装babel polypill插件解决。]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试题(3)]]></title>
    <url>%2F2019%2F01%2F01%2F%E9%9D%A2%E8%AF%95%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98(3)%2F</url>
    <content type="text"><![CDATA[整理2 职责描述 1234567891011职责描述：1、各业务模块前端代码开发；2、配合后端工程师一起研讨技术实现方案，进行应用及系统整合；3、持续优化前端代码的性能，对现有产品功能进行升级以提高前端的用户体验以及性能，推进系统架构的演化。任职要求：1、专科以上学历，计算机相关专业，3年以上前端开发工作经验；1.前端工作经验3年以上，在前几家工作相对稳定没有频繁跳槽的，年龄在88年以后的2.vue是必要条件，至少有1年的相关vue的中大型产品开发经验，从事前端开发经验3年以上，前端开发是指使用vue，react等做过项目3.小程序电商开发经验至少一年,有百度，支付宝小程序经验等优先4.如有带团队经验的超过一年的，需要属于团队的核心开发类型的技术管理岗5.人选从两个方向选择要么从事过可视化拖拽布局项目者优先，要么会自己编写vue组件，良好的代码风格，扎实的原生JS编写能力，良好的理解和表达能力，良好的逻辑思维能力，编程基础扎实。 小程序有没有做过 前端的生命周期钩子怎么解释；生命周期（小程序的生命周期or vue的生命周期） 12345678beforecreate()；此时 data 和methods 还没有被初始化created() data 和method 已经初始化好了。beforeMount() 模版已经编译加载到内存中，但还未加载到页面上mounted() 已经加载到页面上了。看到的是渲染好的页面。beforUpdate() UI还没有更新，但是数据肯定被更新了，data是新数据，但是页面上的数据是旧数据updated() 已保持同步更新beforDestroy() 销毁前 做一些保存操作destroyed() 销毁后 内存销毁 Vue中的脚手架用什么 12345678vue脚手架指的是vue-cli，它是一个专门为单页面应用快速搭建繁杂的脚手架，它可以轻松的创建新的应用程序而且可用于自动生成vue和webpack的项目模板。全局安装webpack命令行： npm install webpack -g全局安装，输入命令行： npm install vue-cli -g安装完成后执行命令: vue -V 查看版本号在新建文件夹的上一级文件夹右键打开命令行工具，输入命令行：vue init webpack mySelf(项目名)cd 项目的文件夹安装项目依赖。命令行： npm installnpm run dev或者npm start，启动服务 Vue的更新机制 1234567891011121314151617Vue引入虚拟DOM的最初目的却是为了降低内存; vue自动更新视图的基础是响应式系统;(1) 在数据变化时，调用组件的渲染函数重新生成VNode ; 通过diff算法比对新旧VNode，判断哪里发生了变化 ; 更新真实DOM(2) 总结 虚拟DOM本身就是对真实DOM的一种JavaScript描述，每当数据更新时，它就通过diff算法来比对之前的和新生成的两个VNode，根据差异来更新真实DOM。由于在React中没有响应式系统，当数据发生变化时，React不知道哪个组件受到了影响，因此需要对完整的虚拟DOM进行diff，从而更新页面。而借助响应式系统，只要数据变化，Vue就能立即定位到是哪个组件的DOM需要更新，因此它的diff算法是组件级别的，效率更高（当然，构建响应式系统本身必然有一定的资源消耗，但这种消耗是值得的）。(3) 通过isCollapse改变触发ref的子组件child触发方法resize()，接着触发callResize()方法(4) 子组件是child，父组件是整个界面 ，在父组件上任意触发监听，调用方法resize()； resize()调用callResize()，callResize()把下面的3个方法的resize()一次调用。 循环遍历 父触发，父亲告诉子 resize 子告诉孙 resize。没有孙子，就调用停止。想一个树形结构，导航菜单，点击导航菜单，切换对应界面。保证每个节点都跟着刷新。就是说，父组件更新了，它的子组件，孙组件都要更新。子组件变化了，它引用的所有组件都要更新。————————————————(5) 1.数组更改值或者增加删除值，不会触发更新。2.对象更改值可触发更新，增加或者删除属性不会触发更新。3.对象数组：数组中的对象更改值会触发更新。(6) 由于VUE的数据驱动视图更新，是异步的，即修改数据的当下，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。nextTick的触发时机： 在同一事件循环中的数据变化后，DOM完成更新，立即执行nextTick(callback)内的回调 vue双向绑定的原理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192vue主要是借助对象的访问器属性（Object.defineProperty）劫持数据，并结合订阅者-发布者模式来实现数据双向绑定。vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。（1）为属性 实现 Object.defineProperty 实现 set get方法function defineReactive(data,key,val) &#123; observe(val); var dep = new Dep(); Object.defineProperty(data, key, &#123; enumerable: true, configurable: true, get: function() &#123; if (是否需要添加订阅者) &#123; //Watcher初始化触发 dep.addSub(watcher); // 在这里添加一个订阅者 &#125; return val; &#125;, set: function(newVal) &#123; if (val === newVal) &#123; return; &#125; val = newVal; console.log('属性' + key + '已经被监听了，现在值为：“' + newVal.toString() + '”'); dep.notify(); // 如果数据变化，通知所有订阅者 &#125; &#125;);&#125;(2) 创建订阅者function Dep() &#123; this.subs = [];&#125;//prototype这个属性只有函数对象才有，具体的说就是构造函数具有.只要你声明定义了一个函数对象，这个prototype就会存在//对象实例是没有这个属性Dep.prototype = &#123; addSub:function(sub) &#123; this.subs.push(sub); &#125;, notify:function() &#123; this.subs.forEach(function(sub) &#123; sub.update(); //通知每个订阅者检查更新 &#125;) &#125;&#125;Dep.target = null;（3）实现坚监听着，收到通知，通知刷新UI function Watcher(vm,exp,cb) &#123; this.vm = vm; //指向SelfVue的作用域 this.exp = exp; //绑定属性的key值 this.cb = cb; //闭包 this.value = this.get(); &#125; Watcher.prototype = &#123; update:function() &#123; this.run(); &#125;, run:function() &#123; var value = this.vm.data[this.exp]; var oldVal = this.value; if(value !== oldVal) &#123; this.value = value; this.cb.call(this.vm,value,oldVal); &#125; &#125;, get:function() &#123; Dep.target = this; // 缓存自己 var value = this.vm.data[this.exp]; // 强制执行监听器里的get函数 Dep.target = null; // 释放自己 return value; &#125; &#125;（4） 定义一个SelfVue类，来实现observer和watcher的关联，//将Observer和Watcher关联起来function SelfVue(data,el,exp) &#123; this.data = data; observe(data); el.innerHTML = this.data[exp]; new Watcher(this,exp,function(value) &#123; el.innerHTML = value; &#125;); return this;&#125;（5）页面上测试监听： &lt;script&gt; var ele = document.querySelector('#name'); var selfVue = new SelfVue(&#123; name:'hello world' &#125;,ele,'name'); window.setTimeout(function() &#123; console.log('name值改变了'); selfVue.name = 'byebye world'; &#125;,2000); &lt;/script&gt; - 父子组件通信； 父传子，子传父的Vue组件怎么构成（父子组件之间的通信） 12345678910111213(1)通过 Prop 向子组件传递数据父： &lt;my-child :deliverParentAge="parentAge"&gt;&lt;/my-child&gt; 子： props: ["deliverParentAge"]; (2) 通过emit 子传父； 子： AddAge() &#123; this.$emit("addParentAge", this.parentActualAge); &#125; 父： @addParentAge 是子 emit的时候 传入的函数名 &lt;my-child :deliverParentAge="parentAge" @addParentAge="handleAddParentAge"&gt;&lt;/my-child&gt; Vue兄弟组件怎么使用; eventBus ;vuex; localStorage; 1234567891011兄弟组件之间的通信 ，是用eventBus;A 组件监听eventBus.$on('my-event', args =&gt; &#123; //...&#125;)// B组件发送消息list(newValue, oldValue) &#123; eventBus.$emit('my-event', newValue)&#125; ；相抵组件之间相互调用，通过父组件做桥接；父组件 通过refs[0] 获取到组件，执行方法 是否了解异步路由，异步路由配置之后会有什么变化 12345678910111213141516171819202122232425262728异步加载路由组件组件懒加载 在单页应用中，如果没有应用懒加载，运用webpack打包后的文件将会异常的大，造成进入首页时，需要加载的内容过多，延时过长，不利于用户体验，而运用懒加载则可以将页面进行划分，需要的时候加载页面，可以有效的分担首页所承担的加载压力，减少首页加载用时 (1)路由中配置异步组件 export default new Router(&#123; routes: [ &#123; mode: 'history', path: '/my', name: 'my', component: resolve =&gt;require(['../page/my/my.vue'], resolve),//懒加载 &#125;, ]&#125;)(2) 实例中配置异步组件components: &#123; historyTab: resolve =&gt; &#123;require(['../../component/historyTab/historyTab.vue'], resolve)&#125;,//懒加载 //historyTab: () =&gt; import('../../component/historyTab/historyTab.vue')&#125;,(3) 全局注册异步组件Vue.component('mideaHeader', () =&gt; &#123; System.import('./component/header/header.vue')&#125;)问题变化：//异步加载的组件将会比页面中其他元素滞后出现， 页面会有瞬间闪跳影响；因为在首次加载组件的时候会有加载时间， 出现页面滞后， 所以需要合理的进行页面结构设计， 避免首次出现跳闪现象； 怎么定义动态路由；怎么获取传过来的动态参数； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 定义动态路由；const router = new VueRouter(&#123; routes: [ // 动态路径参数 以冒号开头 &#123; path: '/user/:id', component: User &#125; ]&#125;)// 获取参数： 一个“路径参数”使用冒号 : 标记。当匹配到一个路由时，参数值会被设置到 this.$route.params(1) 组件中配置，路由配置拼接参数，取参数使用 this.$route.params.idthis.$router.push(&#123; path: `/describe/$&#123;id&#125;`,&#125;)&#123; path: '/describe/:id', name: 'Describe', component: Describe&#125;（2）子组件中: 这样来获取参数 通过 this.$route.params.id父组件中：通过路由属性中的name来确定匹配的路由，通过params来传递参数。this.$router.push(&#123; name: 'Describe', params: &#123; id: id &#125;&#125;)对应路由配置: 这里可以添加:/id 也可以不添加，不添加数据会在url后面显示，不添加数据就不会显示&#123; path: '/describe', name: 'Describe', component: Describe&#125;（3）对应子组件: 这样来获取参数 this.$route.query.id 父组件：使用path来匹配路由，然后通过query来传递参数 这种情况下 query传递的参数会显示在url后面?id=？ this.$router.push(&#123; path: '/describe', query: &#123; id: id &#125; &#125;) 对应路由配置： &#123; path: '/describe', name: 'Describe', component: Describe &#125; this.$router 和 this.$route 的区别 123(1)router为VueRouter实例，主要是实现路由跳转使用。想要导航到不同URL，则使用router.push方法(2)route object ，路由信息对象，表示当前激活的路由的状态信息，包含了完整路径、当前 URL 解析得到的信息，还有 URL 匹配到的 route records（路由记录）(3)route object 是 immutable（不可变） 的，每次成功的导航后都会产生一个新的对象 简述一下vuex 的哪几种属性，分别各自什么作用； 123456789属性： State Getters Mutation Action Module;State 基本数据getters 从基本数据派生的数据；mutation 提交更改数据的方法；同步; 更改Vuex中的store中的状态的唯一方法action 像是一个装饰器。封装mutations；使之可以异步；modules 模块化Vuex;store.commit("mutationsname",&#123;&#125;)store.dispatch("actionname",&#123;&#125;) 格式化金额，三个逗号分隔； 123456789101112131415161718192021222324252627282930313233(1) 方法1 function fmoney(s, n) &#123; /* * 参数说明： * s：要格式化的数字 * n：保留几位小数 * */ n = n &gt; 0 &amp;&amp; n &lt;= 20 ? n : 2; s = parseFloat((s + "").replace(/[^\d\.-]/g, "")).toFixed(n) + ""; var l = s.split(".")[0].split("").reverse(), r = s.split(".")[1]; t = ""; for (i = 0; i &lt; l.length; i++) &#123; t += l[i] + ((i + 1) % 3 == 0 &amp;&amp; (i + 1) != l.length ? "," : ""); &#125; return t.split("").reverse().join("") + "." + r;&#125;//调用fmoney(9.7,2);//9.70fmoney('12345.675910', 3);//12,345.676// 方法2 s为传入的字符串，dot为金额每隔三位用","或" "间隔function formatMoney(s,dot) &#123; s = parseFloat((s + "").replace(/[^\d\.-]/g, "")).toFixed(2) + ""; var l = s.split(".")[0].split("").reverse(), r = s.split(".")[1]; t = ""; for(i = 0; i &lt; l.length; i ++ ) &#123; t += l[i] + ((i + 1) % 3 == 0 &amp;&amp; (i + 1) != l.length ? dot : ""); &#125; return t.split("").reverse().join("") + "." + r; &#125; console.log(formatMoney("12345.605910", ' '))// 12 345.61 数组扁平化处理；讲一个数组（此数组可能是一维，可能是二维，三维 ） 转为一维数组； 1234567891011121314151617181920212223242526272829303132333435363738394041421. reduce 遍历数组每一项，若值为数组则递归遍历，否则concatfunction flatten(arr) &#123; return arr.reduce((result, item)=&gt; &#123; return result.concat(Array.isArray(item) ? flatten(item) : item); &#125;, []);&#125;2. toString &amp; splitfunction flatten(arr) &#123; return arr.toString().split(',').map(function(item) &#123; return Number(item); &#125;)&#125; 3 join &amp; split和上面的toString一样，join也可以将数组转换为字符串function flatten(arr) &#123; return arr.join(',').split(',').map(function(item) &#123; return parseInt(item); &#125;)&#125;4. 递归 递归的遍历每一项，若为数组则继续遍历，否则concatfunction flatten(arr) &#123; var res = []; arr.map(item =&gt; &#123; if(Array.isArray(item)) &#123; res = res.concat(flatten(item)); &#125; else &#123; res.push(item); &#125; &#125;); return res;&#125;5. 扩展运算符 es6的扩展运算符能将二维数组变为一维[].concat(...[1, 2, 3, [4, 5]]);function flatten(arr) &#123; while(arr.some(item=&gt;Array.isArray(item))) &#123; arr = [].concat(...arr); &#125; return arr;&#125; 权限配置怎么实现 123456789101112131415接口访问的权限控制页面的权限控制 菜单中的页面是否能被访问 页面中的按钮（增、删、改）的权限控制是否显示接口session过期service.interceptors.request.use( config =&amp;gt; &#123; if (store.state.user.token) &#123; config.headers.Authorization = `token $&#123;store.state.user.token&#125;`; &#125; return config &#125;, err =&amp;gt; &#123; return Promise.reject(err) &#125;);动态路由生成router.meta.permission 深度广度，二叉树，网站Dom的节点怎么构成 123456789101112131415161718192021222324252627282930313233343536373839404142434445(1)// 多叉树的遍历，广度优先遍历层序遍历，借助队列，非递归方式Tree.prototype.BFSearch = function(node, callback) &#123; var queue = []; while (node != null) &#123; callback(node); if (node.children.length != 0) &#123; for (var i = 0; i &lt; node.children.length; i++) &#123; queue.push(node.children[i]); //借助于队列,暂存当前节点的所有子节点 &#125; &#125; node = queue.shift(); //先入先出，借助于数据结构：队列 &#125;&#125;;(2)// 多叉树的遍历，深度优先遍历 借助栈，首先遍历根节点，然后沿着一条路径遍历到最深的一层，最后在逐层返回Tree.prototype.DFSearch = function(node, callback) &#123; var stack = []; while (node != null) &#123; callback(node); if (node.children.length != 0) &#123; for (var i = node.children.length - 1; i &gt;= 0; i--) &#123; //按照相反的子节点顺序压入栈 stack.push(node.children[i]); //将该节点的所有子节点压入栈 &#125; &#125; node = stack.pop(); //弹出栈的子节点顺序就是原来的正确顺序(因为栈是先入后出的) &#125;&#125;;(3) 每一个元素都是一个节点，可以看到有很多类型不同的节点 Element(元素节点) 1 ELEMENT_NODE Attr(属性节点) 1 ATTRIBUTE_NODE Text(文本节点) 1 TEXT_NODE Comment(注释节点) 1 COMMENT_NODE Document(文档节点) 1 DOCUMENT_NODE DocumentType(文档类型节点) 1 DOCUMENT_TYPE_NODE DocumentFragment(文档片段节点) 1 DOCUMENT_FRAGMENT_NODE(4) 每个节点都有nodeType（节点类型）、nodeName（节点名称）、nodeValue（节点值）属性（还有其他的常用属性这里不讲），我们可以通过xxx.nodeType xxx.nodeName xxx.nodeValue获得（xxx代表通过DOM提供的方法获取的node） 节点类型 nodeName nodeValue Element(元素节点) 元素标签名称如:div null Attr(属性节点) 属性名称如:id 属性值如:container Text(文本节点). #text 节点中包含的文本内容 Comment(注释节点) #comment 注释中的内容 DocumentType(文档类型节点) doctype的名称（html） null DocumentFragment(文档片段节点) #document_fragment null 未知的对象树怎么辩证节点 12345678910111213141516171819// 递归查找 根据key 是否相同function recursion(data, current)&#123; var result = null; if(!data)&#123; // return; 中断执行 return; &#125; for(var i in data)&#123; var item = data[i]; if(item.id == current)&#123; result = item; break; &#125;else if(item.children &amp;&amp; item.children.length &gt; 0)&#123; result = recursion(item.children, current); &#125; &#125; return result;&#125;var r = recursion(data, 3); 有没有见过色盘，颜色选择器，颜色选择器的颜色怎么出来 1234567891011121314151617var begin = 0; for (var i = 0; i &lt; 2; i++) &#123; begin = i * 8; for (var r = 0; r &lt; c.length; r++) &#123; document.writeln('&lt;div class="clear"&gt;'); for (var g = begin; g &lt; begin + 8; g++) &#123; for (var b = 0; b &lt; c.length; b++) &#123; var color = '#' + c.charAt(r) + c.charAt(g) + c.charAt(b); document.write('&lt;div onclick="setColor(\'' + color + '\');" onmouseover="showColor(\'' + color + '\');" style="background-color:' + color + ';"&gt; &lt;/div&gt;'); &#125; &#125; document.writeln('&lt;/div&gt;'); &#125; &#125; 吸盘吸各种颜色，怎么去实现 123456789101112131415function selectColor(o) &#123; o.style.backgroundColor = '#FFF'; o.style.border = 'solid 10px ' + (o.value == '' ? 'black' : o.value); &#125; function showColor(color) &#123; document.getElementById('txtColor').style.border = 'solid 10px ' + color; &#125; function setColor(color) &#123; var txtColor = document.getElementById('txtColor'); txtColor.value = color; txtColor.style.backgroundColor = color; txtColor.select(); txtColor.focus(); &#125; 热响应的原理; 热更新；热修复； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748使得应用在运行状态下，不重载刷新就能更新、增加、移除模块的机制(1) 使用 HotModuleReplacementPlugin 插件 HotModuleReplacementPlugin 插件是 Webpack 自带的// webpack.config.jsmodule.exports = &#123; // ... plugins: [ webpack.HotModuleReplacementPlugin(), // ... ]&#125;;(2) 如果直接通过 webpack-dev-server 启动 Webpack 的开发环境，那么可以这样打开 webpack-dev-server 的热更新开关：// webpack.config.jsmodule.exports = &#123; // ... devServer: &#123; hot: true, // ... &#125;&#125;(3)处理依赖模块的热更新module.hot.accept() 告诉 Webpack，当前模块更新不用刷新module.hot.decline() 告诉 Webpack，当前模块更新时一定要刷新(4) 处理自身模块的热更新 使用vue的热加载可以实现局部内容的刷新，更改数据后，不会刷新整个页面在webpack.config.js中设置： 对config.devServer中添加属性hot:true对config.plugins添加 new webpack.HotModuleReplacementPlugin(), new webpack.NoEmitOnErrorsPlugin()————————————————if (isDev) &#123; config.devServer = &#123; port: 8000, //配置端口号 host: '0.0.0.0', //让页面可以通过本机的ip访问，也可以使用手机同一局域网内通过ip访问 overlay: &#123; errors: true //webpack在编译的时候如果出现了错误，可以在网页上显示 &#125;, hot: true //热加载 &#125; config.plugins.push( new webpack.HotModuleReplacementPlugin(), new webpack.NoEmitOnErrorsPlugin() )&#125; module.exports = config———————————————— 分环境打包怎么配置 development(开发)、test(测试)、pre(预生产)、product（生产） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778791、cnpm/npm run build:dev ------本地包打包完成2、cnpm/npm run build:test ------测试包打包完成3、cnpm/npm run build:prod ------生产包打包完成(1)在config 目录下 建立 pre.env.js test.env.js 文件 //test.env.js module.exports = &#123; NODE_ENV: '"testing"', // 环境 ENV_CONFIG: '"test"' // 环境标识 &#125; // pre.env.js module.exports = &#123; NODE_ENV: '"pre"', ENV_CONFIG: '"pre"' &#125;(2) 导入 config目录下的 index.js build模块 build: &#123; prodEnv: require('./prod.env'), // 添加（导入）环境配置 testEnv: require('./test.env'), preEnv: require('./pre.env'), index: path.resolve(__dirname, '../dist/index.html'), assetsRoot: path.resolve(__dirname, '../dist'), assetsSubDirectory: 'static', assetsPublicPath: './', productionSourceMap: true, devtool: '#source-map', productionGzip: false, productionGzipExtensions: ['js', 'css'], bundleAnalyzerReport: process.env.npm_config_report &#125; ————————————————(3) 肯定配置build目录动态打包文件 而不是单纯的 prod（生产环境了） 首先 在 build/webpack.prod.conf .js下 const env = require('../config/prod.env') // 源代码 替换成 const env = config.build[process.env.env_config + 'Env'] //动态环境 env_config 其次 在build/build.js 下 修改 const spinner = ora const spinner = ora( 'building for ' + process.env.NODE_ENV + ' of ' + process.env.env_config + ' mode...' （4）肯定是配置我们的 package.json "scripts": &#123; "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js", "start": "npm run dev", "build": "node build/build.js", "test": "cross-env NODE_ENV=testing env_config=test node build/build.js", "pre": "cross-env NODE_ENV=pre env_config=pre node build/build.js", "prod": "cross-env NODE_ENV=production env_config=prod node build/build.js" &#125; （5）build之前肯定得安装依赖 才会执行 npm run test 等命令 npm install cross-env –save-dev （6）在src下 任意模块下建立 常量 config.js， let FBC_Api = '' // 服务（包括上传） api IP let uploadUrl = '' // 图片 路径拼接 IP if (process.env.NODE_ENV === 'development') &#123; FBC_Api = 'http://192.168.1.114:8180' // 本地IP uploadUrl = 'http://192.168.1.114:8180' // 本地 代理 &#125; else if (process.env.NODE_ENV === 'testing') &#123; // 07环境 FBC_Api = 'http://192.168.2.70:8000/fbcadmin' uploadUrl = 'http://192.168.2.70:8000' &#125; else if (process.env.NODE_ENV === 'pre') &#123; // 预开发 09 FBC_Api = 'http://192.168.2.70:9061' uploadUrl = 'http://192.168.2.70:8000' &#125; else &#123; // 生产 FBC_Api = 'http://192.168.2.70:9061' uploadUrl = 'http://192.168.2.70:8000' &#125; export &#123; FBC_Api, uploadUrl &#125; ———————————————— 函数执行的过程是什么样的（未答） 1234567891011121314151617181920212223242526272829303132 function Person(name) &#123; this.getName = function() &#123; return name; &#125;; this.setName = function(value) &#123; name = value; &#125;; &#125; var person = new Person("Candy"); alert(person.getName()); //"Candy" person.setName("Greg"); alert(person.getName()); //"Greg" 为函数创建一个执行环境 复制函数的 [[scopes]] 属性中的对象构建起执行环境的作用链域 创建函数活动对象并推入执行环境作用链域的前端 执行代码 销毁执行环境和活动对象（闭包情况下活动对象仍被引用没被销毁）（1）未调用前，只存在全局变量对象 全局变量中定义了Person() 构造函数，Person作为全局变量对象的一个属性，[[scopes]] 保存着Person() 构造函数的作用链域，因为Person() 构造函数是定义在全局变量对象里面的 创建函数时，会创建一个预先包含全局变量对象的作用链域，这个作用链域被保存在内部的 [[scopes]] 属性中 (2) new Person() 创建对象，调用之后，存在全局变量对象，Person对象 用new调用构造函数会经过以下4个步骤： 创建一个新对象 将构造函数的作用域赋给新对象（因此this就指向这个新对象——person，这也是变量name为什么不是对象属性的原因） 执行构造函数中的代码（为新对象添加属性） 返回新对象 (3) 函数执行完毕后 setName执行环境和setName活动对象都被销毁，因为setName活动对象没有被引用 (4) 通过这个例子，也很好理解为什么person.name是undefined，因为person对象没有name这个属性，getName、setName能访问name属性是因为它们通过作用链域访问到了Person活动对象中的name属性 变量声明提升是什么 123var a =2;这条语句在会被JS引擎看成是两部分，分别为var a;和a = 2。其中前一部分是发生在编译过程中，而第二部分发生在执行过程中。也就是说，编译的时候，JS引擎把我们对a的声明已经提前了 图片打水印怎么使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126// canvas生成水印makeWaterMark(content, &#123; container = document.body, width = 250, height = 200, textAlign = 'center', textBaseline = 'middle', font = '20px 微软雅黑', fillStyle = 'rgba(184, 184, 184, 0.8)', angle = 30, zIndex = 11000,&#125; = &#123;&#125;) &#123; // 创建画布 const cvs = document.createElement('canvas'); // 画布尺寸 cvs.width = width; cvs.height = height; // 上下文 const ctx = cvs.getContext('2d'); // 文字样式 ctx.textAlign = textAlign; ctx.textBaseline = textBaseline; ctx.font = font; ctx.fillStyle = fillStyle; // 文字旋转 ctx.rotate(angle * Math.PI / 180); // 绘制文字 ctx.fillText(content, width / 2, height / 2); // 生成base64图片编码 const base64Url = cvs.toDataURL(); // 生成水印容器div const div = document.createElement('div'); // CSS属性 div.id = 'watermark'; div.setAttribute('style', `position: fixed; top: 0; left: 0; width: 100 % ; height: 100 % ; z - index: $ &#123; zIndex &#125;; pointer - events: none; background - repeat: repeat; background - image: url('$&#123;base64Url&#125;')`); // 插入容器 container.insertBefore(div, null); return base64Url———————————————— // 通过SVG生成水印 (function () &#123; // svg 实现 watermark function __svgWM(&#123; container = document.body, content = '请勿外传', width = '300px', height = '200px', opacity = '0.2', fontSize = '20px', zIndex = 1000 &#125; = &#123;&#125;) &#123; const args = arguments[0]; const svgStr = ` &lt;svg xmlns="http://www.w3.org/2000/svg" width="$&#123;width&#125;" height="$&#123;width&#125;"&gt; &lt;text x="50%" y="50%" dy="12px" text-anchor="middle" stroke="#000000" stroke-width="1" stroke-opacity="$&#123;opacity&#125;" fill="none" transform="rotate(-45, 120 120)" style="font-size: $&#123;fontSize&#125;;"&gt;$&#123;content&#125;&lt;/text&gt;&lt;/svg&gt;`; const base64Url = `data: image / svg + xml; base64, $&#123; window.btoa(unescape(encodeURIComponent(svgStr))) &#125;`; const __wm = document.querySelector('.__wm'); const watermarkDiv = __wm || document.createElement("div"); // ... // 与 canvas 的一致 // ... &#125; )(); __svgWM(&#123; content: 'QQMusicFE' &#125;) ———————————————— // 浏览器给图片添加水印就是通过canvas绘制图片，然后增加文字的形式完成的。 (function () &#123; function __picWM(&#123; url = '', textAlign = 'center', textBaseline = 'middle', font = "20px Microsoft Yahei", fillStyle = 'rgba(184, 184, 184, 0.8)', content = '请勿外传', cb = null, textX = 100, textY = 30 &#125; = &#123;&#125;) &#123; const img = new Image(); img.src = url; img.crossOrigin = 'anonymous'; img.onload = function () &#123; const canvas = document.createElement('canvas'); canvas.width = img.width; canvas.height = img.height; const ctx = canvas.getContext('2d'); ctx.drawImage(img, 0, 0); ctx.textAlign = textAlign; ctx.textBaseline = textBaseline; ctx.font = font; ctx.fillStyle = fillStyle; ctx.fillText(content, img.width - textX, img.height - textY); const base64Url = canvas.toDataURL(); cb &amp;&amp; cb(base64Url); &#125; &#125; if (typeof module != 'undefined' &amp;&amp; module.exports) &#123; //CMD module.exports = __picWM; &#125; else if (typeof define == 'function' &amp;&amp; define.amd) &#123; // AMD define(function () &#123; return __picWM; &#125;); &#125; else &#123; window.__picWM = __picWM; &#125; &#125;)(); // 调用 __picWM(&#123; url: 'http://localhost:3000/imgs/google.png', content: 'QQMusicFE', cb: (base64Url) =&gt; &#123; document.querySelector('img').src = base64Url &#125;, &#125;); ———————————————— 路由器配置包体变化 浅拷贝深拷贝类型区别 html2的组件有没有使用过（是否是htmlcanvas） 文档跟图片的关系怎么转换，页面输出pdf展示怎么实现 技术中什么用的最多，是什么类型的 这里开始原生代码的测试题（分为初中级，初级题目做完会给中级题目做，并且解答出来答案会问为什么这样做） 函数作用是怎么确定的 开发环境跟生产环境的区别 最主要做过的项目 原生代码的问题 项目一个人开发还是多人开发 并发问题 前端有没有遇到过 有没有带人经验 对加班强度怎么看 为什么离职，离职的原因是什么]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试题(1)]]></title>
    <url>%2F2019%2F01%2F01%2F%E9%9D%A2%E8%AF%95%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98(1)%2F</url>
    <content type="text"><![CDATA[收集 es6 声明变量方法let const 12let 是拥有块级作用于，用于解决var引起的提升作用于的bugconst 定义常量，静态变量 promise async await 区别 123456async/await 是建立在promise上的。区别 async/await 不阻塞；讲异步代码处理成类似同步；没有很多then 代码简介 清晰；可以对await的函数 进行try catch; promise 不行；合并值两个异步 promise是两个嵌套。async/await 比较清晰，两个await，1个promise合并前面的2个返回值； Vue ；生命周期8个 ；组件传值(路由 父传子 子传父) 数据绑定双向数据绑定； Vuex 全局变量 ；UI库 element ui mint ui等 React/react-native 生命周期 组件传值(路由 父传子 子传父) 数据绑定单向数据绑定{}通过setstate实现 Webpack 原理 Webpack? 入口文件在哪里设置? 构建后生成的文件名中 app.4f5ce6e39d08aad93685.js，app和js之间的一串作用是? webpack里怎么配置的? css-loader和style-loader各自作用 (前者:处理依赖，比如import，url()，后者:把前者转变成js，运行时动态插入style标签) vue 生命周期 12345678beforecreate()；此时 data 和methods 还没有被初始化created() data 和method 已经初始化好了。beforeMount() 模版已经编译加载到内存中，但还未加载到页面上mounted() 已经加载到页面上了。看到的是渲染好的页面。beforUpdate() UI还没有更新，但是数据肯定被更新了，data是新数据，但是页面上的数据是旧数据updated() 已保持同步更新beforDestroy() 销毁前 做一些保存操作destroyed() 销毁后 内存销毁 vue 组件传值； 12345678910111213141516171819202122232425262728293031323334353637 (1)父传子；使用props 父： &lt;child-1 :btnName="btnName"/&gt; 子：用props 接收 name: 'Child1', props: ['btnName'] (2)子传父； vue 中的 $on 和 $emit 父注册监听：可以在组件上写函数 &lt;child-1 :btnName="btnName" @update:count="changeCount"/&gt; 子：触发函数：也可以传参数 clickHandle () &#123; this.$emit('update:count') &#125; (3)兄弟之间传值（1）是通过父组件中间件传值。A先传父，父再传B（2）也是可以通过$on和$emit来时实现的 但是要创建空的 vue对象来管理 on emit 创建中间件 import Vue from 'vue' export default new Vue() A中：emit import Event from '../bus' Event.$emit('update:count') B中：on import Event from '../bus' Event.$on('update:count', () =&gt; &#123; ++this.count &#125;) 传参数： this.$on('test', function (msg) &#123; console.log(msg) &#125;) this.$emit('test', 'hi') Vuex状态管理； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748action 提交mutation 而不是直接更改状态；action 可以异步；mutation只能同步；(1) 创建storeconst store =new Vuex.Store(&#123; modules: &#123; user &#125;, actions: &#123; SaveToken(&#123; commit &#125;, token) &#123; commit('SET_TOKEN',token); &#125; &#125;, mutations: &#123; SET_TOKEN: (state, token) =&gt; &#123; state.token = token; &#125; &#125;, getters &#125;); (2) 在store文件夹中新建一个getters.js，将token写进去 const getters = &#123; token: state =&gt; state.user.token &#125;; export default getters // 定义user const user = &#123; state: &#123; token：‘’ &#125; &#125; export default user; (3)在提交mutations修改store的时候可以用commit同步提交，也可以用dispatch异步提交 this.$store.dispatch('SaveToken',“token”).then((res) =&gt; &#123; &#125; 读取的时候： import &#123; mapGetters &#125;from 'vuex'; computed: &#123; ...mapGetters([ 'token' ]) &#125; React/react-native 生命周期 12345678react的组件 分三种 mounting updating unmountingcomponentWillMount() 渲染前componentDidMount() 第一次渲染之后调用，已经生成了Dom结构；componentWillReceivesPropos()接收到新的props会调用，在render时不会调用shouldComponentUpdate() componentWillUpdate()componentDidUpdate()compontentWillUnmount() 其他问题12345开发遇到的技术问题前面的面试你自己觉得怎么样你觉的你在之前公司表现如何，怎么体现，举例说明；$set;$nextStike;$forceUpdate() 区别，分别使用场景；vue的更新机制；]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue环境配置]]></title>
    <url>%2F2018%2F12%2F21%2FVue%2FVue%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Vue环境配置 需要配置有node / npm. 终端查看node -v npm -v 查看是否有，如果没有需要提前安装 vue -V 查看是否安装Vue 12mayloverdeMacBook-Pro:~ maylover$ vue -V-bash: /usr/local/bin/vue: No such file or directory npm install -g @vue/cli 安装Vue脚手架 123456789mayloverdeMacBook-Pro:~ maylover$ npm install -g vue-clinpm WARN deprecated coffee-script@1.12.7: CoffeeScript on NPM has moved to "coffeescript" (no hyphen)/usr/local/bin/vue -&gt; /usr/local/lib/node_modules/vue-cli/bin/vue/usr/local/bin/vue-init -&gt; /usr/local/lib/node_modules/vue-cli/bin/vue-init/usr/local/bin/vue-list -&gt; /usr/local/lib/node_modules/vue-cli/bin/vue-list+ vue-cli@2.9.6added 239 packages from 206 contributors in 56.677smayloverdeMacBook-Pro:~ maylover$ vue -V2.9.6 vue create hello-world 创建项目 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849mayloverdeMacBook-Pro:~ maylover$ vue init webpack first-vue? Project name first-vue? Project description A Vue.js project? Author ** &lt;ytxinguan035@163.com&gt;? Vue build standalone? Install vue-router? Yes? Use ESLint to lint your code? No? Set up unit tests No? Setup e2e tests with Nightwatch? No? Should we run `npm install` for you after the project has been created? (recommended) npm vue-cli · Generated "first-vue".# Installing project dependencies ...# ========================npm WARN deprecated browserslist@2.11.3: Browserslist 2 could fail on reading Browserslist &gt;3.0 config used in other tools.npm WARN deprecated bfj-node4@5.3.1: Switch to the `bfj` package for fixes and new features!npm WARN deprecated browserslist@1.7.7: Browserslist 2 could fail on reading Browserslist &gt;3.0 config used in other tools.&gt; fsevents@1.2.7 install /Users/maylover/first-vue/node_modules/fsevents&gt; node installnode-pre-gyp WARN Using request for node-pre-gyp https download [fsevents] Success: "/Users/maylover/first-vue/node_modules/fsevents/lib/binding/Release/node-v64-darwin-x64/fse.node" is installed via remote&gt; uglifyjs-webpack-plugin@0.4.6 postinstall /Users/maylover/first-vue/node_modules/webpack/node_modules/uglifyjs-webpack-plugin&gt; node lib/post_install.jsnpm notice created a lockfile as package-lock.json. You should commit this file.npm WARN ajv-keywords@3.4.0 requires a peer of ajv@^6.9.1 but none is installed. You must install peer dependencies yourself.added 1194 packages from 667 contributors and audited 10657 packages in 109.913sfound 8 vulnerabilities (1 low, 6 moderate, 1 high) run `npm audit fix` to fix them, or `npm audit` for details# Project initialization finished!# ========================To get started: cd first-vue npm run dev Documentation can be found at https://vuejs-templates.github.io/webpackmayloverdeMacBook-Pro:~ maylover$ npm run dev 开发测试 npm run build 打包 Vue项目工程配置 搭建一个完美的vue项目的基础工程 123456789101112131415161718192021vue + webpack + sass/less + es6 + async+ Element + router + store + bable 1、先用webpack搭建一个最简单的web项目，学习webpack的几个核心概念，插件，loader等等等。2、添加 webpack-dev-server，实现工程启动启动打开浏览器，热替换等功能。3、添加引用css样式支持，然后添加sass，less支持等。4、添加babel编译（将es6编译成es5），eslint编写检查等功能。5、添加vue支持。6、添加各类vue-router，vuex等功能支持。7、最后添加element支持。8、开发环境配置好了，在写打包配置。1/ 全局公共文件 这里设置版本号， 获取host 判断dev test pro 环境， 全局公共url / cdn 地址等信息2/ axios 的封装， 这里根据项目做特殊处理，get/post二次封装等， 例如拦截所以请求添加 token ，对dev 环境中的url 添加固定的 api标示（后端代理请求跨域处理） 当请求异常时是否做弹窗提示等；3/ api 管理，全局 API 提取当公共文件中，通过dispatch 触发，当前页面内部的业务api 直接写在当前vue文件中4/ 错误异常收集并上报处理， 利用$bus(具体实现看业务需求)5/ router 做 require 按需加载，个人习惯 每个 业务独立一份router.js 管理 全局 通过addRoutes 添加6/ views 下面按照业务分类为 文件夹形式，不太习惯另一种模式（components 下一切皆组件），太难找了，不好区分7/ 组件间嵌套尽量不超过3级8/ eslint 的配置， 官网配置的是 save 的是运行lint， 我个人 习惯借用husky的precommit时运行lint9/ 分包处理， 防止单文件过大 cd first-vue 进入项目内 npm run dev启动项目]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>前端环境</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RN环境配置]]></title>
    <url>%2F2018%2F12%2F10%2FReactNative%2FRN%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[搭建RN环境 1.安装Homebrew： Homebrew, Mac 系统的包管理器，用于安装 NodeJS 和一些其他必需的工具软件 1/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" homebrew 在安装软件时可能会碰到/usr/local目录不可写的权限问题。 1sudo chown -R `whoami` /usr/local 上述步骤中会提示输入密码然后开始下载Homebrew，如果此时网速不稳定可能会出现错误提示：curl: (35) Server aborted the SSL handshake。 此时需要执行卸载操作，输入如下命令进行卸载 1/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)" 2.使用Homebrew来安装npm Node.js. 1brew install node 3.nrm 是一个npm 源管理器，允许你快速地在如下 npm 源间切换： 安装 1npm install -g nrm 使用查看源 1nrm ls 测试源 1234测试一个nrm test npm 测试所有nrm test 更换源 1nrm use taobao 4.安装WatchMan/安装Flow 该插件用于监控bug文件和文件变化 ，并且可以触发指定的操作 1brew install watchman flow是一个 JavaScript 的静态类型检查器，安装后，方便找出代码中可能存在的类型错误 1brew install flow 5.React Native安装 安装React Native： 1npm install -g yarn react-native-cli 如果提示root权限不够 1sudo npm install -g react-native-cli 6.创建新项目 12react-native init 项目名称react-native init 项目名称 --version 0.40.0 //创建一个指定版本为0.40.0版本的项目 7.配置iOS/android之后 运行项目 iOS 1react-native run-ios android 1react-native run-android 8.其他命令 查看本地的React Native的版本 1react-native --version 升级或者降级npm包的版本 1npm install --save react-native@0.18 更新本地的React Native的版本 1npm update -g react-native-cli 更新项目templates文件 1react-native upgrade 搭建iOS开发环境 1.下载Xcode AppStore 下载，或者AppDeveloper中心download下载 2.安装cocoapods 开始安装 1sudo gem install -n /usr/local/bin cocoapods 如果安装了多个Xcode使用下面的命令选择（一般需要选择最近的Xcode版本） 1sudo xcode-select -switch /Applications/Xcode.app/Contents/Developer 安装本地库 1pod setup 使用终端cd到工程目录下 创建Podfile文件： 12cd xxx/xxx/xxx/iospod init 安装第三方库 1pod install 3.安装cocoapods中间的问题 用web storm 运行react-native 工程时，出错： 1xcrun: error: unable to find utility "instruments", not a developer tool or in PATH 解决方法： 前提是你已经安装了xcode在 终端执行如下命令 1sudo xcode-select -s /Applications/Xcode.app/Contents/Developer/ 安装pod install 时候 停在installing React 上 12345678910111213141516需要安装React的依赖pod 'React', path: rn_path, subspecs: [ 'Core', 'RCTActionSheet', 'RCTAnimation', 'RCTGeolocation', 'RCTImage', 'RCTLinkingIOS', 'RCTNetwork', 'RCTSettings', 'RCTText', 'RCTVibration', 'RCTWebSocket' ] pod 'aliyun-oss-react-native', :path =&gt; '../node_modules/aliyun-oss-react-native' [iOS][cocoapods] ‘RCTAnimation/RCTValueAnimatedNode.h’ file not found 123It works if change#import &lt;RCTAnimation/RCTValueAnimatedNode.h&gt; to #import "RCTValueAnimatedNode.h" 搭建Android 开发环境 1下载安装JDK 查看JDK版本 2.下载Android Studio2.0 或更高版本。]]></content>
      <categories>
        <category>RN</category>
      </categories>
      <tags>
        <tag>前端环境</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试笔记1]]></title>
    <url>%2F2018%2F12%2F03%2F%E9%9D%A2%E8%AF%95%2F%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[UI卡顿/掉帧的原因滑动优化方案 针对CPU 对象创建调整销毁；预排版；布局计算，文本计算；预渲染，异步绘制，图片解码等 针对GPU 纹理渲染，涂层混层等 绘制原理 1.调用view.setNeedDisplay()之后，调用view.layer.setNeedDisaplay(),等当前runloop将要结束工作时，执行CAlayer.setNeedDisplay() 2.CAlayer 判断是否响应displayLayer代理，响应了就进入异步绘制入口，否 进入系统绘制流程 3.系统绘制流程 CAlayer 创建上下文，判断是否有代理，有代理，让代理执行执行layer.delegate.drawLayer(inContext),之后触发回调返回到UI view.drawRect();无代理，调用drawInContext();两个结果之后，CAlayer 把上下文/位图交给GPU绘制 4异步绘制layer.delegate.displayLayer() 如果laye的代理响应了dispalyLayer() 方法，就会在子线程中执行位图操作，根据CoreGraphigcs创建位图上下文;绘制path;上下文生成图片；回到主线程，CALayer继续执行setContents 离屏渲染？在屏渲染在屏渲染，当前屏幕缓冲区]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[300道iOS面试题（附参考答案）]]></title>
    <url>%2F2018%2F12%2F02%2F%E9%9D%A2%E8%AF%95%2F300iOS%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前端2、如何实现一个倒计时功能，类似于蘑菇街中的秒杀。 3、怎么理解es6箭头函数中的this，它和一般函数的this指向有什么区别呢？ 4、一个矩形，里面一个樱桃，过樱桃做一条直线， 并且没有数据和测量工具，如果做到评分矩形呢？ 5、说一下同源策略 6、vue中的路由时如何管理的？ 你知道他的实现方式吗？ 7、提到了我的博客，问我的博客相关问题。 8、retina屏幕的了解 9、说一说移动端的布局。 flexible。 10、知道原理吗，怎么自己去实现一个flexible。 rem布局的实现原理。移动端的点透是什么，有没有了解 11、说一说异步编程的方式有哪些。 12、项目中的设计是怎么回事，说说设计方面。 13、你博客里的轮播图，如果还要优化，你会怎么去优化。 14、你最喜欢的es6中的特性是什么，为什么。 16、css布局的属性有哪些。 17、有没有遇到过这样的问题： 一个有border的div，里面有一个图片，发现图片和下面的border有一定的空隙（baseline）。 18、函数调用的方式有哪些。他们的区别是什么。 19、说一说原型链（这个要非常清楚）。 20、用过什么框架。jquery用过吗？ 22、给你一个项目，你使用jquery还是vue、react。为什么。（这个问题也是会被经常问到的） 23、说一说异步编程。 24、说一说回调地狱是什么，有什么问题。异常捕获怎么做。 25、说一说promise。 一个promise有多个then，如果第一个then出错，后面的还会执行吗，如何捕获异常。 如果第一个then出错了，我还想要后面的继续执行，应该怎么做。 26、你在学习js的时候，遇到过哪些js方面的坑、 你觉得js哪些知识会难一些。 27、 MVC 具有什么样的优势，各个模块之间怎么通信，比如点击 Button 后 怎么通知 Model？ 28、两个无限长度链表（也就是可能有环） 判断有没有交点 68、对安全方面有何了解？如何应对web页面被劫持？了解HTTPS加密解密的过程吗69、vue和react有什么区别？70、angular用过吗？71、说一下同源策略？ 说一个JSONP？ （同源策略和跨域的多种方式还是要很熟练的）72、304和200的区别是什么。 （状态码也是必须要掌握的，包括各种区别）73、你所知道的前端优化有哪些内容？ （常考的问题，多多总结就好了）74、linux知道吗？ 你所知道的linux命令有哪些？75、vue中v-if和v-show的区别是什么？ （这个实在是记不住了，但是说明了vue不好就是因为api太多）76、你看过哪些书? （比如计算机的几门专业课、JavaScript高级程序设计、css揭秘、你不知道的JavaScript、深入react技术栈、图解http等等）77、你会的技术包括哪些 84、简洁、对于不同的类型，如何做出对比？85、说一下vue和react中的路由实现方式？86、说一下强缓存和协商缓存？ （浏览器的缓存机制也需要很清楚）87、跨域？88、说一下设计模式？89、其中的一个项目，你究竟做了哪些优化？90、websocket聊天室如果发送失败了，你怎么解决这个问题？如何做到发送图片？ 有了文字、图片等不同的数据类型之后，你如何实现数据的存储，如何设计，前端如何获取？91、websocket聊天室有输入框，那么怎么获取的，对于使用div来模仿textarea，我说使用正则去掉div，那么用户输入的也是div呢？ 如果发送失败了呢？ 究竟应该是先发送，还是应该先存储到redux中，考虑用户体验（仿照微信）。92、为什么数据库使用的是mongodb而不是mysql。93、什么是xss，如何防止xss？94、边边购项目说一下？登录的整个过程是什么？ 购物车是怎么存储设计的？ 如果LocalStorage中数据的值超过了范围，你该如何去处理这个问题？ 如果商品下架了，那么你如何显示这个商品？ 登录的过程中，一个用户退出登录，另一个用户登录，那么这个购物车是否还是存在的。 说一下边边购项目的多个不同的模块。95、说一下你说的项目中遇到的问题，然后你是如何解决这个问题的？ （这个可以好好准备一下~）96、websocket的使用，底层是如何处理的。（类似于xhr的。）、97、websocket在连接的过程中， 会有新包。。balabala 一堆听不懂的词，非常尴尬，，， 我就直接说的不会。98、手写代码 判断是否是浏览器环境。99、http和https https的整个过程画一下100、httPS需要多少时间 比http慢多少 怎么优化101、https有什么缺点102、手写快速排序 复杂度 最慢是多少 为什么取第一个值作为中间值 如果这个值是最大的或者最小的怎么办103、http2有哪些特性 头部压缩怎么回事 iOS29、UITableView 的相关优化30、KVO、Notification、delegate 各自的优缺点，效率还有使用场景31、如何手动通知 KVO32、Objective-C 中的 copy 方法33、runtime 中，SEL 和 IMP 的区别34、autoreleasepool 的使用场景和原理35、RunLoop 的实现原理和数据结构，什么时候会用到36、block 为什么会有循环引用37、使用 GCD 如何实现这个需求：A、B、C 三个任务并发，完成后执行任务 D。38、NSOperation 和 GCD 的区别39、CoreData 的使用，如何处理多线程问题40、如何设计图片缓存？41、有没有自己设计过网络控件？42、怎么判断某个 cell 是否显示在屏幕上43、进程和线程的区别44、TCP 与 UDP 区别45、TCP 流量控制46、数组和链表的区别47、UIView 生命周期48、如果页面 A 跳转到 页面 B，A 的 viewDidDisappear 方法和 B 的 viewDidAppear 方法哪个先调用？49、block 循环引用问题50、ARC 的本质51、RunLoop 的基本概念，它是怎么休眠的？52、Autoreleasepool 什么时候释放，在什么场景下使用？53、如何找到字符串中第一个不重复的字符54、哈希表如何处理冲突56、登录状态怎么保持？57、为什么用本地存储，而不用session，session更加简单啊！58、http和https的区别是什么？ （http、https、http2这些都是经常被问到的）59、post和get的区别是什么？ 63、为什么要用Alamofire而不用原生的NSURLSession，Alamofire的优势是什么？64、如果让你来封装一个网络库，类似于Alamofire或者SDWebImage，你会如何实现？65、在网络库中，如何针对TableView快速滚动过程中的图片额外渲染进行优化(网络库不能持有TableView)？66、iOS的系统架构是怎么样的？常用SDK有哪些？67、了解HTTP协议吗？GET和POST的区别是什么？ 算法81、一个DOM树，其中有两个节点，找出这两个节点公共的父节点？ （视频面试）82、说一下二叉树？83、如果反转二叉树？ 104、100层 1个花瓶仍 找到n层不碎 n + 1层碎了的情况 2个花瓶呢 105、node了解多少 全局对象是什么106、事件机制说一下 事件绑定说一下 手写如何把div中的a放在平级其中的事件会怎么样 冒泡会到document还是window108、xss怎么防范 尖括号应该怎么过滤，一直问确定吗，最后也没说清楚109、用过哪些框架110、移动端如何真机调试111、tap是怎么回事、和click的区别。。。112、cookie和session有什么区别113、说一下浏览器缓存问题114、动态规划是怎么回事115、进程和线程的区别是什么116、说一下restful api吧，117、说一说post和get的区别，118、说一下状态码吧119、你觉得什么样的代码是好的代码 （这个其实还挺考验实力的）120、说一下position的几个属性吧。121、typescript你用过吗？123、框架对比一下124、cookie和session有什么区别，cookie的大小是多少。125、css3了解多少，说到了渐进增强和优雅降级126、vue接触过多长时间、react接触过多长时间、129、你还转载过美团的文章？嗯 （很多面试官还是会看博客的，谢谢博客总是好的）130、cookie和localStorage区别，如何把cookie写在一个对象中，其属性就是键值对131、实现水平竖直居中的几中方法（高度和宽度不确定）132、flex是什么133、深拷贝和浅拷贝的区别，手写深拷贝 （博客里总结过，遂让手撕）134、Oject的几中方式，如何区分 （这个也是常考的）135、兼容性说一说，你做的PC端兼容性是到哪的136、如何看待最近react事件 （百度、wordpress弃用事件。可以多关注前端的一些动态）137、JQuery和三大框架的区别，react和vue的区别138、说一说CSS3中的动画，animation中可以取哪些值 （css3动画也很重要）139、flex布局是什么，默认的方向是什么，如何改变方向140、你的博客都是自己写的吗？ 你所有所学都会写成博客吗？141、说一说原型和原型链，object是最上面的吗？142、vue中的数据双向绑定是如何实现的、143、display有哪些，回答了7 8个，还是不满意144、你的node项目中有几个线程，有几个进程，如果node进程崩溃了，如何知道145、node中的process是什么146、node中如何创建子进程/19讲一讲你遇到的比较困难的事情，问了两个，最后是怎么解决的147、CSS中的单位有哪些分别说一说 （提到了ex）148、你未来的发展规划是怎么样的149、跨域，举一个例子，安全性问题到底在哪里150、100万个数据中，找出前10大数据，最快的方法是什么，堆排序怎么写151、登录状态怎么使用cookie保持，最好的方法是什么152、页面中一个video，可能格式不支持，那么前端如何判断并给出提示？153、通过比较img的onerror是一种方法， 通过服务器端也可以保存一些属性来标识哪些浏览器支持，哪些不支持154、为什么要用vue和react，而不用JQuery，给你一个项目，什么情况下使用单页面应用，什么情况下使用多页面应用。155、你所知道的前端大会有哪些，比如腾讯web前端大会，CSS conf大会，js conf大会。156、你学习的前端号有哪些，比如前端早读课，那么维护者是谁。157、前端的表单中如何设置表单的方式，如multipart, www等，对于multipart具体是如何区分其中的不同的格式的158、http2的所有特性。159、http2中的头部压缩和多路复用。160、迅雷一面比较基础，二面会根据项目扩展，体验还是不错的，和面试官聊得很开心。161、post、put和get的区别什么162、localStorage和sessionstorage的区别是什么163、页面加载速度很慢，如何加速页面的渲染164、输入了一个URL之后发生了什么165、图片很大，如何进行优化166、手写二分查找167、画出TCP三次握手的过程168、websocket是如何实现服务器端推送的169、你对迅雷了解多少？170、websocket和http的区别是什么？websocket的优点是什么？171、为什么使用websocket？ websocket是怎么连接的，一定需要通过http协议吗？ 短轮询、commet、长轮训都介绍一下。各有什么优缺点。172、聊天室如何兼容IE8173、http1.1中的keep-alive是怎么理解的？174、setTimeout和setInterval175、原型、原型链、继承等。176、http1.0、http1.1、http2 （这三者还是要会区分的，也会经常被问到）177、css3动画相关178、html、css、js分别实现一个动画效果。179、说一下你做过的几个项目吧。180、框架对比一下181、你在项目中用过 runtime 吗？举个例子。182、runtime 中，SEL 和 IMP 的区别183、 MVC 具有什么样的优势，各个模块之间怎么通信，比如点击 Button 后 怎么通知 Model？184、你在项目中用过 GCD 吗？举个例子。185、Category 的实现原理，以及 Category 为什么只能加方法不能加属性。186、有没有自己设计过网络控件187、block 的原理，block 的属性修饰词为什么用 copy，使用 block 时有哪些要注意的？188、iOS 的热更新方案有哪些？介绍一下实现原理。189、KVO、Notification、delegate 各自的优缺点，效率还有使用场景190、cookie和session有什么区别，cookie的大小是多少。191、css3了解多少，说到了渐进增强和优雅降级192、vue接触过多长时间、react接触过多长时间、193、你对互联网公司怎么看，你想要什么样的公司、未来是怎么样的。194、乐信你了解多少，你对来深圳工作怎么看。195、class A 继承 class B，class B 继承 NSObject。画出完整的类图。196、细致地讲一下事件传递流程197、main()之前的过程有哪些?198、Category 中有 load 方法吗？load 方法是什么时候调用的？load 方法能继承吗？199、讲一下你对 iOS 内存管理的理解200、使用 GCD 如何实现这个需求：A、B、C 三个任务并发，完成后执行任务 D。201、你在项目中是怎么优化内存的？202、讲讲 RunLoop，项目中有用到吗？203、列表卡顿的原因可能有哪些？你平时是怎么优化的？204、项目有没有做过组件化？或者你是否调研过？205、讲一下 OC 的消息机制206、ARC 都帮我们做了什么？207、如何手动通知 KVO208、c++ new 和 malloc 有什么区别？209、c++ 可不可以多继承？210、c++ 引用和指针的区别？211、如何判断两个链表是否有交点？212、堆区和栈区有什么区别？为什么要这么设计？213、给栈增加一个Max函数接口，返回当前栈的最大值，应该如何设计？214、给定排好序的整数数组array[]以及整数n，如何找出和为n的两个数？215、如果没排好序呢？216、一个字符串，如何找出只出现一次并且最先出现的字符？217、反转字符串218、判断整数是否为219、一个m*n的棋盘，有些格子不能走，如何找到左上角到右下角的最短路径？220、iOS 按下 Home 键之后会发生什么？221、c++中内存分配是怎样的？222、c++中常用的容器有哪些？223、queue和vector有什么区别？224、vector底层是怎么实现的？225、TCP三次握手？为什么两次不行？226、项目中有没有服务器push机制？227、两个无限长度链表（也就是可能有环） 判断有没有交点228、实现 isEqual 和 hash 方法时要注意什么？229、block 为什么会有循环引用230、如何设计图片缓存？231、CoreData 的使用，如何处理多线程问题232、property 的常用修饰词有哪些？weak 和 assign 的区别？weak 的实现原理是什么？233、线程安全的处理手段有哪些？把你想到的都说一下。234、说一下 OperationQueue 和 GCD 的区别，以及各自的优势235、Swift 中 struct 和 class 的区别236、Swift 是如何实现多态的？237、Swift 和 OC，各自的优缺点有哪些？238、如果让你实现 NSNotificationCenter，讲一下思路240、如果让你实现 GCD 的线程池，讲一下思路241、为什么是三次握手？为什么是四次挥手？三次挥手不行吗？242、讲一下 HTTPS 密钥传输流程243、UITableView 的相关优化244、讲讲 MVC、MVVM、MVP，以及你在项目里具体是怎么写的？245、iOS 系统框架里使用了哪些设计模式？至少说6个。246、你自己用过哪些设计模式？247、NSOperation 和 GCD 的区别248、Objective-C 中的 copy 方法249、 autoreleasepool 的使用场景和原理250、哪一个项目技术点最能体现自己的技术实力？具体讲一下。266、你在项目中遇到的最大的问题是什么？你是怎么解决的？267、用 Alamofire 比直接使用 URLSession，优势是什么？268、你是如何学习 iOS 的?269、和产品经理、测试产生冲突时，你是怎么解决的？270、手写一下快排271、遍历一个树，要求不能用递归272、RunLoop 的实现原理和数据结构，什么时候会用到273、找出两个字符串的最大公共子字符串274、假设ViewController中需要用一个Blcok来改变ViewController中的一个属性，需要怎么实现？275、这样实现之后，这个Block在内存中被存在何处？引用关系又是怎么样的？276、函数中的闭包，如果要求闭包执行完后立刻改变函数中某个变量的值，应该如何实现？277、如何实现一个类似于微信聊天界面的布局？278、如何用Auto Layout实现一个如下要求的布局： %&amp;@$@(#!…… （说了一大堆 =。= 反正就是使用优先级就解决了）279、说一说 MVC 和 MVVM 的区别，以及各自的优缺点。280、如何将 MVC 改造成 MVVM ？在MVVM中，网络请求、缓存处理的部分应该放在哪个模块？281、为什么说Swift是面向协议的语言？使用 Protocol 有什么好处282、比较一下 Swift 和 Objective-C 在语言层面上的安全性？283、如果ViewController中使用闭包时，用weak避免循环引用，会有什么问题？284、当点击一个View时，发生了什么？如何扩大点击区域？285、如何对TableView进行优化？286、能讲一讲你对光栅化的理解吗？287、对Swift和OC有什么看法？288、能对Swif中的可选类型谈下你的理解吗？289、说一下快排的伪代码和时间复杂度？290、怎么判断两个链表是否相交？291、怎么反转二叉树？292、了解元组吗？293、了解多线程吗？294、什么是并行？295、现在有ABC三个任务，如何实现AB完成后再执行C？296、对 Runtime 有什么了解？297、HTTP 和 HTTPS 有什么区别？298、知道 HTTPS 通信过程吗？299、Struct 和 Class 有什么区别？300、为什么要设计Cache？Cache分级有什么好处？301、如何保证多核数据的一致性]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>iOS面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端基础2]]></title>
    <url>%2F2018%2F12%2F01%2F%E9%9D%A2%E8%AF%95%2FFrontPrevew1%2F</url>
    <content type="text"><![CDATA[js 1.JS的typeof 会返回什么数据类型 -&gt; (object| number|function|boolen|undefind) 判断一个字符串中出现的次数最多的字符，统计这个次数 12345678910111213141516171819test1()&#123; var str = 'asdfssaaasasasasaa'; var json = &#123;&#125;; for (var i = 0; i &lt; str.length; i++) &#123; if(!json[str.charAt(i)])&#123; json[str.charAt(i)] = 1; &#125;else&#123; json[str.charAt(i)]++; &#125; &#125;; var iMax = 0; var iIndex = ''; for(var i in json)&#123; if(json[i]&gt;iMax)&#123; iMax = json[i]; iIndex = i; &#125; &#125; alert('出现次数最多的是:'+iIndex+'出现'+iMax+'次');&#125; 写一个获取非行间样式的函数 1234567891011getStyle(obj,attr,value) &#123; if(!value) &#123; if(obj.currentStyle) &#123; //ie return obj.currentStyle(attr); &#125;else&#123; //标准浏览器 obj.getComputedStyle(attr,false); &#125; &#125;else &#123; obj.style[attr] = value; &#125;&#125; 闭包是什么，有什么特性，对页面有什么影响 闭包是能读取其他函数内部变量的函数 会延长函数变量的声明周期 JSONP 的原理 为什么不是真正的Ajax jsonp 只是动态创建script标签，回调函数 Ajax 是页面无刷新请求数据操作 JS的本地对象，内置对象 宿主对象 本地对象可以new实例化的 array obj regexp 内置对象 不可以实例化 的，gload math 等 宿主对象 BOM对象 document window等 Window.location.search 返回什么？(返回问好后面的，?number1&amp;page=2&amp;id=2111) Window.location.hash返回的是什么？(#后面的锚点http://www.sina.com/getage?#age 中的#age) 阻止冒泡函数 兼容W3C 和IE 12345678stopPropagation(e) &#123; e = e || window.event; if(e.stopPropagation) &#123; //W3C阻止冒泡方法 e.stopPropagation(); &#125; else &#123; e.cancelBubble = true; //IE阻止冒泡方法 &#125; &#125; 对象和函数的log 12345678910111213unction f1()&#123; var tmp = 1; this.x = 3; console.log(tmp); //A console.log(this.x); //B&#125;var obj = new f1(); //1console.log(obj.x) //2console.log(f1()); //3 // 1 构造函数，内部的this 就是f1 ,log:1,3// 2 创建的实例：log:3// 3. 简单的一个函数：this是window，JS特性是向外层去找，所以log: 1 3 undefined 函数的作用域问题： 1234567891011121314function changeObjectProperty (o) &#123; o.siteUrl = "http://www.csser.com/"; o = new Object(); o.siteUrl = "http://www.popcg.com/";&#125;var CSSer = new Object();changeObjectProperty(CSSer);console.log(CSSer.siteUrl); ///*如果 CSSer 参数是按引用传递的，那么结果应该是 "http://www.popcg.com/"，但实际结果却仍是"http://www.csser.com/"。事实是这 样的:在函数内部修改了引用类型值的参数，该参数值的原始引用保持不变。我们可 以把参数想象成局部变量，当参数被重写时，这个变量引用的就是一个局部变量，局 部变量的生存期仅限于函数执行的过程中，函数执行完毕，局部变量即被销毁以释放 内存。(补充:内部环境可以通过作用域链访问所有的外部环境中的变量对象，但 外部环境无法访问内部环境。每个环境都可以向上搜索作用域链，以查询变量和函数 名，反之向下则不能。)*/ JS 加减运算 alert(&#39;5&#39;+3) 数字和字符串加 转换为字符串格式 alert(‘5’-3) 字符串和数字减 转换为Number类型 为什不能定义1PX 的div 容器 IE6这个问题是默认行高造成的，解决：overflow:hidden zoom:0.08 line-height:1px 闭包函数运行log 123456789101112131415161718192021222324function foo()&#123; foo.a = function()&#123; alert(1) &#125;; this.a = function()&#123; alert(2) &#125;; a = function()&#123; alert(3) &#125;; var a = function()&#123; alert(4) &#125;;&#125;;foo.prototype.a = function()&#123; alert(5)&#125;; foo.a = function()&#123; alert(6)&#125;;foo.a(); //6var obj = new foo();obj.a(); //2foo.a(); //1 匹配输入的字符：第一个必须是字母或下划线开头，后面的是字母数字或者下划线构成，长度5-20 /^[a-zA-Z_][a-zA-Z0-9_]{4,19}/ html添加事件的几种方法 onclick attachEvent addEventListener BOM的对象？ Window 是JS的最顶层 其他BOM对象都是Window的属性 doucument 文档对象 location 浏览器的当前URL navigation 浏览器本身信息 screen 客户端屏幕信息 history 浏览器访问历史信息 JS中的简单继承 Call方法 12345678910111213141516171819202122function textCallAction() &#123; function Parent(name, money)&#123; this.name = name; this.money = money; this.info = function()&#123; console.log('姓名: '+this.name+' 钱: '+ this.money); &#125; &#125; //定义孩子类 function Children(name)&#123; Parent.call(this, name); //继承 姓名属性，不要钱。 this.info = function()&#123; console.log('姓名: '+this.name); &#125; &#125; //实例化类 var per = new Parent('parent', 800000000000); var chi = new Children('child'); per.info(); // 查询自己有方法 chi.info(); // 查询自己有方法，如果没有向父类查询&#125; bind() live() delegate() 的区别？ bind 绑定事件，对新添加的事件不起作用，方法用于将一个处理成语附加到每个匹配事件上并返回Jquery 对象 live 方法将一个时间处理程序附加到与当前选择器匹配到所有的元素的制定事件上并返回JQuery对象 delegate 放大基于一组特定的根元素将处理程序附加到匹配选择器的所有元素的一个或者多个事件上 typeof [1,2] 返回的object | 返回的类型有 boolen string number object function undefined Link 和import的区别 用途：Link是Html标签 除了加载CSS 外，还可以定义RSS的其他事物，@import 属于CSS范畴 只能加载CSS 载入时机：Link引用CSS时，在页面载入的时候加载，@import 网页完全载入之后加载 兼容性问题：Link时html标签，无兼容性问题 @import时CSS2.1提出来的，低版本无法兼容 改变样式：Link支持用JS控制DOM去改变样式 @import不支持 Window.onload 和Window.ready的区别？ Load需要图片和包含的文件都在加进来之后执行 ready是不包含图片和非文字的 文档结构准备好就执行 DOM结构绘制完成之后就执行 如何优化代码 代码重用 避免使用全局变量 拆分函数 -&gt; 避免函数过于臃肿单一职责 适当的注释 尤其是复杂的业务逻辑和计算逻辑 应写出业务逻辑的具体过程 内存管理，闭包的变量的释放 文本域当按下enter 键时，不换行，而是换成 123456789function replaceTextEnterKey()&#123; var dom = document.getElementsByTagName('textarea') dom.onkeyup = function (e)&#123; e.preventDefault() //为了阻止 enter 键的默认换行效果 if(e.keycode == 'enter键码')&#123; dom.value+="&#123;&#123;enter&#125;&#125;"; &#125; &#125;&#125; 用原声的JS实现Jquer的Post/get 请求 以及跨域问题 1234占位置：POST：GET：跨域配置 web 前端性能优化 优化思路？ 网络资源 ：设置缓存 减少Http请求 本地资源：多个小图配置程精灵图， 加载进度 JS 循环引用 重复代码合并抽取 没用的图片定期删除 减小包体积 reayonly 与disable的区别 readonly 只针对inputtext / passwodd 和textarea 有效 而disable 对于所有的表单元素都有效，当表单元素使用了disable之后，当把表单提交的时候，元素值不会传递出去 readonly 会将值传递出去 尽可能详尽的解释Ajax的工作原理 Ajax原理通过XMLHttpRequest对象来向服务器发异步请求 ，从服务器获得数据，然后通过JS来操作DOM来更新界面， XMLHttpRequest时Ajax的核心机制，是IE5首先引入的，支持异步请求的技术， JS同源策略: 域名 协议 端口 相同 如何实现设计中用了非标准的字体? HTTP 协议中GET 金和POST有什么区别，分别使用什么场景 使用场景： get 传送的数据长度有限制，post没有 get 通过url 传递 在浏览器地址栏可见，post在报文中传递 post一般用于表单提交 get一般用于简单的数据查询，严格要求不那么高的场景 HTTP状态码 【200 302 304 403 404 500】分别表示什么 200请求成功 302临时重定向 客户端应当继续原有的地址发送以后的请求，只有在cache-control 或Expirse中进行了指定的情况下这个相应才是可缓存的 304如果客户端 发送了一个带条件的GET请求并且被允许，而内容没有改变，304响应禁止包含消息体 因此消息头后以第一个空行结尾 403 服务器拒绝执行 404 请求失败，请求的资源未在服务器上发现 500 服务器遇到了一个未曾预料的状况，导致无法完成对请求的处理，一般出现在服务器端代码出现错误 HTTP协议中，header信息里面 -&gt; 怎么控制页面失效时间？ last-modified cache-control Expires Last-Modified 文档最后修改的时间 客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304(Not Modified)状态 Last-Modified也可以通过setDateHeader 方法来设置 Expires 应该在什么时候认为文档过期，从而不再缓存它 优化常用的优化WEB页面加载速度的方法(从网络请求 CSS JS 服务器等) JS中实现一个map 123456789101112function testMap()&#123; Array.prototype.map2=function(callback)&#123; for (var i = 0; i &lt; this.length; i++) &#123; this[i]=callback(this[i]); &#125; &#125;; var temq = [&#123;name:'1'&#125;,&#123;name:'2'&#125;,&#123;name:'3'&#125;,&#123;name:'4'&#125;] temq.map2(obj=&gt; obj2.name) var nameStr = temq.map2(function (amodel) &#123; return amodel.name &#125;) &#125; 如何获取对象A的所有属性(可枚举的，不可枚举的，不包括继承来的属性) 123456Object.keys——IE9+//或者使用 for...in 并过滤出继承的属性 for(o in obj)&#123; if(obj.hasOwnproperty(o))&#123; //把 o 这个属性放入到一个数组中 &#125; &#125; 三种弹框的单词三种弹框的功能 【alert confirm prompt】 console.log(8 | 1) -&gt; log:9 JS数组添加，删除 排序 方法有哪些 12345678910111213Array.contact() //拼接数组Array.join() // 用，拼接 Array.length // 数组长度Array.pop() //尾部删除并返回数组的最后一个元素Array.push() 尾部给添加元素Array.shift() 头部移除Array.unshift() 头部插入Array.splice() 删除位置，长度Array.slice() 返回数组的一部分Array.reverse() 反转Array.sort() 排序 函数或箭头函数Array.toString() 转换为字符串Array.toLocaleString() 将数组 转换成局部字符串 JS中callee 和 caller的作用区别 caller :返回一个函数的引用 该函数调用了当前函数fn.caller() callee 返回正在被执行的function 函数 ，也就是指定的function对象的上下文 arguments.callee 在JS中什么是伪数组？如何将伪数组转化为数组 伪数组(类数组) 无法调用length，但可以通过for遍历，典型的函数是arguments 还有使用getElementsByTagName,document.childNodes 等返回的Nodeist都是伪数组 立即执行函数/闭包 12345678910setImmedFunc()&#123; (function test()&#123; var a,b=5; console.log(typeof a); console.log(typeof b); &#125;)(); console.log(typeof a); console.log(typeof b);&#125;// number number undefined number 运算符之间的操作 123456789101112131415161718192021222324var a;var b = a * 0; if (b == b) &#123; console.log(b * 2 + "2" - 0 + 4);&#125; else &#123; console.log(!b * 2 + "2" - 0 + 4);&#125;// 26---------------------------------------&lt;script&gt; var a = 1;&lt;/script&gt;&lt;script&gt; var a; var b = a * 0; if (b == b) &#123; //b=0 console.log(b * 2 + "2" - 0 + 4); &#125; else &#123; console.log(!b * 2 + "2" - 0 + 4); &#125; //6&lt;/script&gt; btn.addEvenetListener() 1234567var btn = document.getElementById('btn'); var handler = &#123; id: '_eventHandler', exec: function()&#123; alert(this.id); &#125;&#125;btn.addEventListener('click', handler.exec); 原型链继承 1234567891011121314151617var obj = &#123; proto: &#123;a:1,b:2&#125;&#125;; function F()&#123;&#125;;F.prototype = obj.proto;var f = new F(); obj.proto.c = 3;obj.proto = &#123;a:-1, b:-2&#125;;alert(f.a);//1alert(f.c);//3delete F.prototype['a'];alert(f.a);//undefinedalert(obj.proto.a);//-1添加属性会继承，父影响子，子不影响父 写出函数DateDemo()123456 function DateDemo()&#123; var d, s="今天日期是:"; d = new Date(); s += (d.getMonth() + 1) + "/"; s += d.getDate() + "/"; s += d.getFullYear(); return s;&#125;console.log(DateDemo()) HTML5 CSS3算法 农场买了一只羊，第一年是小羊，第二年底生一只，第三年不生，第四年底再生一只，第 五年死掉 写出代码对下列数组去重并从大到小排列 {5,2,3,6,8,6,5,4,7,1,9}先去重再排序 约瑟夫环 已知 n 个人(以编号 1，2，3…分别表示)围坐在一张圆桌周围。从编号为k的人开始报数，数到m的那个人出列;他的下一个人又从1开始报数，数到m的那个人又出列;依此规律重复下去，直到圆桌周围的人全部 出列 有 1 到 10w 这个 10w 个数，去除 2 个并打乱次序，如何找出那两个数? 请写一个正则表达式:要求最短 6 位数，最长 20 位，阿拉伯数和英文字 母(不区分大小写)组成^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])[a-zA-Z\d]{6,20}$ 统计 1 到 400 亿之间的自然数中含有多少个 1?比如 1-21 中，有1、10、11、12、13、14、15、16、17、18、19、20、21 这么多自然数有 13 个 1 删除与某个字符相邻且相同的字符，比如 fdaffdaaklfjklja 字符串处理之后成为“fdafdaklfjklja” 请写出一个程序，在页面加载完成后动态创建一个 form 表 单，并在里面添加一个 input 对象并给它任意赋值后义 post 方式 提交到:http://127.0.0.1/save.php 用 JavaScript 实现冒泡排序。数据为 23、45、18、37、92、13、24 Jquery $.ajax()常用的参数有哪些 用post请求并带有发送数据的和返回数据的样例 jQuery 的 slideUp 动画 ，如果目标元素是被外部事件驱动, 当鼠标快速地连续触发外部元素事件, 动画会滞后的反复执行， 该如何处理呢? JS高级JS流行框架移动开发Node.js前端概括性问题]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端基础1]]></title>
    <url>%2F2018%2F12%2F01%2F%E9%9D%A2%E8%AF%95%2FFrontPrevew%2F</url>
    <content type="text"><![CDATA[HTML/CSS 浏览器内核？ IE/Trident FireFox / gecko Chrome / webKit-&gt;Blink Safari / WebKit Opera / 之前是presto -&gt; Blink Doctype? 在标签之前 告知浏览器使用那种文档 Quirks 模式是什么？Standards模式区别 如果有条件采用CSS之后更好的模式，如果没有写，兼容之前的布局方式 区别 ：1234盒模型 / 标准下内容宽高；Quirks下IE的包括padding border设置行内元素宽高 / 标准下设置不会生效；quriks 下会设置宽高设置百分比的高度 / 标准下高度是内容决定的，如果父元素没有设置百分比高度，字元素设置百分比是无效的；quirks下设置生效margin：0 auto / 标准下可以元素居中，quirks下不能居中 div+css 布局和table布局有什么区别 改版方便 页面加载快 结构化清晰，页面显示简洁 表现与数据结构分离 易于优化，搜索引擎更友好。 img alt 和title的区别 strong和em的区别 alt 用在显示不出来图片的时候占位文字 title 是鼠标悬浮img时的说明文字 IE下当没有设置title会把alt作为title提示 strong 强调 加粗，重要性 en 斜体 强调 渐进增强/优雅降级 Progressive Enhancement针对低版本保证最基本功能，再适配低版本 进行效果交互能用户体验 Graceful Degradation 一开始完整功能，再针对低版本浏览器进行兼容 区别： 优雅降级往回看，向低版本兼容。渐进增强向前看，兼容最新的的功能。 为什么利用多个域名来存储网站资源会更有效 CDN 缓存更方便 突破浏览器并发限制 节约cookie带宽 节约主域名的连接数，优化页面相应速度 防止不必要的安全问题 网页标准和标准制定机构重要性的理解 Cookie SessionStorage LocalStorage 区别 SessionStorage session中的数据 这些数据 只有在同一个会话中的页面才能访问，并当会话结束随之销毁，会话级别的存储。 LocalStorage 持久化的本地存储 除非主动删除数据，否则永远不会过期 Cookie 大小受限制，并且每次请求新页面Cookie都会被发送过去，这样无形中浪费带宽，还需要制定作用域，不可以跨域。 WebStorage 是作为本地存储用的，有API setItem getItem removeItem clear 等。 Cookie 作用是与服务器进行交互，作为HTTP规范的一部分存在。 src 和 href 的区别 src source &lt;script&gt; 中指向的资源替换当前元素，会加载编译资源之后再向下进行 href 网络资源位置，和 配合使用，指向的一个地址，会并行加载，编译当前文档之后再编辑指向的资源位置 网页制作的图片格式 PNG-8/PNG-24/JPEG/GIF/SVG Webp 谷歌的图片格式，是JPEG的60%，节省空间和网络资源 微格式？ 是一种让机器可读的语义话词汇的集合，是结构化数据的开放标准，是特殊应用而制定的特殊格式。 优点：将只能数据添加到网页上，让网站内容再搜索引擎结果界面可以显示额外的提示， 从用户刷新网页开始，一次JS请求一般情况那些缓存？ DNS缓存 CDN缓存 浏览器缓存 服务器缓存 大型电商网站大量的图片，加载很慢，有哪些方法优化？ 能用font字体替代一些icon图片 使用精灵图 取代小而多的一类图片 图片懒加载，先加载显露出来的，上拉加载的时候再加载 如果有幻灯片，只加载第一张和后一张，点击之后再加载后面的 CSS图片，使用CSSsprite SVGsprite Iconfont Base64等技术 如果图片过大，使用特殊编码压缩图片 有限加载缩略图，再加载高清图片 所需小图，优先服务器压缩后的小图。 HTML结构的语义化 丢掉CSS样式后也能显示页面结构 有默认的CSS 搜索引擎注重语义标记 W3C 有标准，减少差异化东西，方便开发和维护，提高开发效率，实现模块开发 做好SEO考虑？ 合理标签的使用 Meta标签优化，title Description Keywords Author Category Language DOM 设置它的CSS样式 内部样式/内联样式/外部样式 | 标签内部/&lt;style&gt;标签内 / 引入的外部样式 CSS哪些选择器 派生选择器(标签选择器) 权重1 id选择器 ID权重100 类属性选择器 class权重10 属性选择器 ::hover 后代选择器 div .text .span 空格隔开 权重相加(1+10+10) 群组选择器 p,div,#a{} 或的关系，是多个目标一起设置 使一个元素不显示？ CSS里可以用哪些属性定义 display:none visibility:hidden 这只宽高为0 ; z-index:-100 ; 透明度设置为0 超链接访问过后hover样式就不出现了，问题？ 如何让解决？ LVHA(link;visted;hover;active) 什么是CSS Hack 针对不同的浏览器写不能的CSS 1234_background-color:white; /*ie6*/+background-color:white; /*ie7*/background-color:white\9;/*ie9*/background-color:white; /*剩下的就是IE8 */ rgba() 和opacity 的透明效果有什么不同？ | 元素内的所有的内容的透明度 CSS让文字在垂直和水平方向上的重叠的两个属性是什么？ 垂直方向line-height 水平方向letter-spacing letter-spacting 可以消除 inline-block的换行符空格间隙问题 垂直居中一个浮动元素 12345678910111213141516171819202122232425 /* 垂直居中一个浮动元素 方法一:已知元素的高宽 */.div1&#123; position: absolute; width: 100px; height: 100px; left: 50%; top: 50%; margin-left: -50px; margin-top: -50px;&#125; /* 垂直居中一个浮动元素 方法二:未知元素的高宽 */.div2&#123; position: absolute; top: 0px; bottom: 0px; left: 0px; bottom: 0px; &#125; /* 垂直居中一个&lt;img&gt;? */.imageContainer &#123; display: table-cell; text-align: center; vertical-align: middle;&#125; px 和 em的区别 px 是固定值，em值不是固定的，并且会继承父级元素的大小 浏览器的默认字体是16px = 1em . 12px = 0.75em 描述一个reset的CSS文件如何使用？ normalize.css? 不同之处？ 重置样式，恢复默认样式 不同的浏览器有不同的默认样式，先进行初始化统一样式 normalize.css 没有充值所有的样式，仅提供了一套合理的默认样式。 Sass Less 是什么？ 为什么使用？ 是CSS预处理 是CSS的一种抽象 是一种特殊的语法语言编译成CSS less是一种动态样式 变量继承运算函数等。 结构清晰，便于扩展; 可以封装对浏览器差异的重复处理; 轻松实现多继承; 完全兼容CSS代码向下兼容 dispaly:none 和 visibility:hidden的区别是什么？ display 隐藏空间不占位置 visibility 隐藏，保留空间位置 CSS的 和@import 的区别 link 是html标签;import 是CSS提供 页面加载时候，link 会异步同时加载，@import 引入的CSS会在页面加载完成才引入CSS @import只有在IE5之上才会被识别，link不存在浏览器兼容性问题 Link 优先级权重大于@import 盒子模型 content /padding/border/margin 为什么初始化样式？ 由于浏览器兼容问题，不同的浏览器对标签默认样式不同，会造成不同浏览器之间的差异化显示 但是初始化CSS会对搜索引擎优化造成小影响 BFC是什么？(块级格式化上下文) 一个创建了新的BFC盒子是独立布局的，盒子内元素的布局不会影响盒子外面的元素，在同一个BFC的两个相邻的盒子在垂直方向发生margin 重叠的问题 BFC是值浏览器中创建了一个独立的渲染区域，该区域所有的元素布局不会影响到区域外元素的布局，这个渲染区域只对块级元素起作用 IE的双边距bug，解决：加入dispaly:inline html常见的兼容性问题 双边距问题 使用dispaly 3像素问题 display:inline -3px 超链接hover点击失效 LVHA IE z-index 问题 父级 display:relative PNG透明 使用JS修改 Min-height最小高度 !important select 在ie6下遮盖 使用iframe 为什么没有办法定义1px的宽度问题 (IE6默认行高造成的， over:hidden;zoom:0.08;line-height:1px) IE5-8 不支持opacity 12345.opacity&#123;opacity: 0.4;filter: alpha(opacity = 60); /*IE5-7*/-ms-filter: "progid:DXImageTransform.Microsoft.Alpha(Opacity=60)"; /*IE8*/ &#125; IE6 不支持PNG透明背景 IE6 下使用Gif 图片 浏览器的内核分别是什么，经常遇到的浏览器兼容性哪些？原因，解决方法？常用hack技巧 PNG 24图片显示出现背景，做成PNG8 个浏览器不同的margin padding 加全局的*{padding,magging:0} IE6双边距的问题 display的值和各自的作用，position的值；relative absolute 定位原点是什么 block/inline-block/grid/table/table-cell absolute/relative/fixed/static/inherit inherit 规定从父元素继承position属性的值 absolute的containing block 计算方式跟正常流有什么区别 若此元素为inline元素 则containing block 为能都包含这个元素生成的第一个和最后一个inline box 的padding bxo position 和 display/ margin collapse /overflow / float 这些特性相互叠加会怎样？ JS基础 typeof 返回值是？ Object/number/function/boolen/undefine/string 举例3种强制转换 2种隐式转换 强制转换 perseInt Number() parseFloat 隐式转换 == ; 121 == '1' //truenull == undefine // true splite() 和 join() 的区别 | 字符串分割为数组 数组合并为字符串 pop() push() unshift() shift() | 尾部添加 微不删除 头部添加 头部删除 事件绑定和普通事件的区别？ 事件绑定 是把事件注册到具体的元素上；普通事件指的是可以用来注册的事件 div1.onclick如果给同一个元素绑定了两次或者多次相同的类型的事件,之前绑定的事件会被覆盖;不支持DOM事件流 IE9之后 addEventListener 绑定了多次，所有的都会触发 ；支持DOM事件流 ；绑定的函数名参数不带on IE9 之前是 attachEvent/detachEvent 这种方式只支持事件冒泡不支持事件捕获 IE和DOM 事件流的区别 执行顺序不一样/参数不一样/事件加不加on/this指向问题 IE9之前 attachEvent(‘onclick’,function(){}) IE9之后 addEventListener(‘click’,function(){}) IE和标准下有哪些兼容性写法123var ev = ev || window.eventdocument.documentElement.clienWidth || document.body.clientWidthvar target = ev.srcElement || ev.target call 和 apply 的区别 都是用了一个本不属于一个对象的方法，让这个对象去执行 toString.call([],1,2,3) toString.apply([],[1,2,3]) Object.call(this,obj1,obj2,obj3) Object.apply(this,arguments) call 参数传分散可以多个，apply 传一个参数的集合 B继承A的方法 构造函数继承;原型链继承;以上两种方式的组合 事件委托是什么？ 复合W3C标准的事件绑定，利用事件冒泡的原理，让自己所触发的事件，让他的父元素代替执行，delegate 闭包是什么，有什么特性，对页面有什么影响 闭包就是能够读取其他函数内部变量的函数，(匿名函数就是闭包?) 缺点：滥用闭包会引起内存泄漏，因为闭包引入的外部的变量都永远不会被释放，所有应该再必要的时候，释放这个闭包函数 如何阻止事件冒泡和默认事件 eve.stopPropagation || event.cancelBubble = true(IE9之前) 阻止默认事件：在点击事件内return false || eve.preventDefault 添加 删除 替换 插入某个节点的方法 eleme.appendChild(). //追加 eleme.removeChild()。// 删除 eleme.replaceChild() // 替换 eleme.insertBefore() // 在之前插入 原声JS不提供insertAfter() javascript的本地对象，内置对象 宿主对象 本地对象 Array Obj regep 等可以使用 new 实例化 内置对象为gload Math等不可以实例化的 宿主为浏览器自带的document window 等 document load 和 document ready 的区别 document.onload 是结构样式加载完成之后才执行 window.onload 是结构样式加载之后，还要执行完所有的样式 图片等资源文件全部加载完之后才会调用 window.onload ‘==’ 和 ‘===’ 的区别 == 会隐式转换 === 会先判断左右两边的数据类型 如果数据类型不一致直接return false ，之后才进行值的比较 javascript的同源策略 同一源:主机名 协议 端口号的组合。 麻烦：Ajax 不在0:http协议的默认端口；同域名下请求无法实现 可以通过jsonp 来解决 编写一个数组去重的方法 for循环判断 利用set去重特性 JS是一门什么样的语言，有哪些特点？ 面向对象/动态语言/ 运行环境在浏览器中运行 JS的数据类型？ 基本数据类型:String|Boolen|Number|undefine|Null|Object 引用数据类型:Array|Date|Function|RegExp 如何判断数据类型1234567891011121判断是否有数组的性质。splice() ；不能确定保证2instanceof 在某些低版本中不适用3isArray() 保证兼容性是最好的方法toString.call(18) // [object Number]toString.call('') // [object String]toString.call(/[0-9][10]/) // [object RegExp] if(typeof Array.isArray === 'undefine')&#123; Array.isArray = function(agr) &#123; return Object.prototype.toString.call(arg) === '[object Array]' &#125;&#125; 希望获取页面所有的checkbox怎么做 123456789var domlist = document.getElementsByTagName('input')var checkArr = []var len = domlist.lengthwhile效率会比for循环更高？while(len--)&#123; if(domlict[len].type === 'checkbox')&#123; checkArr.push(domlict[len]) &#125;&#125; 设置一个ID为‘ttt’ 的div 内容为’xxxxxx’,背景色为‘#234’ 123var divDom = document.getElementById('ttt')divDom.innerHtml = 'xxxxxxx'divDom.style.color = '#234' 点击一个DOM的时候，希望执行一个函数，如何做？ 1.直接在DOM里绑定事件 &lt;div onclik=&#39;test()&#39; &gt;&lt;/div&gt; 2.在JS里面绑定 divDom.onclick = test 3.通过事件添加绑定addEventListener(&#39;click&#39;,test) JS的事件流模型 事件冒泡 内而外 目标阶段 事件捕捉 外向里 undefined 会在以下三种情况下产生 变量定义了还没有被复制 想要获取一个对象不存在属性和方法 一个数组中没有被赋值的元素 typeof null 返回的是Object 类型转换的判断相等 1234567891011121314undefined == null // true1 == true // true0 == false // true0 == '' // trueNaN == Nan // false[] == false // true[] != ![] // true对于0 空字符串判断 建议用 === var foo = '11' + 2 - '1'console.log(foo)console.log(typeof foo)112 -1 = 111 类型是Number 引用类型指针拷贝 一个值修改，其他引用的值都做改变 已知有字符串 foo=”get-element-by-id”,写一个 function 将其转化成驼峰表示法” getElementById”。 | splice(‘-‘) ;charAt(0).toUpperCase() 输出今天的日期 以YYYY-MM-DD的方式 1234567891011var d = new Date();// 获取年，getFullYear()返回 4 位的数字var year = d.getFullYear();// 获取月，月份比较特殊，0 是 1 月，11 是 12 月var month = d.getMonth() + 1;// 变成两位month = month &lt; 10 ? '0' + month : month;// 获取日var day = d.getDate();day = day &lt; 10 ? '0' + day : day;alert(year + '-' + month + '-' + day); 将字符串”{$id}{$name}”中的{$id}替换 成 10，{$name}替换成 Tony (使用正则表达式) 1"&lt;tr&gt;&lt;td&gt;&#123;$id&#125;&lt;/td&gt;&lt;td&gt;&#123;$id&#125;_&#123;$name&#125;&lt;/td&gt;&lt;/tr&gt;".replace(/&#123;\$id&#125;/g, '10').replace(/&#123;\$name&#125;/g, 'Tony'); foo = foo || bar 是什么意思？ 短路表达式 swift 给默认值 变量声明提升 &gt; 函数声明与变量声明会被 JavaScript 引擎隐式地提升到当前作用域的顶部，但是只提升名 称不会提升赋值部分。 12345678910111213var foo = 1;function()&#123; console.log(foo); var foo = 2; console.log(foo);&#125;// 输出 undefine 和 2 代码相当于:var foo = 1;function()&#123; var foo; console.log(foo); //undefined foo = 2; console.log(foo); // 2;&#125; JS 实现随机选取10-100 的数据，存到一个数组，并排序 1234567891011// 用 js 实现随机选取 10–100 之间的 10 个数字，存入一个数组，并排序function random(start,end) &#123; var ichose = end - start + 1 return Math.floor(Math.random() * ichose + start)&#125;var iArry = []for (let i = 0; i &lt; 10; i++) &#123; var tem1 = random(10,100) iArry.push(tem1)&#125;iArry.sort() 把两个数组合并，并删除第二个元素。 12345// 把两个数组合并，并删除第二个元素。var arr1 = [1,2,3,4,5]var arr2 = [1,2,3,4,5]var arr3 = arr1.concat(arr2) // 合并之后返回一个新值arr3.splice(1,1) // 在原值的基础上做操作 怎样添加、移除、移动、复制、创建和查找节点(原生JS) 创建新节点 creatDocumentFragement | creatElement | creatTextNode 添加移除替换插入 appendChild() removeChild() replaceChild() inserBefor() 查找 getElementsByTagName() | getElementByName | getElementById() 从网址‘http://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e’取出参数返回一个json结构 1234567891011121314var urls = 'http://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e' var urlStr = urls.splice('?')[0] var mapS = urls.splice('?')[1].splice('&amp;') // 'a=1','b=2','c=','d=xxx','e=' var result = [] for (let i = 0; i &lt; mapS.length; i++) &#123; const aelement = array[i]; var akey = aelement.splice('=')[0] var avalue = aelement.splice('=')[1] var tempEle = &#123; akey:avalue &#125; result.push(tempEle) &#125; return result; 正则表达式构造函数 var reg = new RegExp(&#39;xxx&#39;) 与字面量var reg = // 有什么不同。匹配邮箱的正则表达式？ 当适用RegExp() 构造函数的时候，不仅需要转义引号(‘\’表示) 而且是需要双反斜杠‘\’使用正则表达式字面亮效率更高 1var regMail = /^[a-zA-Z0-9_-]+@([a-zA-Z0-9_-])+((.[a-zA-Z0-9_-]&#123;2,3&#125;)&#123;1,2&#125;)$/ js事件处理器在线程空闲之前不会运行？如何让让下面代码输出1，2，3 12345678910111213141516for (let i = 1; i &lt;= 3; i++) &#123; setTimeout(() =&gt; &#123; console.log(i) &#125;, 1000);&#125;// 加入异步队列是遍历的时候，执行异步队列的时候，是for循环结束之后再执行setTimeout `输出 3 3 3` // 如果要输出 1 2 3 需要修改成立即执行函数for (let i = 1; i &lt;= 3; i++) &#123; // setTimeout(() =&gt; &#123; // console.log(i) // &#125;, 1000); setTimeout((function (a) &#123; console.log(a) &#125;)(i),0);&#125; 写一个函数，清除字符串前后的空格 trim() 12345678910function trimString()&#123; if (!String.prototype.trim) &#123; String.prototype.trim = function ()&#123; return this.replace(/^\s+/,'').replace(/\s+$/,'') &#125; //\s 匹配空白字符:回车、换行、制表符 tab 空格 &#125;&#125;var testfunc = '\t djhfg djkf d 'console.log(testfunc.trim()) js中的callee 和caller的区别 斐波那契数列 生兔子 caller 返回了一个函数的调用，该函数调用了当前函数 calle 是返回正在被执行的function 函数，也就是指定的function 对象的正文 1234567891011121314151617181920// caller calee 的区别 function test3()&#123; //典型的斐波那契数列 var result=[]; function fn(n)&#123; if(n==1)&#123; return 1; &#125;else if(n==2)&#123; return 1; &#125;else&#123; if(result[n])&#123; return result[n]; &#125;else&#123; //argument.callee()表示 fn() result[n]=arguments.callee(n-1)+arguments.callee(n-2) return result[n]; &#125; &#125; &#125; &#125; JS的一个 ++a和a++ 123456789 function test4()&#123; var a=10, b=20 , c=30; ++a; // a:11 a++; // a:12 e=++a+(++b)+(c++)+a++; // a:13 + 21 + 30 + 13 = 77 // 结束之后 a:14 alert(e);&#125; 写一个函数，返回今天的日期 12345678 function test5()&#123; var d, s="今天日期是:"; d = new Date(); s += d.getMonth() + "/"; //(month:0-11 +1?) s += d.getDate() + "/"; s += d.getFullYear(); return s;&#125; 数组reverse()运用 reverse 方法颠倒数组中元素的位置，并返回该数组的引用 1234567function test6()&#123; var arr1 = [1,3,5] // 0,1,2 arr1[4]= 'z' // arr1: [1,3,5,undefine,'z'] var arr2 = arr1.reverse() // arr2:['z',undefine,5,3,1] arr1:['z',undefine,5,3,1] var arr3 = arr1.concat(arr2) console.log(arr3) // arr3 ['z',,5,3,1,'z',,5,3,1]&#125; 补充按钮事件的函数，确认用户是否退出当前页面，确认之后关闭窗口： 123456789&lt;input type="button" value="关闭窗口" onclick="closeWin()" /&gt;&lt;script type="text/javascript"&gt;function closeWin()&#123; if(confirm("确认要退出吗"))&#123; window.close() &#125;&#125;&lt;/script&gt; 写出简单描述 html 标签(不带属性的开始标签和结束标签)的正则表达式 / 并将以下字符串中的 html 标签去除掉 123var str = “&lt;div&gt;这里是 div&lt;p&gt;里面的段落&lt;/p&gt;&lt;/div&gt;”;var reg = /&lt;\/?\w+\/?&gt;/gistr.replace(reg,''); 根据下拉列表的选项变化，更新图片的显示 123456789101112131415&lt;body&gt; &lt;img id="pic" src="img.jpg" width="200" height="200"&gt; &lt;select id='sel'&gt; &lt;option value="img1"&gt;xxxx&lt;/option&gt; &lt;option value="img2"&gt;xxxx&lt;/option&gt; &lt;option value="img3"&gt;xxx&lt;/option&gt; &lt;option value="img4"&gt;xxx&lt;/option&gt; &lt;/select&gt;&lt;body/&gt;&lt;script&gt; function showImg(oSel)&#123; var str = oSle.value document.getElementById("pic").src = str + '.jpg' &#125;&lt;/script&gt; BOM 常用的4个对象 并列举window对象的常用方法至少5个？ window document location screen history navigator Alert() confirm() prompt() open() close() JS 如何实现继承 原型链继承 借用构造函数继承 组合继承 寄生式继承 寄生组合继承 JS对象创建的几种方式 工厂模式 构造函数模式 原型模式 混合构造函数原型模式 动态原型方式 iframe的优缺点 优点：解决加载缓慢的第三方内容图标和广告等的加载问题 Security sandBox 并行加载脚本 缺点：iframe会阻塞主页面的unload事件 | 即时内容为空，加载也需要时间 | 没有语义 Cookie 的弊端 长度限制 每个doming 最多20条cookie ；每个cookie 长度不能超过4K 安全性 有可能被拦截，原样转发cookie 就可以达到目的 有些状态不可能保留在客户端，需要计算的属性存储在服务器端 JS延迟加载的方式有哪些 defer/async 区别？ 动态加载DOM方式(创建script，插入到DOM中，加载完毕后callBack) 按需异步加载JS 哪些操作会造成内存泄漏 内存泄漏是对象释放后，内存地址还是占用着 垃圾回收机制，引用计数为0的时候，]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试基本分析1]]></title>
    <url>%2F2018%2F12%2F01%2F%E9%9D%A2%E8%AF%95%2Fpreview%2F</url>
    <content type="text"><![CDATA[流程 模拟一面 面试技巧 页面布局类 CSS盒模型 DOM事件类 HTTP协议类 原型链类 面向对象类 通信类 前端安全类 前端算法类 模拟二面 面试技巧 渲染机制类 JS运行机制类 页面性能 错误监控 模拟三面 面试技巧 业务能力 团队协作能力 带人能力 模拟终面 面试技巧 职业竞争力 职业规划 公司招聘 职位描述分析 京东 负责PC端和移动端相关的前端开发工作 负责APP H5 开发，完成界面和后端交互开发 与后端工程师协作 调试数据接口 负责前端组件库的建立 负责对现有系统的优化与重构 精通HTML5 特性，了解最新的HTML5最新规范，能用HTML5特性构建移动WebAPP 熟悉当前流行的JavaScript 类库，熟悉 JavaScript面向对象编程方法 熟悉Web标准 对表现与数据分离 HTML 至少熟悉一种前端MVC框架 并有实战经验 具有前端架构分析与设计能力，习惯于OOP开发方式 熟悉Web前沿技术和新技术调研 了解CSS预编译语言 sass less等 熟悉web构建工具 Grunt Glub 能够自己搭建前端构建环境 有服务端开发者经验者优先 查看公司网站 所包含技术点 &lt;meta&gt; 标签 &lt;link&gt; dns-prefetch 图片/静态资源预解析 &lt;script&gt; async src 异步加载Js文件 Font 字体文件 前端技术栈 jQuery Vue React Node.js Anguarl Sass less Grunt Gulp npm webpack browserify 简历阶段 概况 描述 简洁明了 技能 专业技能，技能点全面 5-10条 经历 公司 - 项目 - 技能点 - 所做贡献 - 成长收获 一面 页面布局 请写出三栏布局 两边宽度100px 中间自适应 5种解决方案： (浮动/绝对定位/table/flex/grid) 各自优缺点 三栏 上中下如何布局 两栏 上下，左右如何布局（固定一个部分） Html标签语义化，页面布局，CSS基础，思维灵活多找哪个解决方案，代码规范 CSS盒模型 DOM事件 HTTP协议 面向对象 原型链 通信 安全 算法 三栏布局技术实现 1.浮动 左右浮动固定宽度，中间自适应 缺点：高度不固定会溢出边界 2.绝对定位 左中右三个模块都绝对定位，中间这只距左右的距离 。自适应 3.flexBox布局 设置父试图 display:flex .左右设置固定宽度 中间设置flex:1 4.表格布局 父控件100% display:table .左中右子空间设置dispaly:table-cell ；之后左右设置固定宽度。中间自适应拉伸 5.grid布局 父识图设置100%； display:grid; grid-template-rows:100px;grid-template-columns:300px auto 300px CSS盒模型 基本概念 标准模型| IE模型 ；区别：宽度计算 1IE模型 width = contentW + paddding + boder CSS如何设置两种模型 1box-sizing:content-box | border-box; JS如何获取盒模型对应的宽和高 12345678dom.style.width/height //只取行间样式设置 可以set设置dom.currentStyle.width/height //ALl可取 IE下 未设置取默认值dom.getComputedStyle(dom).width/height // All可取dom.getBoundingClientRect().widht/heightdom.getComputedStyle是一个可以获取当前元素所有最终使用的CSS属性值。`var style = window.getComputedStyle("元素", "伪类");``getBoundingClientRect`用于获得页面中某个元素的左，上，右和下分别相对浏览器视窗的位置 可以用来判断是否在屏幕上显示 根据盒模型解释边距重叠 垂直边距 正正/负负值 取绝对值大的(20,10) =&gt; 20 一正一负取两个值的绝对值相加(20,-10) =&gt; 30 BFC解决方案 123设置父试图的overflow:overflow:hidden | autoBFC 内子元素即使是float 也会参与高度计算 DOM 事件类 12345- DOM事件模型- DOM事件流- 描述DOM事件捕获的具体流程- Event对象的常见应用- 自定义事件 DOM 事件模型 123DOM0 element.onclick=function()&#123;&#125;DOM2 element.addEventListener('click',function()&#123;&#125;)DOM3 element.addeventListener('keyup',function()&#123;&#125;) DOM事件流 分三个阶段：捕获阶段，目标阶段，事件冒泡阶段 事件冒泡：点击了一个button 向所有的父级一层一层上去传递，为事件冒泡 事件捕获：发生和冒泡顺序相反，window -&gt; doucument -&gt; body -&gt; sectionOne -&gt; button window点击事件更改为使用事件捕获模式。(addEventListener最后一个参数，为true则代表使用事件捕获模式，false则表示使用事件冒泡模式。 123 window.addEventListener('click', function() &#123; console.log('4. You click window');&#125;, true); 事件冒泡阶段是可以被阻止的：stopPropagation 123456 button.addEventListener('click', function(event) &#123; // event为事件对象 console.log('1. You click Button'); event.stopPropagation(); console.log('Stop Propagation!');&#125;, false); Event对象常见的应用 12345event.preventDefault() // 阻止事件的默认动作event.stopPropagation() // 阻止冒泡 阻止后续的监听event.stopImmediatePropagation() // 阻止冒泡 包括本身event.currentTarget // 监听事件者event.target // 事件的真正发出者 自定义事件 new Event(‘eventName’) abutton.addEventListener(‘’,function(){}) abuton.dispatchEvent(aevent) 12345var eve = new Event('aeventName')adiv.addEventListener('aeventName',function()&#123; console.log('test cuntomerEvent')&#125;)adiv.dispatchEvent(eve) HTTP协议类 特点：简单快速|灵活|无连接|无状态 报文的组成部分 (请求行 请求头 空行 请求体) | (状态行 相应头 空行 响应体) HTTP方法 ： GET获取资源/POST传输资源/PUT更新资源/DELETE删除资源/HEAD获得报文首部 GET/POST的区别 回退 get返回不刷新界面 / post会重新请求 URL收藏 get可以被收藏 / post不可以 主动缓存 get可以被缓存 / post要主动手动设置缓存 编码 get 只支持URL编码 / post支持多种 浏览记录参数 get完整保留 / post参数不会被保留 长度限制 get参数长度是限制的 / post没有限制 参数数据类型 get只接受ASCII字符 / post无限制 安全性 get不安全参数暴露 不能传递敏感信息 参数位置 get参数在URL / post在body里 HTTP状态码 1XX：指示信息 - 表示请求已接收，继续处理 2XX：成功 - 表示请求已被成功接收 3XX：重定向 - 要完成请求必须进行更近一步的操作 4XX：客户端错误 - 请求右语法错误或请求无法实现 5XX：服务器错误 - 服务器未能实现合法的请求 持久链接 Keep-Alive。 HTTP协议采用请求-应答模式，普通模式每个应答 客户端和服务器都要新建一个链接，完成之后立即断开链接 实用Keep-Alive模式时 客户端-服务端的连接持续有效，当有对服务器其他请求，避免新建或重新建立连接 管线化 管线化机制是通过持久化连接完成，仅Http 1.1 支持 只有GET/HEAD请求可以进行管线化，POST有所限制 初次建立连接不启动管线机制，因为服务器不一定支持http1.1的协议 管线化不影响应到来的顺序，请求1，请求2，请求3，响应1，响应2，响应3 Http1.1 要求服务器支持管线化，不是要求服务器端对相应进行管线化的处理，只是要求 管线化的请求 不处理失败。就是支持处理管线化的请求，不要求对相应消息管线化 开启管线化可能并不会带来大幅度的性能提升，而且很多服务器和代理程序对管线化支持并不好，因此Chrome/Firefox 默认不开启管线化支持 原型链 原型 构造函数 实例 原型链 的关系 instanceof 的原理 new运算符原理 代码类似如下 类的声明-实例 | 类的继承(如何实现，继承的几种方式) 借助构造函数实现继承 12345678910111213function Parent1()&#123; this.name = 'parent1'&#125;Parent1.prototype.say = function () &#123; console.log('test say')&#125;function Child1()&#123; Parent1.call(this); // apply this.type = 'child1'&#125;问题：只继承了父类的属性，没有继承父类的原型属性和方法 2:借助原型链实现继承 12345678function Parent2()&#123; this.name = 'parent2'&#125;function Child2()&#123; this.type = 'child2'&#125;Child2.prototype = Parent2.prototype缺点：继承了原型，但是实例属性没有继承 3:(1/2)组合方式 123456789function Parent3()&#123; this.name = 'parent3'&#125;function Child3()&#123; Parent3.call(this) this.type = 'child3'&#125; Child3.prototype = Parent3.prototype构造器是父类的构造器 4组合方式优化： 123456789function Parent4()&#123; this.name = 'parent4'&#125;function Child4()&#123; Parent3.call(this) this.type = 'child4'&#125; Child4.prototype = Object.create(Parent4.prototype)Child4.prototype.constructor = Child4 同源策略及限制 前后端如何通信 同源策略限制从一个源加载的文档或脚本如何与另一个源的资源进行交互；是用于隔离潜在恶意文件中国呢的关键的安全机制 Cookie LocalStorage IndexDB无法读取；DOM无法获得；AJAX请求不能发送 通过：Ajax;WebScoket;CORS; 如何创建Ajax XMLHttpRequest 对象的工作流程 兼容性处理 事件的触发条件 事件的触发顺序 跨域通信的几种方式 jsonp hash postmessage webScoket CORS 安全类 CSRF 跨站请求伪造 cross-site-request-forgery 引诱点击 XSS 跨域脚本攻击 cross-site-scripting (攻击原理 防御措施) CSRF的防御措施 Token验证| Referer 验证 | 隐藏令牌 算法类 排序(快速排序/选择排序/希尔排序) 堆栈/队列/链表 递归 波兰式和逆波兰式 渲染机制/运行机制/页面性能/错误监控 渲染机制 DOCTYPE-&gt;浏览器渲染过程-&gt;重排Reflow-&gt;重绘Repaint-&gt;布局Layout JS运行机制 单线程 / 任务队列 / EventLoop 打印A，死循环不会输出B，单线程 编译主文档之后才会走异步队列 输入4 个 4 JS异步任务 setTimeout 和 setInterval | DOM事件 | ES6的Promise 理解哪些语句会放入异步任务队列 理解语句放入异步任务队列的时机 页面性能类 提升性能的 方法有哪些 资源压缩合并 减少HTT请求 非核心资源异步加载|异步加载的方式 | 异步加载的区别 使用CDN 预解析DNS 异步加载的方式： 动态脚本加载|defer| async defer会在HTML解析完成之后才会执行 如果多个按加载的顺序执行 async 加载完成之后立即执行 如果是多个执行顺序和加载顺序无关。加载完成时间 看async的资源多少 缓存的分类 强缓存|协商缓存 强缓存 (Expiree Cache-Control) 协商缓存(Last-modified if-Moldified-Since Etag if-None-Match) 错误监控类(错误的分类|错误的捕获方式|上报错误的基本原理) 错误的分类分两种：即时运行错误代码错误 资源加载错误 运行错误的捕获方式：try catch | window.onerror 资源加载错误的捕获方式object.onerror | peformance.getEntries() | Error时间捕获 跨域JS运行错误的捕获处理? 错误信息Script error 处理：1.在script标签中增加crossorigin 2设置JS资源响应头Access-Control-Allow-Origin 上报错误的基本原理：采用Ajax通信的方式上报 2采用Image 对象上报 其他总结： 业务能力 团对协作能力 事务推动能力 待人能力 其他能力]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转-读书笔记---你不知道的JavaScript(上).md]]></title>
    <url>%2F2018%2F12%2F01%2F%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0---%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript(%E4%B8%8A)%2F</url>
    <content type="text"><![CDATA[Q&amp;A 1.问:为什么要写这么长,有必要吗?是不是脑子秀逗了?答:我想这是大部分人看到这个标题都会问的问题.因为作为一个男人,我喜欢长一点,也不喜欢分割成几个部分.一家人就要在一起,整整齐齐.好吧,正经点,其实整篇前言可以说都是在回答这个问题.你可以选择先看完前言,再决定要不要和书本搭配起来阅读. 这里先简单捋一下:1,内容多:首先这篇读书笔记本来内容就很多,是对书本的全方位详解.2,针对新人:针对那种红宝书草草读过一遍,对js只浮于接口调用的新手.3,留给读者自己提炼:读这种社科类书籍一般是先读厚,再读薄.这篇笔记就属于最开始’读厚’的阶段.在读者彻底读懂后,再自己进一步提炼.关于怎么读书,我后面会详细介绍. 2.问:这么长,那到底包含了些什么内容?答:笔记的目录结构和书本的完全一致.对每一节的内容进行更通俗的解读(针对新人),对示例进行更深的说明,有的会辅以流程图,并提供对应的mdn连接;对内容进行归纳,小节脉络更清晰;添加了大量实际工作时的注意事项,增加了更加清晰和易懂的示例及注释,并在原文基础上进行了拓展和总结;对书中的错误和说了后面会进行介绍,而没有介绍的填坑,翻译或者容易引起误会的称呼的说明;添加了个人读书时的感受和吐槽. 3.问:书已经够多了,还要看你这么长的笔记?答:首先你要知道读这种技术类书籍,不是读小说!读完并不意味着你读懂了.而是需要将书中的知识转换成你自己的.这篇笔记就是,帮助新手更方便地理解知识点,更流畅地进行阅读.也可以在读完一节后,通过对比,发现自己有什么知识点是不懂或者遗漏,理解有误的. 并且一些注意事项,容易被误导的,关于书中观点的吐槽等等,其实想说的都已经写在笔记里了. 4.问:这本书到底怎么样,有没有其他人说的那么好?答:这是一个先扬后抑的回答.首先毫无疑问这是一本非常不错的书!它系统地全面地对JavaScript进行解读,优点缺点全都有.当你彻底读懂这本书后,你对JavaScript的几乎所有疑问都会得到解答(我对作用域是不是”对象”的疑问?也得到了解答).但它也是有一定门槛的,如果你对JS不熟,常用接口都不熟,很多名词的表层意思都不太理解.这本书并不适合你,你花在问谷歌娘的时间可能比你读书的都长,读起来也是一知半解;不同于其他书,这本书很多时候没有给出明确的概念定义,需要你自己反复阅读理解他的话.每一小节的脉络结构也不是那么清晰,有时候需要自己去梳理;不知道是不是翻译的锅,很多东西解释得有点迷,本来很简单,但却说一堆并不常用的术语(可能国内不是这么叫的),看得你一脸懵逼!有时候同一个概念,前后会出现三四个不同的名词进行指代,没有任何说明;整本书,具有很强的作者主观情感在里面.前半段,把JS捧得很高,说它引擎的各种优化好!但到后半段关于JavaScript中模拟类和继承”的批评,说它们具有很大误导性!更是嗤之以鼻!就差爆粗口了,好像JavaScript就是一个异教徒,应该绑在十字架上被烧死!但是他这样的观点,都是站在其他类语言的角度来看待,产生的.我想更多的读者可能是只接触过JavaScript这一种语言,对他们来说,其实是根本没有这些”疑惑”的! 读书建议: 1.不要抱任何功利和浮躁的心来读书!这种以理论,概念为主的书,其实大家都是不那么愿意读的.一是读起来很费劲,抽象.二是实际工作,几乎不会用到,在现在浮躁的前端圈这是吃力不讨好.那这本书最大的用处是什么?没错,就是被很多人用来应付面试!? 这本身没什么问题,你读懂系列三本书,所有涉及JS的面试都能轻松应对.但是当抱着功利心时,你更多的则是敷衍.对书中的概念进行机械的复制,再粘贴上自己肤浅的理解.OK,应付那些也是跟风的面试官足够了.一般你回答了,他们也不会继续往下问,问深了自己也不清楚,也不好否定你.如果你够自信,’瞎扯’也可以唬住.如果你答不上,脸皮厚的会让你回去自己查.真正知道的面试官,其实都是会给你解释的,他们也不会忙到差这点时间.其实他们心里也是很乐意展示自己学识丰富的一面.这种功利读书方式,即使你读完了(更多人是半途而废),对你的技术也不会有任何帮助.因为读完,你其实是一知半解的.这样反而更糟,甚至可能会对你之前JavaScript正确的理解产生混淆. 2.认认真真读完一本书好过收藏一百篇相关文章(其实你压根连一半都不会看)! 我一直认为想系统弄懂一门知识,书本才是最好的选择,它绝对比你东拼西凑找来的一堆文章要好得多!现在前端圈随便看看,一大堆全是原型链,闭包,this…这些内容.里面的内容大同小异,很多理解也是比较浅显,考虑的也比较片面.但浮躁的人就是喜欢这种文章,觉得自己收藏了,看了就彻底理解了(!?).其实这些文章里有很多都是借鉴了本书. 首先,你必须知道知识都是有体系的,不是完全独立的.例如想要彻底理解,原型链,闭包,this.就必须先弄清作用域和函数.知识都是环环相扣,相互关联的.如果你想彻底弄懂,还是选择读书吧,由浅入深,全面理清所有知识点的关联.记住 “一知半解”永远比”无知”更糟!(当然不懂装懂,还振振有词的人另当别论). 3.如何读书:先读厚,再读薄!首先先把书读厚: 将每一节里的所有知识点弄懂,不留遗漏.记下所有提到的知识点,并将重要的知识点高亮标识(电子书的话).然后在自己本地的MD笔记里,按照一定的逻辑顺序,尽量用自己的话语进行阐述总结这些知识点.如果有读几遍也不理解的地方,可以查询MDN,结合自己的实际工作经验,或者先圈起来,继续往下读,随着后面理解的深入,前面不懂的地方自然也就明了了.这篇读书笔记就是带你怎么把书读厚.然后把书读薄: 这部分需读者你自己在彻底理解的基础上,并站在全局的角度进行归纳去总结.先是按章进行思维导图式的总结.然后章与章之间进行规律总结,并记住特例.例如:作用域与原型链都有一个类似的”就近原则”,由于就近原则所以就产生了”屏蔽”.这些都是需要自己站在全局融会贯通的角度去总结.虽然网上有别人总结好的,但我们不应该养成什么都依赖别人,自己直接复制的习惯(如果你想一直做一个’复制粘贴’程序员的话). 第一部分 作用域和闭包链接：https://juejin.im/post/5bfaa2e26fb9a04a0440b0e4来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 第一章 作用域是什么1.1 编译原理传统编译的三个步骤 1,分词/词法分析(Tokenizing/Lexing) : 这个过程会将由字符组成的字符串分解成(对编程语言来说)有意义的代码块，这些代码块被称为词法单元(token)。例如，考虑程序var a = 2;。这段程序通常会被分解成 为下面这些词法单元:var、a、=、2、;。空格是否会被当作词法单元，取决于空格在 这门语言中是否具有意义。 2,解析/语法分析(Parsing): 这个过程是将词法单元流(数组)转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”(Abstract Syntax Tree，AST)。var a = 2; 的抽象语法树中可能会有一个叫作 VariableDeclaration 的顶级节点，接下来是一个叫作Identifier(它的值是a)的子节点，以及一个叫作 AssignmentExpression 的子节点。AssignmentExpression 节点有一个叫作 NumericLiteral(它的值是 2)的子节点。 3,代码生成: 将 AST 转换为可执行代码的过程称被称为代码生成。这个过程与语言、目标平台等息息相关。抛开具体细节，简单来说就是有某种方法可以将 var a = 2; 的 AST 转化为一组机器指令，用来创建一个叫作 a 的变量(包括分配内存等)，并将一个值储存在 a 中。 说明: 此处只需记住第一步:分词/词法分析.第二步:解析/语法分析,得到抽象语法树(AST).第三步:代码生成,将抽象语法树转换为机器指令. JavaScript与传统编译的不同点: 1,JavaScript 引擎不会有大量的(像其他语言编译器那么多的)时间用来进行优化. 2,JavaScript与传统的编译语言不同，它不是在构建之前提前编译的，大部分情况下,它是在代码执行前的几微秒(甚至更短)进行编译. 3,JavaScript 引擎用尽了各种办法(比如 JIT，可以延 迟编译甚至实施重编译)来保证性能最佳。 4,JavaScript的编译结果不能在分布式系统中进行移植。 1.2 理解作用域1.2.1 演员表(代码编译到执行的参与者)首先介绍将要参与到对程序 var a = 2; 进行处理的过程中的演员们，这样才能理解接下来将要听到的对话。 引擎从头到尾负责整个 JavaScript 程序的编译及执行过程。 编译器引擎的好朋友之一，负责语法分析及代码生成等脏活累活(详见前一节的内容)。 作用域引擎的另一位好朋友，负责收集并维护由所有声明的标识符(变量)组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。1.2.2 对话(代码编译执行过程) 1.2.3 作用域的LHS查询和RHS查询由上图可知,引擎在获得编译器给的代码后,还会对作用域进行询问变量. 现在将例子改为var a = b;此时引擎会对变量a和变量b都向作用域进行查询.查询分为两种:LHS和RHS.其中L代表左.R代表右.即对变量a进行LHS查询.对变量b进行RHS查询. 单单从表象上看.LHS就是作用域对=左边变量的查询.RHS就是作用域对=右边变量的查询.但实际上并不是这么简单,首先LHS和RHS都是对变量进行查询,这也是我为什么要将例子从var a=2;改为var a=b;两者的区别是两者最终要查询到的东西并不一致.LHS是要查询到变量的声明(而不是变量的值),从而后面可以为其赋值.RHS是要查询到变量最终的值.还有一点,LHS 和 RHS 的含义是“赋值操作的左侧或右侧”并不一定意味着就是“= 赋值操作符的左侧或右侧”。赋值操作还有其他几种形式，因此在概念上最 好将其理解为“赋值操作的目标是谁(LHS)”以及“谁是赋值操作的源头(RHS)”.或者这样理解如果这段代码需要得到该变量的’源值’,则会进行RHS查询. 1.2.4 引擎和作用域的对话这部分比较简单就是通过拟人方式比喻引擎和作用域的合作过程.一句话概括就是,引擎进行LHS和RHS查询时都会找作用域要.1234function foo(a) &#123; console.log( a ); // 2&#125;foo( 2 ); 让我们把上面这段代码的处理过程想象成一段对话，这段对话可能是下面这样的。 引擎:我说作用域，我需要为 foo 进行 RHS 引用。你见过它吗?作用域:别说，我还真见过，编译器那小子刚刚声明了它。它是一个函数，给你。引擎:哥们太够意思了!好吧，我来执行一下 foo。引擎:作用域，还有个事儿。我需要为 a 进行 LHS 引用，这个你见过吗?作用域:这个也见过，编译器最近把它声名为 foo 的一个形式参数了，拿去吧。引擎:大恩不言谢，你总是这么棒。现在我要把 2 赋值给 a。引擎:哥们，不好意思又来打扰你。我要为 console 进行 RHS 引用，你见过它吗?作用域:咱俩谁跟谁啊，再说我就是干这个。这个我也有，console 是个内置对象。 给你。引擎:么么哒。我得看看这里面是不是有 log(..)。太好了，找到了，是一个函数。引擎:哥们，能帮我再找一下对 a 的 RHS 引用吗?虽然我记得它，但想再确认一次。作用域:放心吧，这个变量没有变动过，拿走，不谢。引擎:真棒。我来把 a 的值，也就是 2，传递进 log(..)。 1.3作用域嵌套当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。进而形成了一条作用域链.因此，在当前作用 域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量， 或抵达最外层的作用域(也就是全局作用域)为止。 当引擎需要对作用域进行查询时.引擎会从当前的执行作用域开始查找变量，如果找不到， 就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都 会停止。 1.4 异常例子:12345function foo(a) &#123; console.log( a + b ); b = a;&#125;foo( 2 ); 如果 RHS 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 ReferenceError 异常。例如上面例子中console.log(a+b)由于RHS此时是找不到b的值.故会抛出ReferenceError. 如果 RHS 查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作， 比如试图对一个非函数类型的值进行函数调用，或着引用 null 或 undefined 类型的值中的 属性，那么引擎会抛出另外一种类型的异常，叫作 TypeError。 当引擎执行 LHS 查询时，如果在顶层(全局作用域)中也无法找到目标变量，全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎，前提是程序运行在非 “严格模式”下。例如上面例子中的b=a;. 在严格模式中 LHS 查询失败时，并不会创建并返回一个全局变量，引擎会抛出同 RHS 查询 失败时类似的 ReferenceError 异常。 1.5 LHS与RHS小结 LHS和RHS查询都是引擎对作用域的查询 LHS和RHS查询都是只对变量进行查询 LHS和RHS都会沿着作用域链进行查询,直到最上层的全局作用域.如果没找到的话,在非严格模式下,LHS则会在全局创建一个相同名称的变量.RHS则会抛出ReferenceError的异常. 如果查找的目的是对变量进行赋值，那么就会使用 LHS 查询;如果目的是获取变量的值，就会使用 RHS 查询。 LHS只是找到变量的容器而已,方便进行赋值 =操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。此时都会进行LHS查询 RHS查询则需要找到变量的值. 第二章 词法作用域作用域分为两种工作模式: 1,词法作用域.是目前最为普遍的，被大多数编程语言所采用的模式.当然JavaScript也是使用的词法作用域. 2,动态作用域.使用较少,比如 Bash 脚本、Perl 中的一些模式等. 2.1 词法阶段词法阶段: 大部分标准语言编译器的第一个工作阶段叫作词法化(也叫单词化)。词法化的过程会对源代码中的字符进行检查，如果是有状态的解析过程，还会赋予单词语义。 词法作用域: 词法作用域就是定义在词法阶段的作用域也被称为静态作用域。即在JavaScript里作用域的产生是在编译器出来的第一阶段词法阶段产生的,并且是你在书写完代码时就已经确定了的. 词法作用域位置: 词法作用域位置范围完全由写代码期间函数所声明的位置来决定. 理解词法作用域及嵌套:看下例子:12345678910function foo(a) &#123; var b = a * 2; function bar(c) &#123; console.log( a, b, c ); &#125; bar( b * 3 ); &#125;foo( 2 ); // 2, 4, 12 在这个例子中有三个逐级嵌套的作用域。为了帮助理解，可以将它们分成3个逐级包含的”气泡作用域”。 1:包含着整个全局作用域，其中只有一个标识符:foo。 2:包含着 foo 所创建的作用域，其中有三个标识符:a、bar 和 b。 3:包含着 bar 所创建的作用域，其中只有一个标识符:c。 注意: 没有任何函数的气泡可以(部分地)同时出现在两个外部作用域的气泡中，就如同没有任何函数可以部分地同时出现在两个父级函数中一样。 引擎对作用域的查找:这一部分在上一节中已经说过,就是从当前作用域逐级向上,直到最上层的全局作用域.这里再进一步进行讲解.作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，这叫作“遮蔽效应”(内部的标识符“遮蔽”了外部的标识符)。抛开遮蔽效应， 作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止。 注意: 全局变量会自动成为全局对象(比如浏览器中的 window对象)的属性，因此可以不直接通过全局对象的词法名称，而是间接地通过对全局对象属性的引 用来对其进行访问。例如:window.a 通过这种技术可以访问那些被同名变量所遮蔽的全局变量。但非全局的变量如果被遮蔽了，无论如何都无法被访问到。 词法作用域查找只会查找一级标识符，比如 a、b 和 c。如果代码中引用了 foo.bar.baz，词法作用域查找只会试图查找 foo 标识符，找到这个变量后，对象属性访问规则会分别接管对 bar 和 baz 属性的访问。 2.2 欺骗词法欺骗词法: 引擎在运行时来“修改”(也可以说欺骗)词法作用域.或者说就是在引擎运行时动态地修改词法作用域(本来在编译词法化就已经确定的). 欺骗词法的两种机制:(下面这两种机制理解了解即可,不推荐实际开发使用) 2.2.1 evalJavaScript 中的 eval(..) 函数可以接受一个字符串为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码。即将eval放在该词法作用域,然后eval携带的代码就会动态加入到该词法作用域. 通过下面的例子加深理解:123456function foo(str, a) &#123; eval( str ); // 欺骗! console.log( a, b );&#125;var b = 2;foo( "var b = 3;", 1 ); // 1, 3 eval(..) 调用中的 “var b = 3;” 这段代码会被当作本来就在那里一样来处理。由于那段代码声明了一个新的变量 b，因此它对已经存在的 foo(..) 的词法作用域进行了修改。当 console.log(..) 被执行时，会在 foo(..) 的内部同时找到 a 和 b，但是永远也无法找到外部的 b。因此会输出“1, 3”而不是正常情况下会输出的“1, 2”。 注意: eval(..) 通常被用来执行动态创建的代码.可以据程序逻辑动态地将变量和函数以字符形式拼接在一起之后传递进去。 在严格模式下,eval(…)无法修改所在的作用域。 与eval(…)类似,setTimeout(..)和 setInterval(..) 的第一个参数可以是字符串，字符串的内容可以被解释为一段动态生成的函数代码。 new Function(..) 函数的行为也很类似，最后一个参数可以接受代码字符串，并将其转化为动态生成的函数(前面的参数是这个新生成的函数的形参)。这种构建函数的语法比 eval(..) 略微安全一些，但也要尽量避免使用。12var sum = new Function("a", "b", "return a + b;");console.log(sum(1, 1111)); //1112 2.2.2 with(不推荐实际使用)例子:12345678910111213141516171819function foo(obj) &#123; with (obj) &#123; a = 2; &#125;&#125;var o1 = &#123; a: 3&#125;;var o2 = &#123; b: 3&#125;;foo( o1 );console.log( o1.a ); // 2foo( o2 );console.log( o2.a ); // undefinedconsole.log( a ); // 2——不好，a 被泄漏到全局作用域上了! 起初你会觉得o1的a属性被with里的a进行了词法引用被遮蔽了成为了2.而o2没有a属性,此时with不能进行词法引用,所以此时o2.a就会变成undefined.但是,为什么最后console.log(a)会为2?因为在执行foo(o2)时,with会对其中的a=2进行LHS查询,但它在o2作用域,foo()作用域,全局作用域都没找到,因此就创建了一个全局变量a并随后赋值2. 总的来说,with就是将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符。 注意: 使用 eval(..) 和 with 的原因是会被严格模式所影响(限制)。with 被完全禁止，而在保留核心功能的前提下，间接或非安全地使用 eval(..) 也被禁止了。 2.2.3 性能JavaScript 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。但是eval(..) 和 with会在运行时修改或创建新的作用域，以此来欺骗其他在书写时定义的词法作用域。这么做就会导致引擎无法知道eval和with它们对词法作用域进行什么样的改动.只能对部分不进行处理和优化!因此如果代码中大量使用 eval(..) 或 with，那么运行起来一定会变得非常慢!。 2.3 小结 词法作用域是在你书写代码时就已经决定了的.在编译的第一阶段词法分析阶段产生词法作用域.此时词法作用域基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它 们进行查找。 eval(..) 和 with。前者可以对一段包含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域(在运行时)。后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域(同样是在运行时)。 一般不要在实际代码中使用eval(…)和with,因为不仅危险,而且会造成性能问题! 第三章 函数作用域和块作用域3.1 函数中的作用域 JavaScript 具有基于函数的作用域，一般情况下每声明 一个函数都会创建一个函数作用域. 函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用(事实上在嵌套的作用域中也可以使用)。这样的好处是JavaScript 变量可以根据需要改变值类型。 3.2 隐藏内部实现因为 子级函数作用域可以直接访问父级函数作用域里的标识符; 父级函数作用域不能直接访问子级函数作用域里的标识符. 所以用函数声明对代码进行包装，实际上就是把这些代码“隐藏”起来了。 为什么要将代码进行”隐藏”?因为最小授权或最小暴露原则。这个原则是指在软件设计中，应该最小限度地暴露必 要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计。隐藏的好处: 实现代码私有化,减少外部对内部代码的干扰,保持其稳定性. 规避冲突: 可以避免同名标识符之间的冲突， 两个标识符可能具有相同的名字但用途却不一样，无意间可能造成命名冲突。冲突会导致 变量的值被意外覆盖。那么一般规避冲突的手段有哪些? 全局命名空间: 变量冲突的一个典型例子存在于全局作用域中。当程序中加载了多个第三方库时，如果它们没有妥善地将内部私有的函数或变量隐藏起来，就会很容易引发冲突。这些库通常会在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象(命名空间)的属性，而不是将自己的标识符暴漏在顶级的词法作用域中。 2.模块管理: 另外一种避免冲突的办法和现代的模块机制很接近，就是从众多模块管理器中挑选一个来 使用。实际上就是我们常用的amd,commonjs,import模块机制. 3.3 函数作用域函数声明与函数表达式:123function foo() &#123; ...&#125; 我们知道函数foo内的变量和函数被隐藏起来了,是不会对全局作用域造成污染.但是变量名foo仍然存在于全局作用域中,会造成污染.那有什么方法能避免函数名的污染呢?那就是作为函数表达式,而不是一个标准的函数声明.这样函数名只存在于它自己的函数作用域内,而不会存在于其父作用域,这样就没有了污染.举个函数声明的例子:123456var a = 2;(function foo()&#123; var a = 3; console.log( a ); // 3 &#125;)(); console.log( a ); // 2 当我们用()包裹一个函数,并立即执行.此时这个包装函数声明是从(function开始的而不是从function关键字开始.这样foo就会被当做一个函数表达式,而不是一个函数声明(即foo不会存在于父级作用域中).回到上面的例子中,全局作用域是访问不到foo的,foo只存在于它自己的函数作用域中. 补充: 什么是函数声明和函数表达式首先我们得了解JS声明函数的三种方式: 函数表达式(Function Expression): 将函数定义为表达式语句（通常是变量赋值,也可以是自调用形式）的一部分。通过函数表达式定义的函数可以是命名的，也可以是匿名的。因为它可以没有函数名,因此常被用作匿名函数.如果有,其函数名也只存在自身的函数作用域.并且函数表达式不能以“function”开头.函数表达式可以存储在变量或者对象属性里. (在函数声明前加上运算符是可以将其转化为函数表达式的.例如!,+,-,().举个例子:!function(){console.log(1)}()的结果是1,并不会报错) 函数声明(Function Declaration): 函数声明是一种独立的结构,它会声明一个具名函数,并必须以function开头. 且函数声明会进行函数提升.使它能在其所在作用域的任意位置被调用,即后面的代码中可以将此函数通过函数名赋值给变量或者对象属性. Function()构造器: 即使用Function构造器创建函数.不推荐这种用法, 容易出问题123456789101112131415//Function()构造器var f =new Function()// 函数表达式var f = function() &#123; console.log(1); &#125;// 函数声明function f ()&#123; console.log(2);&#125;console.log(f())//思考一下,这里会打印出什么 怎么区分函数声明和函数表达式:看 function 关键字出现在声明中的位置(不仅仅是一行代码，而是整个声明中的位置)。如果 function 是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。例如上例中,是从(开始而不是function. 补充: 上面这段是原书的解释,我觉得这个解释并不完全,这里给出我自己的解释. 表象区别:和它说的一样,只要是以function开头进行声明,并且含有函数名的就一定是函数声明. 内在区别:其实我在上面补充两者的定义时已经说得很清楚了,我再对比总结下. 函数提升:函数声明,会将整个函数进行提升.而函数表达式则不会提升,它是在引擎运行时进行赋值，且要等到表达式赋值完成后才能调用。 函数表达式是可以没有函数名的,如果有,它的函数名也只存在于自身的作用域,var f = function fun(){console.log(fun)}其他地方是没有的.这也避免了全局污染,也方便递归. 3.3.1 匿名和具名函数表达式可以是匿名的，而函数声明则不可以省略函数名.有函数名的就是具名函数,没有函数名的就是匿名函数. 匿名函数的缺点: 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。 如果没有函数名，当函数需要引用自身时只能使用已经过期的arguments.callee引用，比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。 匿名函数省略了对于代码可读性/可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。 所以给函数表达式指定一个函数名可以有效解决以上问题。始终给函数表达式命名是一个最佳实践. PS: 个人意见是如果函数表达式有赋值给变量或属性名或者就是一次性调用的.其实是没必要加上函数名.因为代码里取名本来就很难,取不好反而会造成误解. 3.3.2 立即执行函数表达式比如 (function foo(){ .. })()。第一个 ( ) 将函数变成表达式，第二个 ( ) 执行了这个函数。这就是立即执行函数表达式,也被称为IIFE，代表立即执行函数表达式 (Immediately Invoked Function Expression); IIFE可以具名也可以匿名.好处和上面提到的一样.IIFE还可以是这种形式(function(){ .. }()).这两种形式在功能上是一致的。 3.4 块作用域函数作用域是JavaScript最常见的作用域单元,有时我们仅会将var赋值变量在if或for的{…}内使用,而不会在其他地方使用.但它仍然会对外层的函数作用域造成污染.这个时候就会希望能有一个作用域能将其外部的函数作用域隔开,声明的变量仅在此作用域有效.块作用域(通常就是{…}包裹的内部)就可以帮我们做到这点. 从 ES3 发布以来，JavaScript 中就有了块作用域，而 with 和 catch 分句就是块作用域的两个小例子。 3.4.1 with我们在第 2 章讨论过 with 关键字。它不仅是一个难于理解的结构，同时也是块作用域的一个例子(块作用域的一种形式)，用 with 从对象中创建出的作用域仅在 with 声明中而非外部作用域中有效。 3.4.2 try/catchtry/catch 的 catch 分句会创建一个块作用域，其中声明的变量仅在 catch 内部有效。1234567try &#123; undefined(); // 执行一个非法操作来强制制造一个异常&#125;catch (err) &#123; console.log( err ); // 能够正常执行! &#125;console.log( err ); // ReferenceError: err not found err 仅存在 catch 分句内部，当试图从别处引用它时会抛出错误。那么如果我们想用catch创建一个不是仅仅接收err的块作用域,该怎么做呢?1234try&#123;throw 2;&#125;catch(a)&#123; console.log( a ); // 2&#125;console.log( a ); // ReferenceError 这样就创建了一个块作用域,且a=2,仅在catch分句中存在.在ES6之前我们可以使用这种方法来使用块作用域. 3.4.3 letES6 引入了新的 let 关键字，提供了除 var 以外的另一种变量声明方式。let 关键字可以将变量绑定到所在的任意作用域中(通常是 { .. } 内部)。 用 let 将变量附加在一个已经存在的块作用域上的行为是隐式的。例如在if的{…}内用let声明一个变量.那什么是显式地创建块作用域呢?就是单独创建{}来作为let的块作用域.而不是借用if或者for提供的{}.例如{let a=2;console.log(a)}注意: 使用 let 进行的声明不会在块作用域中进行提升.块作用域的好处: 1,垃圾收集12345678910111213function process(data)&#123; // 在这里做点有趣的事情 &#125; var someReallyBigData=function()&#123; //dosomeing &#125; process(someReallyBigData); var btn=document.getElementById("my_button"); btn.addEventListener("click",function click(evt)&#123; alert("button click"); //假如我们在这里继续调用someReallyBigData就会形成闭包,导致不能垃圾回收(这段是书里没有,我加上方便理解的) &#125;,false); click 函数的点击回调并不需要 someReallyBigData 变量。理论上这意味着当 process(..) 执行后，在内存中占用大量空间的数据结构就可以被垃圾回收了。但是，由于 click 函数形成了一个覆盖整个作用域的闭包，JavaScript 引擎极有可能依然保存着这个结构(取决于具体实现)。但显式使用块作用域可以让引擎清楚地知道没有必要继续保存 someReallyBigData 了: 123456789101112function process(data)&#123; // 在这里做点有趣的事情 &#125; // 在这个块中定义的内容可以销毁了! &#123; let someReallyBigData = &#123; .. &#125;; process( someReallyBigData ); &#125; var btn=document.getElementById("my_button"); btn.addEventListener("click",function click(evt)&#123; alert("button click"); &#125;,false); let循环1234for (let i=0; i&lt;10; i++) &#123; console.log( i ); &#125;console.log( i ); // ReferenceError for 循环头部的 let 不仅将 i 绑定到了 for 循环的块中，事实上它将其重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。这样就避免了i对外部函数作用域的污染. 3.4.4 const除了 let 以外，ES6 还引入了 const，同样可以用来创建块作用域变量，但其值是固定的(常量)。之后任何试图修改值的操作都会引起错误。123456789var foo = true;if (foo) &#123; var a = 2; const b = 3; // 包含在 if 中的块作用域常量 a = 3; // 正常! b = 4; // 错误! &#125;console.log( a ); // 3console.log( b ); // ReferenceError! 3.5 小结函数是 JavaScript 中最常见的作用域单元。本质上，声明在一个函数内部的变量或函数会在所处的作用域中“隐藏”起来，可以有效地与外部作用域隔开. 但函数不是唯一的作用域单元。块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块(通常指 { .. } 内部)即块作用域。ES6中就提供了let和const来帮助创建块作用域. 第四章 提升4.1 先有鸡(赋值)还是先有蛋(声明)考虑第一段代码123a = 2;var a; console.log( a ); 输出结果是2,而不是undefined 考虑第二段代码12console.log( a ); var a = 2; 输出结果是undefined,而不是ReferenceError考虑完以上代码,你应该会考虑这个问题.到底是声明(蛋)在前，还是赋值(鸡)在前? 4.2 编译器再度来袭编译器的内容,回忆一下，引擎会在解释 JavaScript 代码之前首先对其进行编译。编译阶段中的一部分工作就是找到所有的声明，并用合适的作用域将它们关联起来。 之后引擎会询问作用域,对声明进行赋值操作. 那么,在编译阶段找到所有的声明后,编译器又做了什么?答案就是提升以上节的第一段代码为例,当你看到 var a = 2; 时，可能会认为这是一个声明。但 JavaScript 实际上会将其看成两个声明:var a;和a = 2;。 第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在原地等待执行阶段。在第一个声明在编译阶段时,编译器会对var a;声明进行提升(即把var a;置于所在作用域的最上面).而a = 2;则会保持所在位置不动.此时代码会变成123var a; a = 2;console.log( a ); 由此可知,在编译阶段,编译器会对声明进行提升.即先有蛋(声明)后有鸡(赋值)。哪些声明会被进行提升? 变量声明:例如上例中的var a;.不包括后面的a = 2;即不包含有赋值操作的声明. 函数声明:注意是函数声明,而不是函数表达式!(不清楚可以看前面的3.3节,我有详细说明).函数声明提升,是将整个函数进行提升,而不是仅仅函数名的提升. 4.3 函数优先函数声明和变量声明都会被提升。但是一个值得注意的细节(这个细节可以出现在有多个“重复”声明的代码中)是函数会首先被提升，然后才是变量。考虑以下代码:12345678foo(); // 1var foo;function foo() &#123; console.log( 1 );&#125;foo = function() &#123; console.log( 2 );&#125;; 会输出 1 而不是 2 !这个代码片段会被引擎理解为如下形式:1234567function foo() &#123; console.log( 1 );&#125;foo(); // 1foo = function() &#123; console.log( 2 );&#125;; 注意，var foo 尽管出现在 function foo()… 的声明之前，但它是重复的声明(因此被忽略了)，因为函数声明会被提升到普通变量之前。注意: js会忽略前面已经声明的声明(不管是变量声明还是函数声明,只要其名称相同,则后续不会再进行重复声明).但是对该变量新的赋值,会覆盖之前的值.一句话概括:函数声明的优先级高于变量声明,会排在它前面. 4.4 小结 对于var a = 2 JavaScript引擎会将var a和 a = 2当作两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务。 论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。 可以将这个过程形象地想象成所有的声明(变量和函数)都会被“移动”到各自作用域的最顶端，这个过程被称为提升。 声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升(即赋值操作都不会提升)。 注意:，当普通的 var 声明和函数声明混合在一起的时候，并且声明相同时(var的变量名和函数名相同时,会引发js对重复声明的忽略)!一定要注意避免重复声明! 第五章 作用域闭包5.1 启示 JavaScript中闭包无处不在，你只需要能够识别并拥抱它。 闭包是基于词法作用域书写代码时所产生的自然结果，你甚至不需要为了利用它们而有意识地创建闭包。 5.2 实质问题 &amp;&amp; 5.3 现在我懂了因为这两小节理解透了其实发现书里也没讲什么,这里就进行合并,并补充拓展我自己的理解和总结.什么是闭包?(广义版)书中解释: 当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。MDN的解释: 闭包是函数和声明该函数的词法环境的组合。我的解释(详细版): 必须包含两点: 1,有函数.由于函数自身的特性,它能访问所在的词法作用域.并能保存外部词法作用域的变量和函数到自己的函数作用域. 2,有该函数所在的词法环境.其实在JavaScript中任何函数都会处在一个词法环境中.不管是全局作用域还是函数作用域. 综上简单版就是:MDN的解释闭包是函数和声明该函数的词法环境的组合。还可以继续延伸成极简版:JavaScript中的函数就会形成闭包。Tips: 注意到上面对词法作用域和词法环境两词的分开使用了吗?1,里此时函数还没被执行,所以使用的是词法作用域即静态作用域.2,里,此时函数被执行,此时词法作用域就会变成词法环境(包含静态作用域与动态作用域).所以其实MDN的解释其实更准确一点, 我们日常使用时所说的闭包(狭义版,严格意义上的):为了便于对闭包作用域的观察和使用.我们实际使用时会将闭包的函数作用域暴露给当前词法作用域之外.也就是本书一直强调的闭包函数需要在它本身的词法作用域以外执行.作者认为符合这个条件才称得上是真正的闭包(也就是我们日常使用常说的’使用闭包’,并且使用任何回调函数其实也是闭包).所以狭义版就是:闭包是函数和声明该函数的词法环境的组合,并且将闭包的函数作用域暴露给当前词法作用域之外. 闭包暴露函数作用域的三种方式:下面部分是书中没有的,是自己实际使用时的总结,并且符合这三种形式之一的就是我们日常使用时所说的闭包(狭义版) 1,通过外部函数的参数进行暴露. 1234567891011function foo() &#123; var a = 2; function bar() &#123; baz(a) //通过外部函数的参数进行暴露 &#125; bar(); &#125;;function baz(val) &#123; console.log( val ); // 2 &#125;foo(); 2,通过外部作用域的变量进行暴露 12345678910var val;function foo() &#123; var a = 2; function bar() &#123; val=a //通过外部作用域的变量进行暴露 &#125; bar(); &#125;;foo();console.log(val) //2 3,通过return直接将整个函数进行暴露 123456789function foo() &#123; var a = 2; function bar() &#123; console.log(a) &#125; return bar //通过return直接将整个函数进行暴露&#125;;var val=foo();val() //2 关于闭包的内存泄露问题:首先必须声明一点:使用闭包并不一定会造成内存泄露,只有使用闭包不当才可能会造成内存泄露.(吐槽:面试很多新人时,张口就说闭包会造成内存泄露)为什么闭包可能会造成内存泄露呢?原因就是上面提到的,因为它一般会暴露自身的作用域给外部使用.如果使用不当,就可能导致该内存一直被占用,无法被JS的垃圾回收机制回收.就造成了内存泄露.注意: 即使闭包里面什么都没有,闭包仍然会隐式地引用它所在作用域里的所用变量. 正因为这个隐藏的特点,闭包经常会发生不易发现的内存泄漏问题.常见哪些情况使用闭包会造成内存泄露: 1,使用定时器未及时清除.因为计时器只有先停止才会被回收.所以决办法很简单,将定时器及时清除,并将造成内存的变量赋值为null(变成空指针) 2,相互循环引用.这是经常容易犯的错误,并且也不容易发现.举个栗子:12345678function foo() &#123; var a = &#123;&#125;; function bar() &#123; console.log(a); &#125;; a.fn = bar; return bar; &#125;; 这里创建了一个a 的对象，该对象被内部函数bar引用。然后，a创建了一个属性fn指向了bar，最后返回了innerFn()。这样就形成了bar和a的相互循环引用.可能有人说bar里不使用console.log(a)不就没有引用了吗就不会造成内存泄露了.NONONO,bar作为一个闭包,即使它内部什么都没有,foo中的所有变量都还是隐使地被 bar所引用。这个知识点是我前面忘记提到的,也是书中没有提到的.算了我现在加到前面去吧.所以即使bar内什么都没有还是造成了循环引用,那真正的解决办法就是,不要将a.fn = bar. 3,将闭包引用到全局变量上.因为全局变量是只有当页面被关闭的时候才会被回收. 4,在闭包中对DOM进行不当的引用.这个常见于老IE浏览器,现代浏览器已经长大了,已经学会了自己处理这种情况了.这里就不赘述了.想知道的可以自行问谷娘和度娘. 总而言之,解决办法就是使闭包的能正常引用,能被正常回收.如果实在不行,就是在使用完后,手动将变量赋值null,强行进行垃圾回收. 5.4 循环和闭包看如下例子:12345for (var i=1; i&lt;=5; i++) &#123; setTimeout( function timer() &#123; console.log( i ); &#125;, i*1000 );&#125; 我们期望的结果是分别输出数字 1~5，每秒一次，每次一个。但实际结果是,这段代码在运行时会以每秒一次的频率输出五次 6。(关于书里的解释,我觉得有点说复杂了,没说到点子上,下面是我的解释.)为什么会是这样的结果?timer毫无疑问是一个闭包,它是可以访问到外部的变量i.在进行for循环时,timer()会被重复执行5次,也就是它会 console.log( i )5次.(关键部分来了!)这5次i其实是同一个i.它是来自于外部作用域,即for里面声明的i.在词法作用域中变量i只可能对应一个唯一的值,即变量和它的值是一一对应的.不会变化的.那这个值到底是多少呢?这个值就是最终值! i的最终值就是6即for循环完后i的值.当引擎执行console.log( i )时,它会询问i所对应的作用域,问它i的值是多少.这个时候作用域进行RHS查询得到的结果就是最终值6. 为什么我们会以为分别输出1~5?因为在for循环中,我们错以为每一次循环时,函数所输出的i是根据循环动态变化的.即是1~5累加变化的.但实际上它所访问的i是同一个固定不变的值,即最终值6.可能你会有这样的疑惑,那我循环还有意义吗?i其实一开始就确定是6了.没有变化过!错!i变化过,它的确是从1逐步增加到6的.只是外部作用域的i值只可能是循环完后的最终值,并且函数timer()并没有保存每次i变化的值.它只是访问了外部作用域的i值即最终的值6. OK我们知道了出错的地方,就是我们没有把每次i的值保存在一个独立的作用域中.接下来,看下这个改进的例子结果是多少.1234567for (var i=1; i&lt;=5; i++) &#123; (function() &#123; setTimeout( function timer() &#123; console.log( i ); &#125;, i*1000 ); &#125;)();&#125; 它的最终值仍然是5个6.为什么?我们来分析下,上例中,它用了一个匿名函数包裹了定时器,并立即执行.在进行for循环时,会创造5个独立的函数作用域(由匿名函数创建的,因为它是闭包函数).但是这5个独立的函数作用域里的i也全都是对外部作用域的引用.即它们访问的都是i的最终值6.这并不是我们想要的,我们要的是5个独立的作用域,并且每个作用域都保存一个”当时”i的值. 解决办法:那我们这样改写.123456789for (var i=1; i&lt;=5; i++) &#123; (function () &#123; var j =i; setTimeout( function timer() &#123; console.log( j ); &#125;, j*1000 ); &#125;)();&#125;//这次终于结果是分别输出数字 1~5，每秒一次，每次一个。 这样改写后,匿名函数每次都通过j保存了每次i值,这样i值就通过j保存在了独立的作用域中.注意此时保存的i值是’当时’的值,并不是循环完后的最终值.这样循环完后,实际上就创建了5个独立的作用域,每个作用域都保存了一个’当时’i的值(通过j).当引擎执行console.log( j )询问其对应的独立作用域时,得到的值就是’当时’保存的值,再也不是6了.我们还可以进一步简写为这样:12345678for (var i=1; i&lt;=5; i++) &#123; (function(j) &#123; setTimeout( function timer() &#123; console.log( j ); &#125;, j*1000 ); &#125;)(i);&#125;//结果是分别输出数字 1~5，每秒一次，每次一个。 利用块作用域进行解决:在es6中,我们不仅可以使用函数来创建一个独立的作用域,我们还可以使用let声明来创建一个独立的块作用域(在{}内).所以我们还可以这样改写:123456for (let i=1; i&lt;=5; i++) &#123; setTimeout( function timer() &#123; console.log( i ); &#125;, i*1000 );&#125;//结果是分别输出数字 1~5，每秒一次，每次一个。 这样改写,在每次循环时,let都会对i进行声明.并通过循环自带的{}创建一个独立的块作用域.并且let声明的i,保存了’当时’i的值在当前块作用域里.因此当引擎执行console.log( i )时,它会询问对应的块作用域上i的值,得到的结果就是’当时’保存的值. 延伸:实际上块作用域可以称得上一个’伪’闭包(之所以是伪,是因为闭包规定了只能是函数).因为它几乎拥有闭包的所有特性.它也可以创建一个独立的作用域,同样外部作用域不能访问块作用域的变量.但块作用域可以访问外部作用域.举个栗子:123456789function foo() &#123; var a = 2; &#123; //通过&#123;&#125; 显示表示块作用域 let b = a; console.log('块作用域内',b) //2 &#125; console.log('块作用域外',b) //b is not defined&#125;foo() 说了相同点,说说不同点:1,保存变量到块作用域,必须通过let声明.2,块作用域不能和函数一样有名称(函数名)很多不方便使用闭包或者比较麻烦的时候,是可以考虑通过块作用域进行解决. 总结一下一般什么时候考虑使用闭包:这部分也是自己工作使用的总结,如果有补充或者不对的地方,欢迎留言指正. 1,需要创建一个独立的作用域并隐藏一些变量或函数,不被外部使用;或者想保存一些外部作用域的变量或函数到这个独立作用域. 2,只想暴露一部分自身作用域的变量或函数给外部使用. 5.5 模块首先看下面的例子:123456789101112131415161718function CoolModule() &#123; var something = "cool"; var another = [1, 2, 3]; function doSomething() &#123; console.log( something ); &#125; function doAnother() &#123; console.log( another.join( " ! " ) ); &#125; return &#123; doSomething: doSomething, doAnother: doAnother &#125;; &#125;var foo = CoolModule(); foo.doSomething(); // coolfoo.doAnother(); // 1 ! 2 ! 3 首先我们对上面这段代码进成分行分析:私有数据变量:something, another内部函数:doSomething, doAnother直接说结论,上面这个例子就是模块模式.它return返回的这个对象也就是模块也被称为公共API(至少书中是这样称呼的).CoolModule()就是模块构造器或者叫模块函数.注意: 这里的模块和我们所说的模块化开发不是完全一样的! 模块不一定非要是标准对象,也可以是一个函数,函数本质上也是对象,函数也可以有自己的属性. 书中有这样一句话CoolModule() 只是一个函数，必须要通过调用它来创建一个模块实例。如果不执行外部函数，内部作用域和闭包都无法被创建。我觉得这句话有必要延伸说一下.函数调用一次就会创建一个该函数的作用域(不调用就不会创建),包括创建它里面的变量和函数. 模块模式:模块模式需要具备以下2个条件:(这里结合上面的例子,对书中的定义进行说明方便理解) 1, 必须有外部的封闭函数(即CoolModule)，该函数必须至少被调用一次(每次调用都会创建一个新的模块实例–&gt;模块实例指的就是函数return返回的对象)。 2, 封闭函数(即CoolModule)必须返回至少一个内部函数(即doSomething, doAnother)，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态(即something, another)。 模块:表面上看由模块函数(例子中的CoolModule)所返回的对象就是模块.但模块还必须还包含模块函数的内部函数(即闭包函数).只有包含了才能真正称得上是模块.才强调一次这里的模块与模块化里的模块是有区别的,也不是nodejs里的模块. 模块函数:模块函数也就是模块构造器,例子中的CoolModule().一般它有两个常见用法. 通过接受参数,对输出的模块进行修改. 通过添加模块里添加相关的内部函数,实现对输出模块数据的增删改查.(书中用命名将要作为公共API返回的对象.我觉得命名应该是用错了,应该是修改即增删改查更好) 5.5.1 现代的模块机制大多数模块依赖加载器 / 管理器本质上都是将这种模块定义封装进一个友好的 API。下面就介绍一个简单的模块管理器实现例子(对书中的例子进行逐行解读):1234567891011121314151617181920212223242526272829303132//首先实例化我们的模块管理器,取名myModulesvar MyModules=(function Manager() &#123; //作为我们的模块池,保存所有定义的模块 var modules=&#123;&#125;; /** *使用类似AMD的方式定义新模块，接收3个参数 *name:模块名 *deps:数组形式表示所依赖的其他模块 *impl:模块功能的实现 **/ function define(name,deps,impl) &#123; //遍历依赖模块数组的每一项，从程序池中取出对应的模块,并赋值. //循环完后,deps由保存模块名的数组变成了保存对应模块的数组. for (var i=0;i&lt;deps.length;i++) &#123; deps[i]=modules[deps[i]]; &#125; //将新模块存储进模块池，并通过apply注入它所依赖的模块(即遍历后的deps,实际上就是用deps作为impl的入参) modules[name]=impl.apply(impl,deps); &#125; //从模块池中取出对应模块 function get (name) &#123; return modules[name]; &#125; //暴露定义模块和获取模块的两个api return &#123; define: define, get: get &#125;&#125;)() 说明: 后面书中说了这么一句为了模块的定义引入了包装函数(可以传入任何依赖),这里包装函数指的是Manger(),同样也是我们上节提到的模块函数.首先说明下什么是包装函数.例如函数A当中还有一个函数B.当我们想要调用函数B的时候,则需要先调用函数A.那么函数A就叫做函数B的包装函数.也就是说我们想调用某个模块时,需要先调用它的包装函数即这里的Manger().接着是后面那句并且将返回值，也就是模块的 API，储存在一个根据名字来管理的模块列表中。注意这里的返回值是指impl的返回值. 接着看通过管理器来定义和使用模块 123456789101112131415161718192021222324252627282930313233MyModules.define('bar',[],function () &#123; function hello (who) &#123; return "Let me introduce: " + who; &#125; //返回公共API 即提供一个hello的接口 return &#123; hello:hello &#125;;&#125;);MyModules.define('foo',['bar'],function (bar) &#123; var hungry = "hippo"; functin awesome () &#123; //这里的bar为返回模块bar返回的公共API console.log( bar.hello( hungry ).toUpperCase() ); &#125; //返回公共API 即提供一个awesome的接口 return &#123; awesome:awesome &#125;&#125;)var bar=MyModules.get('bar');//通过管理器获取模块'bar'var foo=MyModules.get('foo');//通过管理器获取模块'foo'console.log(//调用模块bar的hello接口 bar.hello( "hippo" ) ); // Let me introduce: hippo //调用模块foo的awesome接口foo.awesome(); // LET ME INTRODUCE: HIPPO 这节的主要内容还是了解现在是如何对模块进行一个规范处理.主要是两部分内容,一个是通过名称和依赖合理定义模块并储存.另一个则是通过名称对存储的模块的调用.其实还可以再增加一个删除模块的方法. 5.5.2 未来的模块机制ok,这节说的模块,就是我们常说的模块化开发.并且主要提到的就是ES6里常用的import.没什么好说的. 5.6 小结吐槽: 同一个函数概念在5.5这一个小节里,居然换着花样蹦出了三个名字!一会叫模块构造器!一会叫模块函数!以及最后的包装函数!每变化一次,都得想一遍它指的是啥!真的是无力吐槽了!!!! 闭包:当函数可以记住并访问所在的词法作用域，并且函数是在当前词法作用域之外执行，这时 就产生了闭包。 模块有两个主要特征: (1)为创建内部作用域而调用了一个包装函数(模块构造器的实例化,不想对频繁换名字吐槽了); (2)包装函数的返回值(也就是模块)必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。 第二部分第一章 关于this1.1 为什么要用this因为this 提供了一种更优雅的方式来隐式“传递”一个对象(即上下文对象)引用，因此可以将 API 设计得更加简洁并且易于复用。 1.2 误解下面两种常见的对于 this 的解释都是错误的(看看就好,就不过多解读了,以免增加了对错误的印象)。 1.2.1 指向自身人们很容易把 this 理解成指向函数自身. 具名函数，可以在它内部可以使用函数名来引用自身进行递归,添加属性等。(这个知识点其实在第三章提过,既然这里又提了一遍,我也再说一遍.)例如:123function foo() &#123; foo.count = 4; // foo 指向它自身&#125; 匿名函数如果想要调用自身则,需要使用arguments.callee不过这个属性在ES5严格模式下已经禁止了,也不建议使用.详情可以查看MDN的说明. 1.2.2 它的作用域切记: this 在任何情况下都不指向函数的词法作用域。你不能使用 this 来引用一个词法作用域内部的东西。 这部分只需记住这一段话就行. 终极疑问: JavaScript里的作用域到底是对象吗?这小节最令我在意的是里面这句话”在 JavaScript 内部，作用域确实和对象类似，可见的标识符都是它的属性。但是作用域“对象”无法通过 JavaScript代码访问，它存在于JavaScript 引擎内部。”它让我想起了最开始学JS的一个疑问,JavaScript里的作用域到底是对象吗.虽然”在JS里万物皆对象”.但是作用域给人的感觉却不像是一个对象.更像是一个范围,由函数的{}围城的范围,限制了其中变量的访问.但直觉告诉我它和对象还是应该有点联系的.直到读到书中的这段话,更加印证了我的感觉.在JavaScript里,作用域其实是一个比较特殊的对象,作用域里所有可见的标识符都是它的属性.只是作用域对象并不能通过JavaScript代码被我们访问,它只存在于JavaScript引擎内部.所以作用域作为一个”对象”是经常被我们忽略. 1.3 this到底是什么this 是在运行时(runtime)进行绑定的，并不是在编写时绑定，它的上下文(对象)取决于函数调用时的各种条件。this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。 当一个函数被调用时，会创建一个活动记录(有时候也称为执行上下文)。这个记录会包含函数在哪里被调用(调用栈)、函数的调用方法、传入的参数等信息。this 就是记录的其中一个属性，会在函数执行的过程中用到。(PS:所以this并不等价于执行上下文) 1.4 小结 学习 this 的第一步是明白 this 既不指向函数自身也不指向函数的词法作用域 this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用(关于this你必须记住的话)。 第二章 this全面解析2.1 调用位置通过上节我们知道,this的绑定与函数的调用位置有关.那调用位置是什么.调用位置就是函数在代码中被调用的位置(而不是声明的位置)。 要寻找调用位置,最重要的是要分析调用栈(就是为了到达当前执行位置所调用的所有函数)。我们关心的调用位置就在当前正在执行的函数的前一个调用中。PS:调用栈其实是一个解释起来有点复杂的概念.这里我就不过多解释,这里推荐一篇文章,解释得不错. 这节书里的例子解释得不错,这里就不复制代码了.其实分析调用栈只是为了在运行时找到我们关心的函数到底在哪里和被谁调用了. 但是实际别写代码时,其实并不会分析得这么清楚的,我们还是只需记住this的指向就是我们调用该函数的上下文对象.意思就是我们在哪里调用该函数,this就指向哪里.并且查看调用栈还可以通过浏览器的开发者工具,只需在疑惑的代码上一行加上debugger即可.浏览器在调试模式时,我们就可以在调用列表里查看调用栈.我们一般也仅在查找bug时,会使用该方法. 2.2 绑定规则在找到调用位置后,则需要判定代码属于下面四种绑定规则中的哪一种.然后才能对this进行绑定.注意: this绑定的是上下文对象,并不是函数自身也不是函数的词法作用域 2.2.1 默认绑定什么是独立函数调用:对函数直接使用而不带任何修饰的函数引用进行调用.简单点一个函数直接是func()这样调用,前面什么都没有.不同于通过对象属性调用例如obj.func(),也没有通过new关键字new Function();也没有通过apply,bind,call强制改变this指向.默认绑定: 当被用作独立函数调用时（不论这个函数在哪被调用,不管全局还是其他函数内），this默认指向到window；注意: 如果使用严格模式(strict mode)，那么全局对象将无法使用默认绑定，因此 this 会绑定到 undefined. 2.2.2 隐式绑定隐式绑定: 函数被某个对象拥有或者包含.也就是函数被作为对象的属性所引用.例如obj.func().此时this会绑定到该对象上.隐式丢失: 不管是通过函数别名或是将函数作为入参造成的隐式丢失.只需找到它真正的调用位置,并且函数前没有任何修饰也没有显式绑定(下节会讲到)(非严格模式下).那么this则会进行默认绑定,指向window.注意: 实际工作中,大部分this使用错误都是由对隐式丢失的不理解造成的.记住函数调用前没有任何修饰和显式绑定(其实就是call、apply、bind),this就指向window 2.2.3 显式绑定在分析隐式绑定时，我们必须在一个对象内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把 this 间接(隐式)绑定到这个对象上。如果我们不想在对象内部包含函数引用，而想在某个对象上强制调用函数，此时则需要显式绑定.显式绑定: 可以直接指定 this 的绑定对象，被称之为显式绑定。基本上就是我们常使用的call、apply、bind方法都是显式绑定.(如果这三个方法不能熟练使用的,建议找度娘或者谷娘学习后,再看这节.)注意:如果你传入了一个原始值(字符串类型、布尔类型或者数字类型)来当作 this 的绑定对 象，这个原始值会被转换成它的对象形式(也就是new String(..)、new Boolean(..)或者 new Number(..))。这通常被称为“装箱”。 硬绑定: 使用call、apply、bind方法强制显式地将this进行绑定,称之为硬绑定。硬绑定的典型应用场景就是创建一个包裹函数(其实就是常说的封装函数)，传入所有的参数并返回接收到的所有值.在封装函数中,我们常使用apply.一方面是因为它可以手动绑定this,更重要的是因为可以用apply的第二个参数,方便地注入所有传入的参数.例如之前提到的modules[name]=impl.apply(impl,deps).因为我们不知道传入的参数有多少个,但我们可以方便地使用一个deps将其全部注入.另一个常用的是foo.apply( null,argue)当我们将apply的第一个参数设置为null时,此时this就会默认绑定到window.切记使用这种用法时确保函数foo内没有使用this. 否则很可能会造成全局污染.如果是第三方库的函数就建议不要使用了,因为你不知道别人的函数是否使用了this(关于这部分内容,下节会继续提到).还有一种常用就是foo.call( this).这样foo里的this都会指向当前调用的上下文环境. API调用的“上下文”: 第三方库的许多函数，以及 JavaScript 语言和宿主环境中许多新的内置函数，都提供了一个可选的参数，通常被称为“上下文”(context)，其作用和 bind(..) 一样，确保你的回调函数使用指定的 this。 2.2.4 new绑定JavaScript 中 new 的机制实际上和面向类的语言完全不同。在 JavaScript 中，构造函数只是一些 使用 new 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上， 它们甚至都不能说是一种特殊的函数类型，它们只是被 new 操作符调用的普通函数而已。实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”。 使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。 1,创建(或者说构造)一个全新的对象。 2,这个新对象会被执行[[原型]]连接。 3,这个新对象会绑定到函数调用的this。 4,如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。 示例:12345function foo(a) &#123; this.a = a;&#125;var bar = new foo(2); console.log( bar.a ); // 2 使用 new 来调用 foo(..) 时，我们会构造一个新对象并把它绑定到 foo(..) 调用中的 this 上。说明:对于上面这句话进行解释下,如果在一个函数前面带上 new 关键字来调用， 那么背地里将会创建一个连接到该函数的 prototype 的新对象，this就指向这个新对象； 2.3 优先级直接上结论:new绑定=显示绑定&gt;隐式绑定&gt;默认绑定说明: new绑定与显示绑定是不能直接进行测试比较,但通过分析发现new绑定内部其实是使用了硬绑定(显示绑定的一种),所以new绑定和显示绑定优先级应该差不多.但话说回来,一般实际使用时,不会这种复杂的交错绑定.所以只需记住下面的判定即可. 判断this:现在我们可以根据优先级来判断函数在某个调用位置应用的是哪条规则。可以按照下面的顺序来进行判断: 1,函数是否在new中调用(new绑定)?如果是的话this绑定的是新创建的对象。 var bar = new foo() 2,函数是否通过call、apply(显式绑定)或者硬绑定调用?如果是的话，this绑定的是 指定的对象。var bar = foo.call(obj2) 3,函数是否在某个上下文对象中调用(隐式绑定)?如果是的话，this 绑定的是那个上 下文对象。var bar = obj1.foo() 4,如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到 全局对象。var bar = foo()就是这样。对于正常的函数调用来说，理解了这些知识你就可以明白 this 的绑定原理了。 2.4 绑定例外2.4.1 被忽略的this如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值在调用时会被忽略，实际应用的是默认绑定规则,this会绑定到window上.使用情景:一种非常常见的做法是使用 apply(..) 来“展开”一个数组(也可以用来方便地参数注入)，并当作参数传入一个函数。类似地，bind(..) 可以对参数进行柯里化(预先设置一些参数).通过自带bind方法实现柯里化是很方便的,比自己写要简化好多. 注意: 在 ES6 中，可以用 … 操作符代替 apply(..) 来“展 开”数组，foo(…[1,2]) 和 foo(1,2)是一样的，这样可以避免不必要的 this 绑定。可惜，在 ES6 中没有柯里化的相关语法，因此还是需要使用 bind(..)。 当使用null或者undefined进行绑定时,要确保该函数内没有使用this,否则此时很容易对全局变量造成破坏!尤其是使用第三方库的方法! 更安全的this如果函数内使用了this,直接使用null则可能会对全局造成破坏.因此我们可以通过创建一个“DMZ”(demilitarized zone，非军事区)对象——它就是一个空的非委托的对象(委托在第 5 章和第 6 章介绍)。让this绑定到这个”DMZ上.这样就不会对全局造成破坏.怎么创建DMZ呢.就是通过Object.create(null) 创建一个空对象.这种方法和 {} 很像，但是并不会创建 Object.prototype 这个委托，所以它比 {}“更空”更加安全. PS:实际使用一般不会遇到这种情况(也可能是我太菜,没遇到),如果函数内有this,那肯定是有需要调用的变量或函数,直接把它绑定到一个空对象上.那什么都取不到,还有什么意义?所以函数没有this就传入null.如果有this就把它绑定到真正需要它的对象上,而不是一个空对象上.这些是我自己的见解,如果有不妥的,欢迎留言指正. 2.4.2 间接引用12345678function foo() &#123; console.log( this.a );&#125;var a = 2;var o = &#123; a: 3, foo: foo &#125;; var p = &#123; a: 4 &#125;;o.foo(); // 3(p.foo = o.foo)(); // 2 其实就是foo() 此时this默认绑定到window 例子中的间接引用其实是对函数的理解不深造成的.其实(p.foo = o.foo)()就是(foo)(),这样就是全局调用foo()所以this默认就绑定到了window上.注意:对于默认绑定来说，决定 this 绑定对象的并不是调用位置是否处于严格模式，而是 函数体是否处于严格模式。如果函数体处于严格模式，this 会被绑定到 undefined，否则 this 会被绑定到全局对象。(对于这段话其实在2.2.1节就应该说了!) 2.4.3 软绑定硬绑定会大大降低函数的灵活性，使用硬绑定之后就无法使用隐式绑定或者显式绑定来修改 this。这时候则需要使用软绑定.Tips: 这里给的软绑定方法还是挺好的.但是建议还是在自己的代码里使用,并注释清除.以免别人使用,对this错误的判断. 2.5 this词法 ES6 中介绍了一种无法使用上面四条规则的特殊函数类型:箭头函数。 箭头函数不使用 this 的四种标准规则，而是根据外层(函数或者全局)作用域来决定 this。(而传统的this与函数作用域没有任何关系,它只与调用位置的上下文对象有关.这点在本章开头就已经反复强调了.) 重要: 箭头函数最常用于回调函数中，例如事件处理器或者定时器. 箭头函数可以像 bind(..) 一样确保函数的 this 被绑定到指定对象 箭头函数用更常见的词法作用域取代了传统的 this 机制。 注意: 这种情况:1234567891011function module() &#123; return this.x;&#125;var foo = &#123; x: 99, bar:module.bind(this) //此时bind绑定的this为window. &#125;var x="window"console.log(foo.bar())//window 在 ES6 之前我们就已经在使用一种几乎和箭头函数完全一样的模式:12345678910function foo() &#123;var self = this; // lexical capture of this setTimeout( function()&#123; console.log( self.a ); &#125;, 100 ); &#125;var obj = &#123; a: 2&#125;;foo.call( obj ); // 2 虽然 self = this 和箭头函数看起来都可以取代 bind(..)，但是从本质上来说，它们想替代的是 this 机制。(的确是这样,我一般会用me替代self.因为少两个单词=.=) 关于this的编码规范建议: 只使用词法作用域并完全抛弃错误this风格的代码; 完全采用 this 风格，在必要时使用 bind(..)，尽量避免使用 self = this 和箭头函数。 在自己实际工作中,其实是两种混用的,绝大部分情况下都会使用词法作用域风格.因为有时候你真的很难做到完全统一.我现在的习惯是,在写任何函数时,开头第一个就是var me =this;这样在看到函数第一眼,就知道:哦,这个函数是用词法作用域风格的.尤其函数内涉及到回调.这样就避免了写着写着发现this绑定到其他地方去了,一个函数里面this不统一的情况. 2.6 小结(这里总结得很好,我就全部copy了)如果要判断一个运行中函数的 this 绑定，就需要找到这个函数的直接调用位置。找到之后就可以顺序应用下面这四条规则来判断 this 的绑定对象。 由new调用?绑定到新创建的对象。 由call或者apply(或者bind)调用?绑定到指定的对象。 由上下文对象调用?绑定到那个上下文对象。 默认:在严格模式下绑定到undefined，否则绑定到全局对象。 一定要注意，有些调用可能在无意中使用默认绑定规则。如果想“更安全”地忽略 this 绑定，你可以使用一个 DMZ 对象，比如 ø = Object.create(null)，以保护全局对象。 ES6 中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定 this，具体来说，箭头函数会继承外层函数调用的 this 绑定(无论 this 绑定到什么)。这其实和 ES6 之前代码中的 self = this 机制一样。 特别注意: 其中最需要注意的就是当你使用jquery或vue时,此时this是被动态绑定了的.大多数 jQuery 方法将 this 设置为已选择的 dom 元素。使用 Vue.js时，则方法和计算函数通常将 this 设置为 Vue 组件实例。vue文档中所有的生命周期钩子自动绑定 this 上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着你不能使用箭头函数来定义一个生命周期方法 (例如 created: () =&gt; this.fetchTodos())。这是因为箭头函数绑定了父上下文，因此 this 与你期待的 Vue 实例不同，this.fetchTodos 的行为未定义。 也包括使用第三方ajax时,例如axios.解决方法也很简单,要么使用传统的function或者使用let _this=this进行接管.其实当你使用vue时,你默认的思想就是this指的就是vue实例.所以除了钩子函数和axios里会有点影响外,其余还好. PS 这里再补充说明上下文(对象)与函数作用域的区别于联系: 上下文： 可以理解为一个对象，所有的变量都储存在里面.上下文环境是在函数被调用并被引擎执行时创建的.如果你没调用,那么就没有上下文. 作用域： 除了全局作用域，只有函数和ES6新增的let,const才能创建作用域.创建一个函数就创建了一个作用域，无论你调用不调用，函数只要创建了，它就有独立的作用域.作用域控制着被调用函数中的变量访问. 两者: 作用域是基于函数的，而上下文是基于对象的。作用域涉及到所被调用函数中的变量访问，并且不同的调用场景是不一样的。上下文始终是this关键字有关， 它控制着this的引用。一个作用域下可能包含多个上下文。有可能从来没有过上下文（函数没有被调用）；有可能有过，现在函数被调用完毕后，上下文环境被销毁了(垃圾回收)；有可能同时存在一个或多个（闭包）。 第三章 对象3.1 语法对象可以通过两种形式定义:声明(文字)形式(就是常说的对象字面量)和构造形式。 声明形式(对象字面量):1234 var myObj = &#123; key: value // ... &#125;; 构造形式:12var myObj = new Object(); myObj.key = value; 构造形式和文字形式生成的对象是一样的。唯一的区别是，在文字声明中你可以添加多个 键 / 值对，但是在构造形式中你必须逐个添加属性。PS:其实我们绝大部分情况下都是使用对象字面量形式创建对象. 3.2 类型在JavaScript中一共有6中主要类型(术语是”语言类型”) string number boolean null undefined object 简单数据类型:其中string、boolean、number、null 和 undefined属于简单基本类型,并不属于对象.null 有时会被当作一种对象类型，但是这其实只是语言本身的一个 bug，即对 null 执行typeof null 时会返回字符串 “object”。实际上，null 本身是基本类型。PS: 原因是这样的，不同的对象在底层都表示为二进制，在 JavaScript 中二进制前三位都为 0 的话会被判 断为 object 类型，null 的二进制表示是全 0，自然前三位也是 0，所以执行 typeof 时会返回“object”。 对象:对象除了我们自己手动创建的,JavaScript其实内置了很多对象,也可以说是对象的一个子类型.内置对象: String Number Boolean Object Function Array Date RegExp Error 在 JavaScript 中，这些内置对象实际上只是一些内置函数。这些内置函数可以当作构造函数(由 new 产生的函数调用——参见第 2 章)来使用.几点说明: 函数就是对象的一个子类型(从技术角度来说就是“可调用的对象”)。JavaScript 中的函数是“一等公民”，因为它们本质上和普通的对象一样(只是可以调用)，所以可以像操作其他对象一样操作函数(比如当作另一个函数的参数)。 通过字面量形式创建字符串,数字,布尔时,引擎会自动把字面量转换成 String 对象,Number对象,Boolean对象，所以它们是可以访对应对象内置的问属性和方法。 null 和 undefined 没有对应的构造形式，它们只有文字形式。相反，Date 只有构造，没有文字形式。 对于 Object、Array、Function 和 RegExp(正则表达式)来说，无论使用文字形式还是构造形式，它们都是对象，不是字面量(这是肯定的,因为不管哪种形式一创建出来就是对象类型,不可能是其他类型,实际上是不存在字面量这一说的)。但是使用构造形式可以提供一些额外选项(内置)。 Error 对象很少在代码中显式创建，一般是在抛出异常时被自动创建。也可以使用 new Error(..) 这种构造形式来创建，不过一般来说用不着。 3.3 内容对象属性:由一些存储在特定命名位置的(任意类型的)值.属性名:存储在对象容器内部的属性的名称.属性值并不会存在对象内.而是通过属性名(就像指针,从技术角度来说就是引用)来指向这些值真正的存储位置(就像房门号一样).属性名的两种形式: 使用.操作符.也是我们最常用的形式.它通常被称为”属性访问”. . 操作符会要求属性名满足标识符的命名规范. 使用[&quot;..&quot;]语法进行访问.这个通常被称为”键访问”.[&quot;..&quot;]语法可以接受任意UTF-8/Unicode 字符串作为属性名。并且[&quot;..&quot;]语法使用字符串来访问属性,如果你的属性名是一个变量,则可以使用书中的例子myObject[idx]形式进行访问.这也是最常使用”键访问”的情况.但如果idx是属性名则还是需写成myObject[&quot;idx&quot;]字符串形式. 注意: 在对象中，属性名永远都是字符串。如果你使用 string(字面量)以外的其他值作为属性 名，那它首先会被转换为一个字符串。即使是数字也不例外，虽然在数组下标中使用的的 确是数字，但是在对象属性名中数字会被转换成字符串 . 补充: 这里我在书中的例子基础上进行了修改,得到这个例子:123456789var myObject = &#123; a:2, idx:111&#125;;var idx="a";console.log( myObject[idx] ); //2console.log( myObject["idx"] ); //111console.log( myObject[this.idx] ); // 2 此时this是指向window.[]里的this同样符合上一章所讲的规则//结果是否和你所想得一样呢? 3.3.1 可计算属性名ES6 增加了可计算属性名，可以在文字形式中使用 [] 包裹一个表达式来当作属性名:12345678var prefix = "foo";var myObject = &#123; [prefix + "bar"]:"hello", [prefix + "baz"]: "world"&#125;;myObject["foobar"]; // hellomyObject["foobaz"]; // world 3.3.2 属性与方法 我们经常把对象内部引用的函数称为“方法”(的确如此). 实际上函数并不属于该对象,它不过是对函数的引用罢了.对象属性访问返回的函数和其他函数没有任何区别(除了可能发生的隐式绑定this到该对象)。 即使你在对象的文字形式中声明一个函数表达式，这个函数也不会“属于”这个对象—— 它们只是对于相同函数对象的多个引用。 3.3.3 数组 数组支持[]形式访问储存的值,其中[]内的值默认形式为数值下标(为从0开始的整数,也就是常说的索引).例如myArray[0] 数组也是对象，所以虽然每个下标都是整数，你仍然可以给数组添加属性.例如myArray.baz = &quot;baz&quot;.注意:添加新属性后,虽然可以访问,但数组的 length 值不会改变. 数组可以通过myArray[1]=11;myArray[&quot;2&quot;]=22;这种形式对数组内容进行修改,添加. 虽然数组也可以和对象一样通过键/值 对 形式来使用.但JS已经对数组的行为和用途进行了优化.所以还是建议使用默认的下标/值 对 形式来使用. 3.3.4 复制对象 复制分为浅拷贝和深拷贝.浅拷贝会对对象中的基本数据类型进行复制(在内存中开辟新的区域),对于对象则是继续引用.而不是重新创建一个”一样的”对象.深拷贝则是对其中的所有内(容包括对象)进行深层次的复制. 一般情况下我们可以通过JSON来复制对象.var newObj = JSON.parse( JSON.stringify( someObj ) );.但需要指出的是这种方法对于包含function函数或者Date类型的对象则不管用! ES6 定义了 Object.assign(..) 方法来实现浅复制。具体用法在这就不赘述了. 3.3.5 属性描述符从 ES5 开始，所有的属性都具备了属性描述符。 查看属性描述符: 可以使用Object.getOwnPropertyDescriptor( myObject, “a” );方法查看myObject对象里属性a的属性描述符. 配置属性描述符: 可以使用Object.defineProperty(..)方法对属性的属性描述符就像配置.举个例子:123456789 var myObject = &#123;&#125;;Object.defineProperty( myObject, "a", &#123; value: 2, writable: true, configurable: true, enumerable: true &#125; );myObject.a; // 2//该方法可以配置四个属性描述符 注意: 书中关于属性描述符也被称为“数据描述符”其实是不够准确的.对象里目前存在的属性描述符有两种主要形式：数据描述符和存取描述符。数据描述符是一个具有值的属性，该值可能是可写的，也可能不是可写的。存取描述符是由getter和setter函数对描述的属性。描述符必须是这两种形式之一；不能同时是两者。(getter和setter是后面马上要讲到的两个描述符)它们的关系如下:(详情可以查看MDN的解释) configurable enumerable value writable get set 数据描述符 Yes Yes Yes Yes No No 存取描述符 Yes Yes No No Yes Yes 如果一个描述符不具有value,writable,get 和 set 任意一个关键字，那么它将被认为是一个数据描述符。如果一个描述符同时有(value或writable)和(get或set)关键字，将会产生一个异常。 value就是该属性对应的值。默认为 undefined。下面分别介绍剩下的三个属性描述符键值: 1. Writable 决定是否可以修改属性的值。当被设置为false后,再对属性值进行修改,则会静默失败(silently failed,修改不成功,也不报错)了。如果在严格模式下，则会报出TypeError错误. 2. Configurable 决定属性描述符是否可配置.如果为true,就可以使用 defineProperty(..) 方法来修改属性描述符.注意:不管是不是处于严格模式，修改一个不可配置的属性描述符都会出错。并且把 configurable 修改成 false 是单向操作，无法撤销! 但是有个例外即便属性是 configurable:false，我们还是可以 把 writable 的状态由 true 改为 false，但是无法由 false 改为 true。除了无法修改，configurable:false 还会禁止删除这个属性. 3. Enumerable 决定该属性是否会出现在对象的属性枚举中.比如说 for..in 循环。如果把 enumerable 设置成 false，这个属性就不会出现在枚举中，虽然仍然可以正常访问它。相对地，设置成 true 就会让它出现在枚举中。 3.3.6 不变性除了上面提到的Object.defineProperty(..),ES5还可以通过很多种方法来实现属性或者对象的不可变.注意: 这些所有方法都是只能浅不变,如果目标对象引用了其他对象(数组、对象、函数，等)，其他对象的内容不受影响，仍然是可变的.类似于浅拷贝. 说明: 在 JavaScript 程序中很少需要深不可变性。 有些特殊情况可能需要这样做，但是根据通用的设计模式，如果你发现需要密封或者冻结所有的对象，那你或许应当退一步，重新思考一下程序的设计，让它能更好地应对对象值的改变。 方法: 1. 对象常量(不可改) 结合 writable:false 和 configurable:false 就可以创建一个真正的常量属性(不可修改、重定义或者删除) 2. 禁止扩展(不可增) 使用 Object.prevent Extensions(myObject),可以禁止一个对象添加新属性并且保留已有属性.在非严格模式下，创建属性 b 会静默失败。在严格模式下，将会抛出 TypeError 错误。 3. 密封(不可配置,但可修改) 使用Object.seal(..) 会创建一个“密封”的对象，这个方法实际上会在一个现有对象上调用Object.preventExtensions(..) 并把所有现有属性标记为 configurable:false。密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性(虽然可以修改属性的值)。 4. 冻结(不可配置,也不可修改) Object.freeze(..) 会创建一个冻结对象，这个方法实际上会在一个现有对象上调用 Object.seal(..) 并把所有“数据访问”属性标记为 writable:false，这样就无法修改它们的值。这个方法是你可以应用在对象上的级别最高的不可变性，它会禁止对于对象本身及其任意直接属性的修改(不过就像我们之前说过的，这个对象引用的其他对象是不受影响的)。 注意: 你可以“深度冻结”一个对象(连引用的对象也冻结)，具体方法为，首先在这个对象上调用 Object.freeze(..)， 然后遍历它引用的所有对象并在这些对象上调用 Object.freeze(..)。但是一定要谨慎!因为你引用的对象可能会在其他地发也被引用. 说明: 在 JavaScript 程序中很少需要深不可变性。有些特殊情况可能需要这样做， 但是根据通用的设计模式，如果你发现需要密封或者冻结所有的对象，那你或许应当退一步，重新思考一下程序的设计，让它能更好地应对对象值的改变。 3.3.7 [[Get]]1234var myObject = &#123; a: 2&#125;;myObject.a; // 2 myObject.a是怎么取到值2的?myObject.a 通过对象默认内置的[[Get]] 操作(有点像函数调用:[Get]).首先它会在对象中查找是否有名称相同的属性， 如果找到就会返回这个属性的值。如果没有找到名称相同的属性，按照 [[Get]] 算法的定义会执行另外一种非常重要的行为。其实就是遍历可能存在的 [[Prototype]] 链，也就是在原型链上寻找该属性。如果仍然都没有找到名称相同的属性，那 [[Get]] 操作会返回值 undefined. 注意: 如果你引用了一个当前词法作用域中不存在的变量，并不会像对象属性一样返回 undefined，而是会抛出一个 ReferenceError 异常. 3.3.8 [[Put]]既然有可以获取属性值的 [[Get]] 操作，就一定有对应的 [[Put]] 来设置或者创建属性. [[Put]] 被触发时的操作分为两个情况:1. 对象中已经存在这个属性 2. 对象中不存在这个属性. 如果对象中已经存在这个属性,[[Put]] 算法大致会检查下面这些内容: 属性是否是访问描述符(参见下一节)?如果是并且存在setter就调用setter。 属性的数据描述符中writable是否是false?如果是，在非严格模式下静默失败，在严格模式下抛出 TypeError 异常。 如果都不是，将该值设置为属性的值。 如果对象中不存在这个属性，[[Put]] 操作会更加复杂。会在第 5 章讨论 [[Prototype]] 时详细进行介绍。 3.3.9 Getter和Setter对象默认的 [[Put]] 和 [[Get]] 操作分别可以控制属性值的设置和获取。目前我们还无法操作[[Get]] 和 [[Put]]来改写整个对象 ,但是在ES5中可以使用 getter 和 setter 改写部分默认操作,只能应用在单个属性上，无法应用在整个对象上。 注意: 书中后面说的访问描述符就是存取描述符.关于属性描述符,存取描述符及数据描述符可以查看MDN的解释) getter:getter 是一个隐藏函数，会在获取属性值时调用。同时会覆盖该单个属性默认的 [[Get]]操作.当你设置getter时,不能同时再设置value或writable,否则就会产生一个异常.并且当你设置getter或setter时,JavaScript 会忽略它们的 value 和 writable 特性. 语法: {get prop() { ... } }或{get [expression]() { ... } }.其中prop:要设置的属性名. expression:从 ECMAScript 2015 开始可以使用计算属性名.使用方式:123456789101112131415161718192021222324var myObject = &#123; a: 1111, //在后面会发现myObject.a为2,这是因为设置了getter所以忽略了value特性. //方式一:在新对象初始化时定义一个getter get a() &#123; return 2 &#125;&#125;;Object.defineProperty( myObject, // 目标对象 "b", // 属性名 &#123; // 方式二:使用defineProperty在现有对象上定义 getter get: function()&#123; return this.a * 2 &#125;, // 确保 b 会出现在对象的属性列表中 enumerable: true &#125;);myObject.a = 3; //因为设置了getter所以忽略了writable特性.所以这里赋值没成功myObject.a; // 2myObject.b; // 4delete myObject.a;//可以使用delete操作符删除 setter:setter 是一个隐藏函数，会在获取属性值时调用。同时会覆盖该单个属性默认的 [[Put]]操作(也就是赋值操作).当你设置setter时,不能同时再设置value或writable,否则就会产生一个异常.并且当你设置getter或setter时,JavaScript 会忽略它们的 value 和 writable 特性. 语法: {set prop(val) { . . . }}或{set [expression](val) { . . . }}.其中prop:要设置的属性名. val:用于保存尝试分配给prop的值的变量的一个别名。expression:从 ECMAScript 2015 开始可以使用计算属性名.使用方式:1234567891011121314151617181920212223242526272829303132var myObject = &#123; //注意:通常来说 getter 和 setter 是成对出现的(只定义一个的话 通常会产生意料之外的行为): //方式一:在新对象初始化时定义一个setter set a(val) &#123; this._a_ = val * 2 &#125;, get a() &#123; return this._a_ &#125;&#125;;Object.defineProperty( myObject, // 目标对象 "b", // 属性名 &#123; set: function(val)&#123; this._b_ = val * 3 &#125;, // 方式二:使用defineProperty在现有对象上定义 setter get: function()&#123; return this._b_ &#125;, // 确保 b 会出现在对象的属性列表中 enumerable: true &#125;);myObject.a = 2; myObject.b = 3; console.log(myObject.a); //4console.log(myObject.b);//9console.log(myObject._a_);//4console.log(myObject._b_);//9delete myObject.a;//可以使用delete操作符删除 3.3.10 存在性属性存在性:如何判断一个对象是否存在某个属性(准确来说是检查这个属性名是否存在),这时就需要用到: in操作符in 操作符会检查属性是否在对象及其 [[Prototype]] 原型链中(参见第 5 章)。 hasOwnProperty(..)hasOwnProperty(..) 只会检查属性是否在 myObject 对象中，不会检查 [[Prototype]] 链。 注意: 1.如果有的对象可能没有连接到 Object.prototype( 通过Object. create(null) 来创建——参见第 5 章)。在这种情况下，形如myObejct.hasOwnProperty(..) 就会失败。这时可以使用一种更加强硬的方法来进行判断:Object.prototype.hasOwnProperty. call(myObject,”a”)，它借用基础的 hasOwnProperty(..) 方法并把它显式绑定(参见第2章)到 myObject 上。 2.对于数组来说,不要使用in操作符,因为它检查的是属性名,在数组中属性名就是索引,它并不是我们所关注的重点.对于数组我们更关注的是它所存的值,所以对于数组检查某个值是否存在还是采用indexOf方法. 属性可枚举性:如果一个属性存在,且它的enumerable 属性描述符为true时.则它是可枚举的.并且可以被for..in 循环.一个属性不仅仅需要存在,还需要它的enumerable 为true才是可枚举的,才能被for…in遍历到.注意: for…in不适合对数组进行遍历,对数组的遍历还是使用传统的for循环. 对属性的可枚举性判断,则需要用到以下几种方法: propertyIsEnumerable(..) 会检查给定的属性名是否直接存在于对象中(而不是在原型链上)并且满足 enumerable:true。 Object.keys(..) 会返回一个数组，包含所有可枚举属性. Object.getOwnPropertyNames(..)会返回一个数组，包含所有属性，无论它们是否可枚举。 3.4 遍历关于这节我觉得还是以理清for..in和for..of为主.后面延伸的@@iterator及Symbol.iterator的使用,没必要过于深究.注意书中123页第二行done 是一个布尔值，表示是否还有可以遍历的值。有个错误,应该改成done 是一个布尔值，表示遍历是否结束。否则你在看后面它的说明时会感觉到自相矛盾.这里我也是以for..in和for..of为主进行说明,也更贴近我们实际使用. for..in for..in 循环可以用来遍历对象的可枚举属性列表(包括 [[Prototype]] 链)。 实际上for..in遍历的并不是属性值,而是属性名(即键名 key).所以你想获取属性值还是需要手动使用obj[key]来获取. 一般在遍历对象时,推荐使用for..in.当然数组也是可以使用for..in的.在遍历数组时,推荐还是使用for..of. for..of ES6 增加了一种用来遍历数组的 for..of 循环语法(如果对象本身定义了迭代器的话也可以遍历对象) for..of与for..in最大的不同点是,它循环的是属性值,而不是属性名.不过它只循环数组里存放的值,不会涉及到对象里的key.(关于这个我后面的例子里会说具体对比明的) for..of 循环首先会向被访问对象请求一个迭代器对象，然后通过调用迭代器对象的next() 方法来遍历所有返回值。数组有内置的 @@iterator，(对象没有,所以不能使用for..of,除非我们自己定义一个)因此 for..of 可以直接应用在数组上。 例子比较1234567891011let arr = ['shotCat',111,&#123;a:'1',b:'2'&#125;]arr.say="IG niu pi!"//使用for..in循环for(let index in arr)&#123; console.log(arr[index]);//shotCat 111 &#123;a:'1',b:'2'&#125; IG niu pi!&#125;//使用for..of循环for(var value of arr)&#123; console.log(value);//shotCat 111 &#123;a:'1',b:'2'&#125;&#125;//注意 for..of并没有遍历得到` IG niu pi!`.原因我前面说过`它只循环数组里存放的值,不会涉及到对象里的key.`更不用说 [[Prototype]] 链.(for..in则会) 如何让对象也能使用for..of ?你可以选择使用书中的自己通过Object.defineProperty()定义一个Symbol.iterator属性来实现.这里我就不赘述了.也是最接近原生使用感受的.不过我这里要介绍一个稍微简单点的方法来实现.就是使用上节讲到的Object.keys()搭配使用.举个例子:12345678910111213var shotCat=&#123; name:'shotCat', age:'forever18', info:&#123; sex:'true man', city:'wuhan', girlFriend:'新垣结衣!' &#125;&#125;for(var key of Object.keys(shotCat))&#123; //使用Object.keys()方法获取对象key的数组 console.log(key+": "+shotCat[key]);&#125; 3.5 小结书中小结总结得挺全的,这里我就搬运下 JavaScript 中的对象有字面形式(比如 var a = { .. })和构造形式(比如 var a = new Array(..))。字面形式更常用，不过有时候构造形式可以提供更多选项。 对象是 6 个(或者是 7 个，取决于你的观点)基础类型之一。对象有包括 function 在内的子类型，不同子类型具有不同的行为，比如内部标签 [object Array] 表示这是对象的子类型数组。 对象就是键 / 值对的集合。可以通过 .propName 或者 [“propName”] 语法来获取属性值。访问属性时，引擎实际上会调用内部的默认 [[Get]] 操作(在设置属性值时是 [[Put]])， [[Get]] 操作会检查对象本身是否包含这个属性，如果没找到的话它还会查找 [[Prototype]] 链(参见第 5 章)。 属性的特性可以通过属性描述符来控制，比如 writable 和 configurable。此外，可以使用 Object.preventExtensions(..)、Object.seal(..) 和 Object.freeze(..) 来设置对象(及其属性)的不可变性级别。 属性不一定包含值——它们可能是具备 getter/setter 的“访问描述符”。此外，属性可以是可枚举或者不可枚举的，这决定了它们是否会出现在 for..in 循环中。 可以使用 ES6 的 for..of 语法来遍历数据结构(数组、对象，等等)中的值，for..of 会寻找内置或者自定义的 @@iterator 对象并调用它的 next() 方法来遍历数据值。 第四章 混合对象”类”注意: 正如书中提示的那样,整章一半以上几乎都是讲面向对象和类的概念.会读得人云里雾里,给人哦,也许大概就是这样子的感觉.后面我还是会对那些抽象的概念找到在JavaScript里对应的”立足点”,不至于对这些概念太”飘”. 4.1 类理论说明: 类其是描述了一种代码的组织结构形式. 在js中类常见的就是构造函数,也可以是通过ES6提供的class关键字;继承就是函数;实例化就是对象,常见的就是通过new构造函数实现的. 注意: Javascript语言不支持“类”，所谓的”类”也是模拟出的“类”。即使是ES6引入的”类”实质上也是 JavaScript 现有的基于原型的继承的语法糖。 4.1.1 “类”设计模式一句话:类其实也是一种设计模式! 类并不是必须的编程基础,而是一种可选的代码抽象. 有些语言(比如 Java)并不会给你选择的机会，类并不是可选的——万物皆是类。 其他语言(比如 C/C++ 或者 PHP)会提供过程化和面向类这两种语法，开发者可以选择其中一种风格或者混用两种风格。 4.1.2 JavaScript中的“类”JavaScript 只有一些近似类的语法元素 (比如 new 和 instanceof)，不过在后来的 ES6 中新增了一些元素，比如 class 关键字,其实质上也是 JavaScript 现有的基于原型的继承的语法糖。也不是真正的类. 4.2 类的机制这部分书中的描述,我理解起来也比较费劲,主要是它提到的栈,堆与我理解中内存里的栈,堆相冲突了.这里简单说下我的理解,如有误,感激指正. stack类其实是一种数据结构.它可以储存数据,并提供一些公用的方法(这和上面提到的类很相似).但是stack类其实只是一个抽象的表示,你想对它进行操作,就需要先对它进行实例化. 4.2.1 建造这节主要就是说明”类”和”实例”的关系.在JavaScript里”类”主要是构造函数,”实例”就是对象. 一个类就像一张蓝图。为了获得真正可以交互的对象，我们必须按照类来实例化一个东西，这个东西(对象)通常被称为实例，有需要的话，我们可以直接在实例上调用方法并访问其所有公有数据属性。 总而言之:类通过实例化得到实例对象. 4.2.2 构造函数 类实例是由一个特殊的类方法构造的，这个方法名通常和类名相同，被称为构造函数。 实例就是由构造函数实例化的: new 构造函数. 构造函数大多需要用 new 来调，这样语言引擎才知道你想要构造一个新的类实例。 构造函数会返回一个对象,这个对象就是实例.这个对象可以调用类的方法. 4.3 类的继承在面向类的语言中，你可以先定义一个类，然后定义一个继承前者的类。后者通常被称为“子类”，前者通常被称为“父类”。子类可以继承父类的行为,并且可以根据自己的需求,修改继承的行为(一般并不会修改父类的行为).注意:我们讨论的父类和子类并不是实例,在JavaScript里类一般都是构造函数。 4.3.1 多态大概你看了它的”解释”,对多态还是懵懵懂懂.这里我再解释下:什么是多态?同一个操作，作用于不同的对象，会产生不同的结果。发出一个相同的指令后，不同的对象会对这个指令有不同的反应，故称为多态。说明: 书中例子中的inherited其实就是相当于super.并且注意书中的这些例子都是伪代码! 并不是真的在JavaScript里就是这样实现的.补充:这里是关于super的mdn链接. 多态: 相对性: 其实相对性就是子类相对于父类的引用(例如使用super实现引用),并且子类对父类的引用并不会对父类的行为造成任何影响(并不会对父类自身的行为进行重新定义),例如书中例子子类对drive()的引用. 可重复定义: 子类继承父类的某个方法,并可以对这个方法进行再次定义,例如书中子类对drive()中的output进行修改.当调用方法时会自动选择合适的定义,这句话怎么理解,当子类实例化后,执行drive()方法时,它并不会直接去执行父类的drive().而是子类上的drive().简单来说就是实例来源于那个类,它就使用那个类的方法. 说明: 在 JavaScript 中“类”是属于构造函数的(类似 Foo.prototype… 这样的类型引用)。由于 JavaScript中父类和子类的关系只存在于两者构造函数对应的 .prototype 对象中，因此它们的构造函数之间并不存在直接联系，从而无法简单地实现两者的相对引用(在 ES6 的类中可以通过 super来“解决”这个问题，参见附录 A)。 多态并不表示子类和父类有关联，子类得到的只是父类的一份副本。类的继承其实就是复制。 其实这里讨论的这些概念其实在我们实际工作中,已经使用了无数次,只是现在你需要理解”原来你是叫这个名字啊!” 4.3.2 多重继承多重继承: 一个子类可以继承来自多个父类的方法.多重继承引发的问题: 多重继承可能会出现,多个父类中方法名冲突的问题,这样子类到底引用哪个方法?多重继承与JavaScript: JavaScript本身并没有提供多重继承功能.但它可以通过其他方法来达到多重继承的效果. 4.4 混入JavaScript 中只有对象，并不存在可以被实例化的“类”。一个对象并不会被复制到其他对象，它们会被关联起来(参见第 5 章)(其实就是引用,所以它的多态是”相对”的)。由于在其他语言中类表现出来的都是复制行为，因此 JavaScript 开发者也想出了一个方法来模拟类的复制行为，这个方法就是混入(就是通过混入来模拟实现类的多重继承)。 4.4.1 显式混入郑重提醒: 书中这里的类都是对象形式的.例子里的sourceObj, targetObj,这就可能造成一个”误导”,在JavaScript里是没有真正的类,所谓的类也不过是我们模拟出来的”类”,不过是一种语法糖(包括ES6里的class).在JavaScript里”所谓的类”经常是一个构造函数,你并不能这样进行遍历,只能对它的实例对象进行这种操作.不要被书中例子带进去了,不要混淆,毕竟我们最终使用的是JavaScript(而不是其他面向对象的语言.),它里面的类常常并不是一个对象! 显式混入: 书中没有给出明确的显式混入的定义,但是读完整章.基本就知道什么是显式混入了.显式混入就是通过类似mixin()方法,显式地将父对象属性逐一复制,或者有选择地复制(即例子中的存在性检查)到子对象上. 显式混入常用方法: 就是书中的例子, 首先有子对象,并对其进行特殊化(定义自己的属性或方法).然后再通过mixin()方法将父对象有选择地复制(即存在性检查,过滤子对象已有的属性,避免冲突)到子对象上. 显式混入注意点:显式混入时,切记一点你要避免父对象的属性与子对象特殊化的属性冲突.这就是为什么例子中要进行存在性检查,以及后面要说的混合复制,可能存在的重写风险. 1. 再说多态(其实说的就是js里的多态)显式多态: 将父对象里的方法通过显式绑定到子对象上.就是显式多态.例如书中的例子:Vehicle.drive.call( this )。显式多态也是为了JS来模拟实现多重继承的!说明: 在ES6之前是没有相对多态的机制。所以就使用call这种进行显式绑定实现显式动态.注意JavaScript里实现多态的方法也被称为”伪多态”.所以不要对后面突然冒出的伪多态概念而一脸懵逼(其实整本书经常做这样的事) 显式多态(伪多态)的缺陷: 因为在JavaScript 中存在屏蔽(实际是函数引用的上下文不同),所以在引用的时候就需要使用显式伪多态的方法创建一个函数关联. 这些都会增加代码的复杂度和维护难度(过多的this绑定,真的会让代码很难读)。 2. 混合复制(显式混入另一种不常用方法)前面的显式混入的方法是先有子对象并进行特殊化,然后再有选择地复制父对象属性.这个不常用的方法则是反过来的,结合书中例子,它先用一个空对象完全复制父对象的属性,然后该对象复制特殊化对象的属性,最后得到子对象.这种方法明显是比第一种麻烦的,并且在复制特殊化对象时,可能会对之前重名的属性(即复制得到的父对象属性)进行重写覆盖.所以这种方法是存在风险,且效率低下的. 显式混入的缺陷: 无法做到真正的复制: 如果复制的对象中存在对函数的引用,那么子对象得到的是和父对象一样的,对同一个函数的引用.如果某个子对象对函数进行了修改,那么父对象及其他子对象都会受到影响.很明显这是不安全的.原因是JavaScript 中的函数无法进行真正地复制，你只能复制对共享函数对象的引用. 函数名和属性名同名: 如果混入多个对象,则可能会出现这种情况.目前现在仍没有比较好的方式来处理函数和属性的同名问题(提问:这种情况下谁的优先级更高?滑稽脸)。 3. 寄生继承显式混入模式的一种变体被称为“寄生继承”，它既是显式的又是隐式的.首先会复制一份父类(对象)的定义，然后混入子类(对象)的定义(如果需要的话保留到父类的特殊引用)，然后用这个复合对象构建实例。说明: 寄生继承与混合复制是很相似的,最大的区别是寄生继承是通过实例化构造函数(JS中的”类”)来实现复制的. 4.4.2 隐式混入隐式混入: 它与显示混入最大的区别,就是它没有明显的对父类(对象)属性进行复制的过程.它是通过在构造函数调用或者方法调用中使用显式绑定例如: Something.cool.call( this)来实现混入(多重继承).其本质就是通过改变this指向来实现混入. 4.5 小结整章的重点其实就是让你理解什么叫类.除了最后一小节的混入和JavaScript有那么一点点关系.其余的小结和JavaScript都没什么关系.重要的是理解类这种思想和设计模式.重点: 1.类意味着复制! 传统的类被实例化时，它的行为会被复制到实例中。类被继承时，行为也会被复制到子类中。 多态(在继承链的不同层次名称相同但是功能不同的函数)看起来似乎是从子类引用父类，但是本质上引用的其实是复制的结果。 JavaScript 并不会(像类那样)自动创建对象的副本。(你只能自己手动复制,而且复制的还不彻底!) 混入模式(无论显式还是隐式)可以用来模拟类的复制行为，但是通常会产生丑陋并且脆弱的语法，比如显式伪多态(OtherObj.methodName.call(this, …))，这会让代码更加难 懂并且难以维护。 显式混入实际上无法完全模拟类的复制行为，因为对象(和函数!别忘了函数也是对象)只能复制引用，无法复制被引用的对象或者函数本身。忽视这一点会导致许多问题。 在 JavaScript 中模拟类是得不偿失的，虽然能解决当前的问题，但是可能会埋下更多的隐患。(但实际,我们用得却很多) 第五章 原型注意:本章的前提是你已经比较熟悉原型及原型链.不太熟或者不知道的可以,通过这篇文章熟悉下. 5.1 [[Prototype]]JavaScript 中的对象有一个特殊的 [[Prototype]] 内置属性，其实就是对于其他对象的引用(一般就是其构造函数prototype属性的引用)。几乎所有的对象在创建时 [[Prototype]] 属性都会被赋予一个非空的值。吐槽: 书中有这样一句话 “注意:很快我们就可以看到，对象的 [[Prototype]] 链接可以为空，虽然很少见。”我前前后后看了三遍都没找到它所说的对象的 [[Prototype]] 链接可以为空.的情况!应该是作者写忘记了.ok,这里我来说下对象的 [[Prototype]] 链接可以为空的情况.就是通过Object.create(null)得到的对象.它的 [[Prototype]] 是为空的.应该说它的所有都是空的.为什么?因为null是原型链的顶端.它是没有[[Prototype]]的.对应的可以对比下console.log(Object.create({}))和console.log(Object.create(null)) [[Prototype]]有什么用?我原以为作者会说可以作为存放实例对象的公共属性,然后像类一样讲得更深刻点.不过这次只是说了它表明的作用. 作用: 就是存放哪些不在对象自身的属性. 当我们访问一个对象的属性时,此时对象的内部默认操作[[Get]],首先会检查对象本身是否有这个属性，如果有的话就使用它。如果没有的话,[[Get]] 就会继续访问对象的 [[Prototype]] 链.([[Prototype]]其实就是其构造函数的prototype属性.也是一个对象.)如果找到,就返回该属性值.如果没有就继续寻找下一个[[Prototype]]链.直到找完整条[[Prototype]]链.还是没有的话,[[Get]] 就会返回undefined. 补充: 使用 for..in 遍历对象时 任何可以通过原型链访问到 (并且是 enumerable:true)的属性都会被枚举。(其实这个在第三章里我说过) 使用 in 操作符 同样会查找对象的整条原型链(无论属性是否可枚举) 5.1.1 Object.prototype所有普通的 [[Prototype]] 链最终都会指向内置的 Object.prototype。(Object.prototype的[[Prototype]] 最终会指向null.null就是最后的终点).这个 Object.prototype 对象，包含了 JavaScript 中许多通用的功能,例如:toString() , valueOf(), hasOwnProperty(..)和 isPrototypeOf(..)。 5.1.2 属性设置和屏蔽说明: 看完本节时,切记不要对myObject.foo = &quot;bar&quot;这种简单的对象属性赋值产生顾虑和疑惑.这种赋值绝对不会对原型链产生任何影响!基本也不会出现赋值不成功的情况.如果有人敢在团队项目里修改对象的属性描述符,早就被拖出去打死了!!! 这部分可以看做补充知识,知道有这些奇葩设定就行.其实这节更应该关注的是myObject.foo的返回值.注意: 书中提到的动词屏蔽其实指的就是在对象上创建同名属性(原型链上已有该属性).注意不要被绕晕了.还有++就相当于myObject.a=myObject.a+1,注意分解就行,不存在什么特别需要当心的. 5.2 “类” JavaScript里只有对象,没有类! JavaScript不需要通过类来抽象对象.而是自己直接创建对象,并定义对象的行为. 5.2.1 “类”函数吐槽:模仿类竟然被说成奇怪的无耻滥用!?不这样做,js那些高级用法怎么实现?怎么会有现在前端的百花齐放(轮子满地跑)?这也是冒得办法的办法啊!毕竟当时js只是小众,不指望它有多大能耐.毕竟只是一个人用7天”借鉴”出来的东西. “类”函数: JavaScript用来模仿类的函数就被称为类函数,其实就是我们常说的构造函数. “类”函数模拟类的关键: 所有的函数默认都会拥有一个名为 prototype 的公有并且不可枚举(参见第 3 章)的属性，它会指向另一个对象.当我们通过new 函数(构造函数)来得到实例对象时,此时new会给实例对象一个内部的 [[Prototype]]属性，实例对象内部的[[Prototype]]属性与构造函数的prototype属性都指向同一个对象.那JS的这个特性怎么模拟类呢?首先类的本质就是复制!.明白这点后,我们就需要实现伪复制.我们可以将类里的属性,放在函数的prototype属性里.这样该函数的实例对象就可以通过[Prototype]访问这些属性.我们也经常把这种行为称为原型继承(作者后面会疯狂吐槽这个称呼,我后面再解释为什么吐槽).这样就实现了伪”复制”. 可以达到和类相似的效果. 注意: 虽然说所有的函数默认都会拥有一个名为 prototype属性.但也有特殊的时候.就不是默认的情况.就是通过bind()硬绑定时.所返回的绑定函数,它是没有prototype属性的! 图解真正的类与JS的模拟类: 关于原型继承这个名字的疯狂吐槽: 作者的吐槽主要集中在”继承”两个字,原因是在面向类的语言中,”继承”意味着复制,但在JavaScript里原型继承却根本不是这个意思,它并没有复制,而是用原型链来实现.所以疯狂吐槽其误导. 什么是差异继承? 我根本没听过这个术语,初次看作者所谓的解释,这是啥?他想说啥?后来读了好多遍,终于大概理解了.如果你也看不懂作者想在表达什么,就pass这部分.没必要理解.反而会把你看得更迷惑.好了,我来解释下什么叫差异继承.差异继承就是原型继承的一个不常用的别名.我们知道对象可以通过原型链继承一部分属性,但我们仍可以给对象设置其他有差异不同的属性.这也就可以称为差异继承. 5.2.2 “构造函数”构造函数之所以是构造函数,是因为它被new调用,如果没被new调用,它就是一个普通函数.实际上,new会劫持所有普通函数并用构造对象的形式来调用它,并且无论如何都会构造返回一个对象. 5.2.3 技术关于两种“面向类”的技巧,我这就不说明了,理解了这部分第一第二章关于this的使用,就很简单了. prototype.constructor:为了正确理解constructor.我特意在标题上加上prototype.是想强调:一个对象访问constructor时,会默认访问其原型对象上的constructor属性. 注意:12345678910111213function Foo() &#123; /* .. */ &#125;Foo.prototype = &#123; /* .. */ &#125;; // 有时候我们会需要创建一个新原型对象,因此也不会有默认的constructor属性指向构造函数// 需要在 Foo.prototype 上“修复”丢失的 .constructor 属性// 关于 defineProperty(..)，参见第 3 章 Object.defineProperty( Foo.prototype, "constructor" , &#123; enumerable: false,//不可枚举 writable: true, configurable: true, value: Foo // 让 .constructor 指向 Foo&#125; );//上面这种方法是比较严谨,也比较麻烦的.并且使用Object.defineProperty()风险是很大的.//所以我们实际是这样修改的Foo.prototype.constructor=Foo; //直接将其赋值Foo 唯一要注意的是此时constructor是可枚举的.会被实例对象的for..in..遍历到. 5.3 (原型)继承原型对象到原型对象的继承:例如:Bar.prototype 到 Foo.prototype 的委托关系，正确的JavaScript中“原型风格”:1234567891011121314151617181920212223function Foo(name) &#123; this.name = name;&#125;Foo.prototype.myName = function() &#123; return this.name;&#125;;function Bar(name,label) &#123; Foo.call( this, name ); this.label = label;&#125;// 我们创建了一个新的 Bar.prototype 对象,并且它的[[Prototype]] 关联Foo.prototype Bar.prototype = Object.create( Foo.prototype );// 注意!Object.create()是返回一个新的对象,所以现在没有 Bar.prototype.constructor 了 // 如果你需要这个属性的话可能需要手动修复一下它Bar.prototype.myLabel = function() &#123; return this.label;&#125;;var a = new Bar( "a", "obj a" );a.myName(); // "a"a.myLabel(); // "obj a" 错误用法: 1, Bar.prototype = Foo.prototype; 此时并不会创建一个关联到 Bar.prototype 的新对象，它只是让 Bar.prototype 直接引用 Foo.prototype 对象。 因此当你执行类似 Bar.prototype. myLabel = … 的赋值语句时会直接修改 Foo.prototype 对象本身。 2, Bar.prototype = new Foo(); 它使用 了 Foo(..) 的“构造函数调用”，如果函数 Foo 有一些其他操作的话,尤其是与this有关的的话，就会影响到 Bar() 的“后代”，后果不堪设想。 结论: 要创建一个合适的关联对象，我们需使用 Object.create(..) 而不是使用具有副作用的 Foo(..)。这样做唯一的缺点就是需要创建一个新对象然后把旧对象抛弃掉(主要是需要手动设置constructor)，不能直接修改已有的默认对象。 检查”类”关系 instanceof 操作符: 验证左边的普通对象的整条[[prototype]]链是否有指向右边函数的prototype,例如:a instanceof Foo。 isPrototypeOf(..) 方法: 验证在对象 a 的整条 [[Prototype]] 链中是否出现过 原型对象b.例如:b.isPrototypeOf( a ); 注意: 如果使用内置的 .bind(..) 函数来生成一个硬绑定函数(参见第 2 章)的话， 该函数是没有 .prototype 属性的。如果硬绑定函数instanceof 的话,则其bind的 目标函数的prototype会成为硬绑定函数的prototype. 关于proto:我们知道函数可以直接通过prototype属性直接访问原型对象.那对象怎么访问呢?我们知道是通过[[prototype]]链.怎么访问呢?在ES5之中的标准方法:通过Object.getPrototypeOf( )方法来获取对象原型.Object.getPrototypeOf( a ) === Foo.prototype; // true,另一种方法:在 ES6 之前并不是标准,但却被绝大多数浏览器支持的一种方法,可以访问内部[[prototype]]对象.那就是__proto__.例如:a.__proto__ === Foo.prototype; // true.你甚至可以通过.__proto__.__ptoto__...来访问整个原型链. .__proto__实际上并不存在于你正在使用的对象中.并且它看起来很像一个属性，但是实际上它更像一个 getter/setter(见第三章). 5.4 对象关联[[Prototype]] 机制就是存在于对象中的一个内部链接，它会引用其他对象。 这个链接的作用是:如果在对象上没有找到需要的属性或者方法引用，引擎就会继续在 [[Prototype]] 关联的对象上进行查找。同理，如果在后者中也没有找到需要的 引用就会继续查找它的 [[Prototype]]，以此类推。这一系列对象的链接被称为原型链。 5.4.1 创建关联问:“我们已经明白了为什么 JavaScript 的 [[Prototype]] 机制和类不一样，也明白了它如何建立对象间的关联。”答: 类的机制是复制,JavaScript里原型链的机制是引用. 问:“那 [[Prototype]] 机制的意义是什么呢?为什么 JavaScript 开发者费这么大的力气(模拟类)在代码中创建这些关联呢?”答: 意义就是模拟类,JavaScript不需要复制(我觉得这不是个优点)而通过原型链实现”实例”对”类”的”继承(其实就是引用)”.这样就达到了实例对象对某些属性(即原型对象里的属性)的复用. Object.create(..)这个方法其实我们在前面已经使用过很多次.”Object.create(..) 会创建一个新对象(bar)并把它关联到我们指定的对象(foo)，这样我们就可以充分发挥 [[Prototype]] 机制的威力(委托)并且避免不必要的麻烦(比如使用 new 的构造函数调用会生成 .prototype 和 .constructor 引用)。”实际上这个方法就是创建返回一个新对象,这个新对象的原型([[Prototype]])会绑定为我们输入的参数对象foo.并且由于不是通过构造函数的形式,所以不需要为函数单独设置prototype.虽然Object.create(..)很好,但实际我们使用的更多的还是构造函数形式.注意: Object.create(..) 的第二个参数指定了需要添加到新对象中的属性名以及这些属性的属性描述符(参见第 3 章)。 Object.create(null)这个方法其实我们在前面也讲解过几次.”Object.create(null) 会创建一个拥有空(或者说null)[[Prototype]] 链接的对象，这个对象无法进行委托。由于这个对象没有原型链，所以 instanceof 操作符(之前解释过)无法进行判断，因此总是会返回 false。 这些特殊的空 [[Prototype]] 对象通常被称作“字典”，它们完全不会受到原型链的干扰，因此非常适合用来存储数据。“ “Object.create()的polyfill代码.”这部分我就不做解读了,因为现在都8102年,es6早就普及了,你几乎不可能再用到es5之前的语法了.所以这部分大家了解下即可. 5.4.2 关联关系是备用[[Prototype]] 的本质作用: 书中提到了一个观点”处理“缺失”属性或者方法时的一种备用选项。”(即备用设计模式).但随后进行了否定”但是这在 JavaScript 中并不是很常见。所以如果你使用的是这种模式，那或许应当退后一步并重新思考一下这种模式是否合适。” 作者给出的观点是:”进行委托设计模式,即例子中的内部委托(就是在对象里套了个壳再引用了一遍,为的是将委托进行隐藏).这样可以使我们的API设计得更加清晰.”文中的清晰是指,当我们需要引用原型对象的属性方法时,我们在对象内部设置对应专门的属性(例子中的doCool),进行内部委托(其实就是套个壳进行隐藏).这样我们对象的属性就是”完整”的. 在实际工作中,我们常常就是把原型对象作为存放对象的公共属性方法的地方.对于一般比较重要的操作才会在对象里进行内部委托(隐藏委托)! 5.5 小结总结得很好很全面,这里我还是直接摘抄了,不是偷懒哦! 如果要访问对象中并不存在的一个属性，[[Get]] 操作(参见第 3 章)就会查找对象内部[[Prototype]] 关联的对象。 这个关联关系实际上定义了一条“原型链”(有点像嵌套的作用域链)，在查找属性时会对它进行遍历。 所有普通对象都有内置的 Object.prototype， 指向原型链的顶端(比如说全局作用域)，如 果在原型链中找不到指定的属性就会停止。toString()、valueOf() 和其他一些通用的功能 都存在于 Object.prototype 对象上，因此语言中所有的对象都可以使用它们。 关联两个对象最常用的方法是使用 new 关键词进行函数调用，在调用的 4 个步骤(第 2 章)中会创建一个关联其他对象的新对象。 使用 new 调用函数时会把新对象的 .prototype 属性关联到“其他对象”(就是构造函数prototype所指的对象)。带 new 的函数调用 通常被称为“构造函数调用”，尽管它们实际上和传统面向类语言中的类构造函数不一样。 JavaScript 中的机制有一个核心区别，那就是不会进行复制，对象之间是通过内部的 [[Prototype]] 链关联的。 “委托”是一个更合适的术语，因为对象之间的关系不是复制而是委托。(意思就是原先继承应该改为原先委托?) 第六章 行为委托第 5 章的结论:[[Prototype]] 机制就是指对象中的一个内部链接引用另一个对象。换句话说，JavaScript 中这个机制的本质就是对象之间的关联关系。在第六章又被称为委托.PS:前面在讲原型的时候我就习惯用父对象指代原型对象(类似”父类”),用子对象指代其实例对象(类似”子类”).本章也将采用这种称呼,故下面不再说明.(其实我觉得用父对象和子对象称呼更形象) 6.1 面向委托的设计一句话:[[Prototype]]机制是面向委托的设计,是不同于面向类的设计. 下面将分别介绍类理论和委托理论. 6.1.1 类理论类理论设计方法: 首先定义一个通用父(基)类，在 父类类中定义所有任务都有(通用)的行为。接着定义子类 ，它们都继承自 父类并且会添加一些特殊的行为来处理对应的任务,并且在继承时子类可以使用方法重写(和多态)父类的行为. 类理论中许多行为可以先“抽象”到父类然后再用子类进行特殊化(重写)。ps:这部分了解即可,着重理解下面JavaScript用到的委托. 6.1.2 委托理论类理论设计方法: 首先你会定义一个”父”对象(相当于上节中的父类)，它会包含所有任务都可以使用(委托)的具体行为。接着，对于每个任务你都可以定义一个对象(“子”对象)来存储对应的数据和行为。你可以把特定的任务对象都关联到父对象上，让它们在需要的时候可以进行委托。 (其实我们一般都是用父对象来定义通用的方法,子对象进行委托.然后子对象自身个性的属性方法就写在子对象本身,并避免与父对象的属性名冲突) ps: 这节书中这段话但是我们并不需要把这些行为放在一起，**通过类的复制**，我们可以把它们分别放在各自独立 的对象中，需要时可以允许 XYZ 对象委托给 Task。有个错误.”通过类的复制”应该改为”通过”[[Prototype]]机制”.这里应该是作者的手误.在 JavaScript 中，[[Prototype]] 机制会把对象关联到其他对象。无论你多么努力地说服自 己，JavaScript 中就是没有类似“类”的抽象机制。(其实主要原因还是是JavaScript没有完整的复制机制) 委托理论的使用建议:PS:书中这里写了3条,其实只有2条,第三条不过是对第一条的说明,这里我进行了合并. 通常来说，在 [[Prototype]] 委托中最好把状态保存在委托者(子对象)而不是委托目标(父对象)上。那怎么实现呢,就是通过”this 的隐式绑定”.在委托目标(父对象)上的函数里通过this定义保存状态.当委托者(子对象)引用该函数方法时,此时的this就自动绑定到委托者上了. 在委托中我们会尽量避免在 [[Prototype]] 链的不同级别中使用相同的命名，否则就需要使用笨拙并且脆弱的语法来消除引用歧义(参见第 4 章)。 补充: 3. 在 API 接口的设计中，委托最好在内部实现，不要直接暴露出去。 这么做更多的是出于安全和接口稳定的考虑.建议子对象将所有引用父对象的方法都套个函数隐藏起来,并取一个语义化的属性名. 委托理论的使用注意: 禁止两个对象互相委托:当你将第二个对象反向委托给前一个对象时,就会报错. 调试: 这个了解下就行.知道不同浏览器和工具对委托的解析结果并不一定相同.(吐槽:看了半天到后面出现实际上，在编写本书时，这个行为被认定是 Chrome 的一个 bug， 当你读到此书时，它可能已经被修复了。我只想说WTF! 好吧,我知道chrome以前可能出现过这个”bug”了=.=) 6.1.3 比较思维模型这节主要是比较了”通过构造函数(模拟类)实现原型继承”与”通过对象关联(委托形式,Object.create( … ))实现原型继承”两种方式的区别. 结论: 通过对象关联,委托形式,更加简洁,更加清晰易懂. PS:这里我原本自己对例子画出原型示意图.但是发现是真的复杂,并且和书中简洁后的示意图是差不多的,所以这里就不展示了,免得让读者看得更头大.这里建议,读者自己在草稿纸上画出原型示意图. 6.2 类与对象其实这节讲得还是”通过构造函数(模拟类)实现原型继承”与”通过对象关联(委托形式,Object.create( … ))实现原型继承”两种方式的区别.不过这次主要是以前端实际使用场景进行讲解. 6.2.1 控件“类”这里我就不以书中的例子进行讲解了,而是直接站在更高的角度对这种”类”风格的代码进行讲解.最大特点: 1是通过构造函数进行模拟类,2是通过显式伪多态(硬绑定函数)关联两个函数.注意: 不管是类还是对象.这两种形式一般都需要定义两种数据.第一种就是实例对象要用到的”初始保存的数据”;第二种就是通用行为的定义,包括对实例对象数据的增删改查. 下面提到的显式伪多态(详见第四章),其实指的就是使用call()方法这种硬绑定. 注意ES6 class模拟类的写法我就没具体列出了.实际上class 仍然是通过 [[Prototype]] 机制实现的,不过是个表面简洁的语法糖. 虽然书中对显式伪多态称为”丑陋的”,还用了一个语气动词”呸!”.虽然这样不好,但有时用call真的很方便,所以用得也很多. 6.2.2 委托控件对象最大特点: 通过对象载体来模拟父子,并通过Object,create(…)来对两个对象进行关联.并通过委托的形式进行引用.与上节中提到的类形式还有一个区别:对象foo构建后,需要手动调用setUp方法进行初始化.故对象的构建与初始化是分开的.而构造函数形式则是在new 构造函数时, 同时进行了对象构建与初始化.(关于这点我下面还会再说明的) 关于书中这句使用类构造函数的话，你需要(并不是硬性要求，但是强烈建议)在同一个步骤中实现构造和初始化。然而，在许多情况下把这两步分开(就像对象关联代码一样)更灵活。的理解:使用类构造函数形式,当我们使用new 构造函数时,其实是在一步实现对象的构建和对象数据的初始化(通过构造函数里的call) ;使用这种委托形式,我们是分别通过Object.create( ... );构建对象和foo.setUp( ...);来初始化的.即我们是分两步实现的.这样分开的话其实是更加灵活,也更符合编程中的关注分离原则. 6.3 更简洁的设计这节也是一样通过两者的对比来突显委托设计模式的各种优点.这里我就不再对书中的例子进行解读.如果你真正理解了类和委托的话,其实是很简单的.如果觉得复杂的话,可以在纸上理一下函数和对象之间的关系,下面我就只总结下这里提到委托设计模式的优点,当然核心是更简洁. 简洁体现在: 1, 委托重点在于只需要两个实体(两个对象相互关联)，而之前的”类”模式需要三个(父”类”,子”类”,实例对象)其实可以这么理解:委托模式将”子类”和”实例对象”合为一个对象了。 2, 不需要基类(父类)来”共享”两个实体之间的行为.不需要实例化类,也不需要合成.其实这第二条就是对第一条这种结果的说明. 额外补充强调:在使用构造函数模拟类时,子类通常会对父类的行为进行重写(属性名相同);但委托模式则不会,它会重新取个属性名,再引用父对象上的行为. 6.4 更好的语法这节主要是介绍ES6提供的2个简洁写法与其中的隐患. 语法: 在 ES6 中我们可以在任意对象的字面形式中使用简洁方法声明，例如: 123 var Foo = &#123; bar() &#123; /*..*/ &#125;,//字面形式声明&#125;; 在 ES6 中我们可以用 Object. setPrototypeOf(..) 来修改对象的 [[Prototype]],具体用法可以查看MDN例如: 12345678910111213// 使用更好的对象字面形式语法和简洁方法 var AuthController = &#123; errors: [], checkAuth() &#123; // ... &#125;, server(url,data) &#123; // ... &#125; // ... &#125;;// 现在把 AuthController 关联到 LoginController Object.setPrototypeOf( AuthController, LoginController ); 弊端: 对象字面形式语法:实际上就是一个匿名函数表达式.匿名函数会导致3个缺点:1. 调试栈更难追踪;2. 自我引用(递归、事件(解除)绑定，等等)更难; 3. 代码(稍微)更难理解。(其实我觉得这3个缺点还好,影响不是那么大).但是这种简洁语法很特殊，会给对应的函数对象设置一个内部的 name 属性，这样理论上可以用在追 踪栈中。所以实际上唯一的弊端就只剩第2条了.终极建议就是:如果你需要自我引用的话，那最好使用传统的具名函数表达式来定义对应的函数，不要使用简洁方法。 Object. setPrototypeOf(..) 这个是书中没有提的,我觉得有必要进行补充下.首先,Object. setPrototypeOf(..)可能会带来性能问题,如果关心性能,则应该使用Object.create()替代.Object. setPrototypeOf(..)与Object.create()的主要区别: Object. setPrototypeOf(..)会直接修改现有对象的[[prototype]],Object.create()则是返回一个新对象.所以你需要手动设置一下丢失的的constructor属性(如果你需要的话).而使用setPrototypeOf(..)则不需要. 6.5 内省吐槽: 纵观整本书,作者关于JavaScript中模拟类和继承”的批评,说它们具有很大误导性!更是嗤之以鼻!就差爆粗口了,JavaScript就像一个异教徒,应该绑在十字架上被烧死!但是他这样的观点,都是站在其他语言的角度来看待时,产生的.我想更多的读者可能是只接触过JavaScript.那么他其实是没有这些疑惑的!!!你反而给他们讲这一大堆其他语言的”正确”含义,有时候会时得其反!让读者更加困惑,如果是理解不透彻的,反而会怀疑自己本来写的是对的代码!所以读者应该做一个可以理解作者意图,并且拥有自我见解和观点立场! 什么是内省(自省)?首先,本节需要弄懂一个问题,什么是内省,或者是自省。书中的解释是自省就是检查实例的类型。类实例的自省主要目的是通过创建方式来判断对象的结构和功能。我这里再更通俗地解释下:当我们构建得到一个实例对象时,有时候我们是不太清除它的属性和方法的.尤其是第三方库.有时候贸然使用会导致很多错误(例如调用的方法不存在,或者报错等).这个时候我们就需要通过自省.其实就是通过一系列操作,来确认实例是不是我们想要的那个,实例的方法是不是我们想要的(存在且可用). 内省的方法: 1.通过 instanceof 语法:123456789101112function Foo() &#123; // ...&#125;Foo.prototype.something = function()&#123; // ... &#125;var a1 = new Foo();// 假设我们不知道上面的过程,只知道得到实例对象a1//我们想知道a1是不是我所希望的函数Foo所构建的if (a1 instanceof Foo) &#123; a1.something();&#125; 例子中我们有一个实例对象a1,但是我们不知道a1是不是我们所希望的函数Foo所构造的,此时就可以通过instanceof进行判断. instanceof比较适合判断实例对象和构造函数之间的关系.缺陷: 但是如果我们想判断函数A是不是函数B的”子类”时,则会稍微麻烦点,我们需要像这样A.prototype instanceof B进行判断.并且也不能直接判断两个对象是否关联. 2.通过 “鸭子类型”: 为什么会叫这个名字?看了作者的解释,还是不太能接受.不太理解外国人的脑回路.你在国内和别人说”鸭子类型”,估计也是一脸懵逼.其实很简单,所谓的”鸭子类型”其实也是我们实际工作中常用的:1234//如果a1的something存在的话,则我们可以进行调用if ( a1.something) &#123; a1.something();&#125; 其实这种方法是非常常用的,排除了在不知道存在性情况下,贸然调用的风险.缺陷: 关于书中提到的缺点,四个字概括就是”以偏概全” .书中关于Promise的例子,就是以偏概全的例子.所以我们在使用时,在if判断a1.something存在时,才会在后面使用something方法.不要直接使用anotherthing,这种没确认过的方法. 3.如果使用对象关联时: 则可以比较简单的使用Object.getPrototypeOf(..)进行判断.例如Object.getPrototypeOf(a)===A其中a,A都是对象.如果为true,则说明a的原型链上含有对象A. 6.6 小结 除了类和继承设计模式,行为委托其实是更强大,更值得推广的模式(本观点仅代表作者的观点!) 行为委托认为对象之间是兄弟关系，互相委托，而不是父类和子类的关系。JavaScript 的 [[Prototype]] 机制本质上就是行为委托机制。(我觉得还是父子对象关系.我的解说里也都是父子相称) 当你只用对象来设计代码时，不仅可以让语法更加简洁，而且可以让代码结构更加清晰。 对象关联(对象之前互相关联)是一种编码风格，它倡导的是直接创建和关联对象，不把它们抽象成类。对象关联可以用基于 [[Prototype]] 的行为委托非常自然地实现 后续更新后面关于&lt;你不知道的JavaScript&gt;中和下.还在写作当中,手头上还有一篇webpack完全指北的文章,目前写了一半2w字,也都是面向新手,真正的全面地由浅入深.最近,空降一个新项目组,开发到测试只有一个月,还要带新人,更新会很慢.不过我会争取年前全部放出.如果大家喜欢的话,可以关注我一下,文章首发还是在掘金的. 最后求一个内推,目前笔者在一家软件国企(半养老型).年底或者明年初就会考虑离职.希望进入一家比较好的互联网企业.如果有小伙伴有好的机会可以发我邮箱:bupabuku@foxmail.com.谢谢!目前暂时优先考虑武汉(房子,盆友,东西都在这边,去外地太不方便了-.-)]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECharts + Vue 配置使用总结]]></title>
    <url>%2F2018%2F10%2F30%2F%E5%89%8D%E7%AB%AF%E6%8A%80%E5%B7%A7%2FEcharts%2F</url>
    <content type="text"><![CDATA[ECharts 文档 高度个性化定制的数据可视化图表本文主要介绍柱状图、折线图、饼图、圆环图、雷达图、中国地图等 主要共用配置的参数 ECharts 需要给固定宽高 才能显示，固定的像素或百分比都可以图从上到下配置参数： 1.title 标题组件 包含主标题和副标题 textStyle 中的rich 可以换行符文本插入图标等功能 1234567891011121314151617title:&#123; text:'标题大号字体', subtext:'第二行标题小号字体', textStyle:&#123; color:'red', fontSize:14, fontWeight:'bolder' &#125;, subtextStyle:&#123; color:'red', fontSize:12, fontWeight:'bolder' &#125;, // 主副标题之间的间距 itemGap:5,&#125; 2.legend 图例组件 位置修改，上下左右 type 普通图例plain；或多的时候 滚动scroll textStyle文字大小 颜色 orient 横向布局 纵向布局horizontal/vertical； itemGap 图形间距 itemWidth 默认时25 和高度不一样。柱状图的图例icon修改成正方形圆角 线图图例icon修改成圆形 可以修改宽高相同 3.grid 直角坐标系 一般控制使用 上下边距留白 控制实际坐标系的范围 1234567grid: &#123; // left: '30.09%', left: '32%', right: '1%', top: '50px', bottom: '4%'&#125; 4.xAxis X轴 xAxis 的几个属性/类型 是否显示show ， position x 轴的位置 top/bottom name | nameLocation 坐标轴名称 位置 在头尾 可以使用在提示 坐标轴的意义提示 splitNumber 强制分割数字 max | min 设置最大值 最小值 防止数据显示问题 axisLine 坐标轴轴线 是否显示 样式 axisTick 坐标轴刻度 是否显示 axisLabel 刻度标签 是否显示，太拥挤间隔显示，是否显示最大值showMaxLabel/最小值showMinLabel formatter的转纵向显示，rich富文本格式显示 splitLine 分隔线 是否显示 样式 data 数据源 日期 number等 5.yAxis Y轴 Y轴 和X轴设置类似Y轴有可能是多个Y轴，多个间隔线会重叠 多个坐标Y轴，在series 的每个数据源属于那个Y轴 yAxisIndex: 0 如果两个的 splitLine 都显示，会比较乱，保留一个就可以 有个思路 增加三个Y轴，计算偏移量，当作纵向的参考线 12345678910111213141516171819202122232425262728293031323334353637383940414243yAxis: [ &#123; type: 'value', axisLine: &#123; show: false &#125;, axisLabel: &#123; show: false &#125;, axisTick: &#123; show: false &#125;, splitLine: &#123; show: false &#125;, min: function(value) &#123; return value.min * 0.8 &#125; &#125;, &#123; type: 'value', axisLine: &#123; show: false &#125;, axisLabel: &#123; show: false &#125;, axisTick: &#123; show: false &#125;, splitLine: &#123; show: false &#125;, max: function(value) &#123; return value.max * 2 &#125;, min: function(value) &#123; return value.min * 0.8 &#125; &#125;] 6.series 系列列表设置数据 type 为 line/bar/pie/radar/gauge 7.tooltip 鼠标悬浮提示框 formatter 传入 params 根据具体系列显示提示 换行使用 123456789101112tooltip: &#123; trigger: 'axis', formatter: function (params) &#123; var index = names.indexOf(params[0].name) var valiue1 = datas2[index]; var valiue2 = totData[index]; // params[0].value -&gt; valiue1 return params[0].name + '&lt;br /&gt;' + params[0].seriesName + ':' + valiue1 + '%' + '&lt;br /&gt;' + params[1].seriesName + ':' + valiue2 + '%'; &#125;, &#125; 柱状图1.标准柱状图实例1 官方文档示例 两个柱状图重叠 背景柱状图设置barGap:&#39;-100%&#39; 颜色渐变 使用 echarts.graphic.LinearGradient1234567891011121314151617181920212223242526272829303132333435363738series: [ &#123; // For shadow type: 'bar', itemStyle: &#123; normal: &#123;color: 'rgba(0,0,0,0.05)'&#125; &#125;, barGap:'-100%', barCategoryGap:'40%', data: dataShadow, animation: false &#125;, &#123; type: 'bar', itemStyle: &#123; normal: &#123; color: new echarts.graphic.LinearGradient( 0, 0, 0, 1, [ &#123;offset: 0, color: '#83bff6'&#125;, &#123;offset: 0.5, color: '#188df0'&#125;, &#123;offset: 1, color: '#188df0'&#125; ] ) &#125;, emphasis: &#123; color: new echarts.graphic.LinearGradient( 0, 0, 0, 1, [ &#123;offset: 0, color: '#2378f7'&#125;, &#123;offset: 0.7, color: '#2378f7'&#125;, &#123;offset: 1, color: '#83bff6'&#125; ] ) &#125; &#125;, data: data &#125; ] 2.标准柱状图实例2 官方文档示例 markPoint 两种方式 12345678910111213141.第一种方式 设置type 最大最小值平均值显示 markPoint : &#123; data : [ &#123;type : 'max', name: '最大值'&#125;, &#123;type : 'min', name: '最小值'&#125; ]&#125;2.设置 value ； xAxis X轴的现实列数 yAxis 显示的位置值 和value近似markPoint : &#123; data : [ &#123;name : '年最高', value : 182.2, xAxis: 7, yAxis: 183&#125;, &#123;name : '年最低', value : 6.4, xAxis: 10, yAxis: 6&#125; ]&#125;, markLine 两种方式设置 12345678910111213141516171819202122232425262728293031323334353637381.设置type 最大值，最小值 平均值，自使用显示位置markLine : &#123; symbol:'none', symbolSize:10, lineStyle:&#123; color:'#B20116 ', &#125;, label:&#123; fontSize:9, &#125;, data : [ &#123;type : 'average', name: '平均值'&#125; ]&#125;2.设置固定的位置 data 中是数组，其中一项是一条线 ，每一项又是一个数组 是个个点点组成，设置起点和终点 就是一条线markLine : &#123; symbol:'none', symbolSize:10, lineStyle:&#123; color:'#B20116 ', &#125;, label:&#123; fontSize:9, &#125;, data:[ [ &#123; name: '出险资产水平\n10%警戒线', x: 20, y: '67.2%', // 70% &#125;, &#123; x: '88%', y: '67.2%' // 46 &#125; ], ],&#125; 3.综合Y轴柱状图 Y轴上有其他非文字数字 用fomatter关键函数处理 数据准备处理【颜色】【Y轴显示数据系name,number1,number2】【柱状图数据3个一个要真实值，一个是文字显示值，最后空数据显示】【根据实际值，百分比求出总值】【计算三个marketLine的值位置用Y轴】 12345678910111213141516171819202122232425262728293031323334353637383940414243var colors = ['#FF6B2C','#BA70CC'];// 左侧Y轴var y1data = [ &#123; value: '中国投资系', number1: '3020', number: '3000' &#125;, &#123; value: '中国中信系', number1: '3020', number: '3000' &#125;, &#123; value: '山西省国有资本投资运营系', number1: '3020', number: '3000' &#125;, &#123; value: '国家电网公司系', number1: '3020', number: '3000' &#125;, &#123; value: '北京国有资本经营管理中心系',number1: '3020', number: '3000'&#125;, &#123; value: '招商局系', number1: '3020', number: '3000' &#125;, &#123; value: '深圳市地铁系', number1: '3020', number: '3000' &#125;, &#123; value: '中国华能系', number1: '3020', number: '3000' &#125;, &#123; value: '上海国际系', number1: '3020', number: '3000' &#125;, &#123; value: '四川发展(控股)系', number1: '3020', number: '3000' &#125;, &#123; value: '辽宁成大系', number1: '3020', number: '3000' &#125;, &#123; value: '大连合兴投资系', number1: '3020', number: '3000' &#125;, &#123; value: '陕西湖业化工集团系', number1: '3020', number: '3000' &#125;, &#123; value: '深圳市江天企业管理咨询系', number1: '3020', number: '3000' &#125;, &#123; value: '中国坊织机械(集团)系', number1: '3020', number: '3000' &#125;, &#123; value: '北京车之家信息技术系', number1: '3020', number: '3000' &#125;, &#123; value: '江苏省国信资产管理系', number1: '3020', number: '3000' &#125;, &#123; value: '中国保利系', number1: '3020', number: '3000' &#125;, &#123; value: '北京银华水利投资管理', number1: '3020', number: '3000' &#125;, &#123; value: '国家电力投资系', number1: '3020', number: '3000' &#125;];// 真实值var totData = [4920,4810,4790,4680,4570,4460,4350,4240,4130,4020, 3910,3810,3710,3680,3560,3450,3340,3230,3120,3010] ;// 左侧显示文字var showTextData = [ 4922220, 4810, 4790,4680,4570,4460,4350,4240,4130,4020,3910,3810,3710,3680, 3560,3450,3340,3230,3120,3010];// 空数据var empData = [0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0 ];// 计算3条标志线位置var totNumber = 28000;var ttw = window.width * 0.62var x1 = 0.10 / 0.22 * ttwvar x2 = 0.15 / 0.22 * ttwvar x3 = 0.20 / 0.22 * ttw echats 中设置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245option = &#123; grid: &#123; // left: '33.09%', left: '36.09%', top: '30px', right: '2%', bottom: '20px' &#125;, xAxis: &#123; type: 'value', splitNumber: 10, axisLine: &#123; lineStyle: &#123; color: '#333', width: 0.5 &#125; &#125;, axisLabel: &#123; // show:false, fontSize: 10, showMaxLabel: false &#125;, axisTick: &#123; show: false &#125;, splitLine: &#123; show: false &#125;, // max: function(value) &#123; // return value.max * 1.2; // &#125;, max: totNumber * 0.22 &#125;, yAxis: [ &#123; type: 'category', gridIndex: 0, inverse: true, axisTick: &#123; show: false &#125;, splitLine: &#123; show: false &#125;, data: y1data, axisLabel: &#123; formatter: function(pramas) &#123; // return '&#123;' + value + '| &#125;\n&#123;value|' + value + '&#125;'; function mapName(avalue) &#123; return avalue.value &#125; let aindx = y1data.map(mapName).indexOf(pramas) let adic = y1data[aindx] return ( '&#123;name|' + pramas + '&#125;' + ' ' + '&#123;index|' + (aindx + 1) + '&#125;' + ' ' + '&#123;bar|' + adic.number1 + '&#125;' + ' ' + '&#123;numbertext|' + adic.number + '&#125;' ) &#125;, margin: 2, align: 'right', rich: &#123; name: &#123; fontSize: 10, align: 'right' &#125;, index: &#123; align: 'center', color: '#fff', fontSize: 10, backgroundColor: '#C8D6E7', borderRadius: 2, padding: [3, 3, 3, 3], width: 10, height: 10 &#125;, bar: &#123; align: 'center', color: '#fff', fontSize: 10, backgroundColor: colors[0], width: 50, height: 14, shadowColor: '#AECDFF', borderRadius: 7, shadowOffsetX: 30, padding: [0, 0, 0, 0] &#125;, numbertext: &#123; align: 'left', color: '#083CAF', fontSize: 10, margin: [0, 0, 0, 0], width: 40 &#125; &#125; &#125; &#125;, // 10% - 15% - 20% &#123; type: 'value', name: '10%', zlevel: 1, nameGap: 12, nameTextStyle: &#123; color: '#fff', backgroundColor: '#51B9D2', borderRadius: 8, padding: [2, 4], fontSize: 10 &#125;, offset: -x1, // -700, axisTick: &#123; show: false &#125;, splitLine: &#123; show: false &#125;, axisLabel: &#123; show: false &#125;, axisLine: &#123; lineStyle: &#123; color: '#51B9D2', type: 'dashed', shadowOffsetY: -25, shadowColor: '#51B9D2' &#125; &#125; &#125;, &#123; type: 'value', name: '15%', zlevel: 1, nameGap: 12, offset: -x2, // -750, nameTextStyle: &#123; color: '#fff', backgroundColor: '#E29519', borderRadius: 8, padding: [2, 4], fontSize: 10 &#125;, axisTick: &#123; show: false &#125;, splitLine: &#123; show: false &#125;, axisLabel: &#123; show: false &#125;, axisLine: &#123; lineStyle: &#123; color: '#E29519', type: 'dashed', shadowOffsetY: -25, shadowColor: '#E29519' &#125; &#125; &#125;, &#123; type: 'value', name: '20%', nameGap: 12, zlevel: 1, offset: -x3, // -800, nameTextStyle: &#123; color: '#fff', backgroundColor: '#B20116', borderRadius: 8, padding: [2, 4], fontSize: 10 &#125;, axisTick: &#123; show: false &#125;, splitLine: &#123; show: false &#125;, axisLabel: &#123; show: false &#125;, axisLine: &#123; lineStyle: &#123; color: '#B20116', type: 'dashed', shadowOffsetY: -25, shadowColor: '#B20116' &#125; &#125; &#125; ], series: [ &#123; name: 'name1', stack: '空值', type: 'bar', barMinHeight: 40, barWidth: '12px', yAxisIndex: 0, color: colors[1], label: &#123; show: true, fontSize: 10, position: 'insideLeft', padding: 5, formatter: function(pramas) &#123; // let stta = (totData[pramas.dataIndex]/totNumber * 100).toFixed(2) + '%' return showTextData[pramas.dataIndex] &#125; &#125;, data: totData &#125;, &#123; name: 'name2', type: 'bar', stack: '空值', yAxisIndex: 0, color: 'clear', label: &#123; show: true, fontSize: 10, position: 'right', color: '#333', formatter: function(pramas) &#123; let stta = (totData[pramas.dataIndex]/totNumber * 100).toFixed(2) + '%' // let anumber = ( // Number(y1data[pramas.dataIndex].percent) * 100 // ).toFixed(2) // var stta = ' ' + anumber + '%' return stta &#125; &#125;, data: empData &#125; ]&#125; 4.堆叠柱状图/多组合柱状图 堆叠柱状图 只有X轴 Y轴不显示，分割线不显示 堆叠柱状图设置option代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105var char1XData = [ '2017-12', '2018-01', '2018-02', '2018-03','2018-04','2018-05','2018-06']var char1Bar1 = [22, 10, 10, 22, 10, 10, 12]var char1Bar2 = [22, 10, 10, 22, 10, 10, 12]option = &#123; title: &#123; text: '单位：亿元', right: 280, textStyle: &#123; fontFamily: 'PingFangSC-Regular', fontWeight: 'normal', fontSize: 12, color: '#333333' &#125; &#125;, tooltip: &#123; trigger: 'axis' &#125;, legend: &#123; data: ['好银行入池规模', '坏银行入池规模'], right: 10 &#125;, grid: &#123; left: '1%', right: '3%', bottom: '3%', containLabel: true &#125;, xAxis: &#123; type: 'category', data: char1XData, boundaryGap: ['5%', '5%'], axisLine: &#123; lineStyle: &#123; color: '#333', width: 0.5 &#125; &#125;, axisLabel: &#123; // show:false, fontSize: 9, interval: 0, // rotate: 30 &#125;, axisTick: &#123; show: false &#125;, splitLine: &#123; show: false &#125; &#125;, yAxis: &#123; type: 'value', axisLine: &#123; show: false &#125;, axisLabel: &#123; show: false &#125;, axisTick: &#123; show: false &#125;, splitLine: &#123; show: false &#125; &#125;, series: [ &#123; name: '好银行入池规模', type: 'bar', yAxisIndex: 0, barWidth: 20, barMinHeight: 15, stack: 'bar1', label: &#123; show: true, fontSize: 10, position: 'inside' &#125;, itemStyle: &#123; color: '#FF6B2C' &#125;, data: char1Bar1 &#125;, &#123; name: '坏银行入池规模', type: 'bar', yAxisIndex: 0, barWidth: 20, barMinHeight: 15, stack: 'bar1', label: &#123; show: true, fontSize: 10, position: 'inside', color: '#333' &#125;, itemStyle: &#123; color: '#FFDCC0' &#125;, data: char1Bar2 &#125; ] &#125; 三组数据 不重叠显示option代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123var char2XData = ['2017-09', '2017-10','2017-11','2017-12','2018-01','2018-02','2018-03','2018-04','2018-05','2018-06','2018-07']var char2Bar1 = [30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30]var char2Bar2 = [10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10]var char2Bar3 = [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]option = &#123; title: &#123; text: '单位：亿元', right: 450, textStyle: &#123; fontFamily: 'PingFangSC-Regular', fontWeight: 'normal', fontSize: 12, color: '#333333' &#125; &#125;, tooltip: &#123; trigger: 'axis' &#125;, legend: &#123; data: ['好银行到坏银行规模', '好银行出池规模', '坏银行出池规模'], right: 10 &#125;, grid: &#123; left: '1%', right: '3%', bottom: '3%', containLabel: true &#125;, xAxis: &#123; type: 'category', data: char2XData, boundaryGap: ['5%', '5%'], axisLabel: &#123; // show:false, fontSize: 9, color: '#333333', interval: 0, // rotate: 30 &#125;, axisTick: &#123; show: false &#125;, splitLine: &#123; show: false &#125; &#125;, yAxis: &#123; type: 'value', axisLine: &#123; show: false &#125;, axisLabel: &#123; show: false &#125;, axisTick: &#123; show: false &#125;, splitLine: &#123; show: false &#125; &#125;, series: [ &#123; name: '好银行到坏银行规模', type: 'bar', yAxisIndex: 0, barWidth: 15, barMinHeight: 15, barGap: 0.05, label: &#123; show: true, position: 'top', fontSize: 10, color: '#333333', offset: [-5, 0] &#125;, itemStyle: &#123; color: '#6678E7' &#125;, data: char2Bar1 &#125;, &#123; name: '好银行出池规模', type: 'bar', yAxisIndex: 0, barWidth: 15, barMinHeight: 15, barGap: 0.05, label: &#123; show: true, position: 'top', fontSize: 10, color: '#333333' &#125;, itemStyle: &#123; color: '#BA70CC' &#125;, data: char2Bar2 &#125;, &#123; name: '坏银行出池规模', type: 'bar', yAxisIndex: 0, barWidth: 15, barMinHeight: 15, barGap: 0.05, label: &#123; show: true, position: 'top', fontSize: 10, color: '#333333', offset: [5, 0] &#125;, itemStyle: &#123; color: '#AECDFF' &#125;, data: char2Bar3 &#125; ]&#125; 5.横向堆叠柱状图 跟上面的横向类似，但是又堆叠数据，背景数据 可以设置barGap:’-100%’ 当作背景 option设置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230var y1data = [ &#123; value: '中国投资系' &#125;, &#123; value: '中国中信系' &#125;, &#123; value: '山西省国有资本投资运营系' &#125;, &#123; value: '国家电网公司系' &#125;, &#123; value: '北京国有资本经营管理中心系' &#125;, &#123; value: '招商局系' &#125;, &#123; value: '深圳市地铁系' &#125;, &#123; value: '中国华能系' &#125;, &#123; value: '上海国际系' &#125;, &#123; value: '四川发展(控股)系' &#125;, &#123; value: '辽宁成大系' &#125;, &#123; value: '大连合兴投资系' &#125;, &#123; value: '陕西湖业化工集团系' &#125;, &#123; value: '深圳市江天企业管理咨询系' &#125;, &#123; value: '中国坊织机械(集团)系' &#125;, &#123; value: '北京车之家信息技术系' &#125;, &#123; value: '江苏省国信资产管理系' &#125;, &#123; value: '中国保利系' &#125;, &#123; value: '北京银华水利投资管理' &#125;, &#123; value: '国家电力投资系' &#125; ]var totData = [3, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 9, 0.101]var bar1 = [0.0001, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 0.051]var bar2 = [2.9999, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.00001]var totNumber = 100var ttw = window.width * 0.27var x2 = 3 / 7.0 * ttwvar x3 = 5 / 7.0 * ttwoption = &#123;grid: &#123; // left: '30.09%', left: '32%', right: '1%', top: '50px', bottom: '4%'&#125;,xAxis: &#123; type: 'value', splitNumber: 10, axisLabel: &#123; // show:false, fontSize: 10, showMaxLabel: false &#125;, axisTick: &#123; show: false &#125;, splitLine: &#123; show: false &#125;, max: totNumber * 0.07&#125;,yAxis: [ &#123; type: 'category', gridIndex: 0, inverse: true, axisTick: &#123; show: false &#125;, splitLine: &#123; show: false &#125;, data: y1data, axisLabel: &#123; margin: 8, formatter: function(pramas) &#123; // return '&#123;' + value + '| &#125;\n&#123;value|' + value + '&#125;'; function mapName(avalue) &#123; return avalue.value &#125; let aindx = y1data.map(mapName).indexOf(pramas) // let adic = y1data[aindx] return ( '&#123;name|' + pramas + '&#125;' + ' ' + '&#123;index|' + (aindx + 1) + '&#125;' ) &#125;, rich: &#123; name: &#123; fontSize: 9, align: 'right' &#125;, index: &#123; align: 'center', color: '#fff', fontSize: 10, backgroundColor: '#C8D6E7', borderRadius: 2, padding: [3, 3, 3, 3], width: 10, height: 10 &#125; &#125; &#125; &#125;, // 3% - 5% &#123; type: 'value', name: '3%', nameGap: 12, zlevel: 1, offset: -350, // -750, nameTextStyle: &#123; color: '#fff', backgroundColor: '#E29519', borderRadius: 8, padding: [2, 4], fontSize: 10 &#125;, axisTick: &#123; show: false &#125;, splitLine: &#123; show: false &#125;, axisLabel: &#123; show: false &#125;, axisLine: &#123; lineStyle: &#123; color: '#E29519', type: 'dashed', shadowOffsetY: -25, shadowColor: '#E29519' &#125; &#125; &#125;, &#123; type: 'value', name: '5%', nameGap: 12, zlevel: 1, offset: -180, // -800, nameTextStyle: &#123; color: '#fff', backgroundColor: '#B20116', borderRadius: 8, padding: [2, 4], fontSize: 10 &#125;, axisTick: &#123; show: false &#125;, splitLine: &#123; show: false &#125;, axisLabel: &#123; show: false &#125;, axisLine: &#123; lineStyle: &#123; color: '#B20116', type: 'dashed', shadowOffsetY: -25, shadowColor: '#B20116' &#125; &#125; &#125;],series: [ &#123; name: 'name1', type: 'bar', barWidth: '12px', stack: 'fengxinan', zlevel: 2, yAxisIndex: 0, color: '#FF6B2C', label: &#123; show: true, fontSize: 10, position: 'insideLeft', padding: 2, formatter: function(pramas) &#123; let v1 = totData[pramas.dataIndex].leftInner return v1 &#125; &#125;, data: bar2 &#125;, &#123; name: 'name2', type: 'bar', barWidth: '12px', stack: 'fengxinan', yAxisIndex: 0, color: '#FFDABB', label: &#123; show: true, fontSize: 10, position: 'right', formatter: function(pramas) &#123; var v1 = totData[pramas.dataIndex] var stta = (totData[pramas.dataIndex] / totNumber * 100).toFixed(2) + '%' if ( (totData[pramas.dataIndex] / totNumber * 100).toFixed(2) &lt; 0.5 ) &#123; v1 = ' ' + v1 &#125; // let v1 = Number(totData[pramas.dataIndex].value).toFixed(0) // let tem1 = totData[pramas.dataIndex].percent // let stta = (Number(tem1) * 100).toFixed(2) + '%' // if ((Number(tem1) * 100).toFixed(1) &lt; 0.5) &#123; // v1 = ' ' + v1 // &#125; var v2 = '(' + stta + ')' return '&#123;value|' + v1 + '&#125;' + '' + '&#123;percent|' + v2 + '&#125;' &#125;, rich: &#123; value: &#123; align: 'left', fontSize: 10, color: '#333' &#125;, percent: &#123; align: 'left', color: '#FF6B2C', fontSize: 10 &#125; &#125; &#125;, data: bar1 &#125;]&#125; 6.堆叠柱状图 + 处理X轴 + markLine X轴文字换行；气泡；两条markLine X轴文字还向 value.split(&quot;&quot;).join(&quot;\n&quot;); 气泡 散点图样式是气泡 type:&#39;scatter&#39;； symbol:&#39;pin&#39; 两条markLine 设置起点终点。 option 设置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169var names = ["煤炭及煤制品煤炭及煤制品煤炭及煤制品",'建筑施工','电力生产','农林牧渔','建材','食品、餐饮及烟酒'] var totData = ["100.00",'16.00','4.00','22.00','20.00','16.00']var datas1 = ["0.00",'2.00','2.00','11.00','10.00','11.00']var datas2 = ["100.00",'14.00','2.00','11.00','10.00','5.00'] var datas3 = ["100.10", '',' 4.10', '', '20.10','']var totNumber = 100;option = &#123; tooltip: &#123; trigger: 'axis', formatter: function (params) &#123; var index = names.indexOf(params[0].name) var valiue1 = datas2[index]; var valiue2 = totData[index]; // params[0].value -&gt; valiue1 return params[0].name + '&lt;br /&gt;' + params[0].seriesName + ':' + valiue1 + '%' + '&lt;br /&gt;' + params[1].seriesName + ':' + valiue2 + '%'; &#125;, &#125;, legend: &#123; data:['风险资产水平','出险资产水平','出险及风险资产水平超警戒线，集团限额监控行业'], right:10, &#125;, grid: &#123; top:'6%', left: '5%', right: '10%', bottom: '26%', &#125;, xAxis: [ &#123; type: 'category', // name:"222", data: names, boundaryGap:['1%', '5%'], gridIndex:0, axisLabel:&#123; interval:0, formatter:function(value) &#123; return value.split("").join("\n"); &#125;, color:"#333", fontSize:10, &#125;, axisTick:&#123; show:false, &#125;, splitLine:&#123; show:false, &#125;, &#125;, ], yAxis:&#123; type: 'value', axisLine:&#123; show:false, &#125;, axisLabel:&#123; // show:false, formatter: '&#123;value&#125;%' , fontSize:10, &#125;, axisTick:&#123; show:false, &#125;, splitNumber:10, splitLine:&#123; // show:false, &#125;, // max: function(value) &#123; // return value.max * 1.2; // &#125;, max:totNumber, &#125;, series: [ &#123; name:'出险资产水平', type:'bar', yAxisIndex:0, barWidth:8, stack: 'chuxianzichan', itemStyle:&#123; color:"#3AA4FF", &#125;, data:datas2, &#125;, &#123; name:'风险资产水平', type:'bar', yAxisIndex:0, barWidth:8, stack: 'chuxianzichan', itemStyle:&#123; color:"#B1DBFF", &#125;, data:datas1, markLine:&#123; symbol:'none', symbolSize:12, lineStyle:&#123; color:'#FF6B2C ', &#125;, label:&#123; fontSize:10, &#125;, data:[ [ &#123; name: '出险资产水平\n10%警戒线', x: 20, y: '67.2%', // 70% &#125;, &#123; x: '88%', y: '67.2%' // 46 &#125; ], ], &#125;, &#125;, &#123; name:'出险及风险资产水平超警戒线，集团限额监控行业', yAxisIndex: 0, type:'scatter', symbol:'pin', symbolSize:16, symbolKeepAspect:true, data:datas3, itemStyle:&#123; color:"#FF6B2C", &#125;, markLine:&#123; symbol:'none', symbolSize:12, lineStyle:&#123; color:'#B20116', &#125;, label:&#123; fontSize:10, &#125;, data:[ [ &#123; name: '风险资产水平\n20%警戒线', x: 20, y: '60.3%', &#125;, &#123; x: '88%', y: '60.3%' &#125; ], ], &#125;, &#125;, ]&#125;; 折线图 单独的多折线图 / 柱状图折线图结合绘制 1.单独绘制 三线图 修改X轴样式； 修改Y轴样式 不显示；修改3线颜色； 修改节点颜色 线的颜色 itemStyle 修改线的宽度 lineStyle: { width: 1} 修改节点颜色大小symbol: &#39;circle&#39;, symbolSize: 8 option 设置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151var char1XData = [ '2017-12', '2018-01', '2018-02', '2018-03', '2018-04', '2018-05', '2018-06' ]var char1Line1 = [2534, 2563, 2531, 2589, 2519, 2737, 2816]var char1Line2 = [2221, 2215, 2211, 2239, 2131, 2225, 2310]var char1Line3 = [313, 348, 320, 349, 388, 492, 506]option = &#123;title: &#123; text: '单位：亿元', right: 309, textStyle: &#123; fontFamily: 'PingFangSC-Regular', fontWeight: 'normal', fontSize: 12, color: '#333333' &#125;&#125;,tooltip: &#123; trigger: 'axis'&#125;,legend: &#123; data: ['非银规模', '银行规模', '整体规模'], right: 10&#125;,grid: &#123; left: '1%', right: '2%', bottom: '3%', containLabel: true&#125;,xAxis: &#123; type: 'category', data: char1XData, boundaryGap: ['5%', '5%'], axisLine: &#123; lineStyle: &#123; color: '#333', width: 0.5 &#125; &#125;, axisLabel: &#123; // show:false, fontSize: 9, interval: 0, // rotate: 30, padding: [0, -6, 0, 0] &#125;, axisTick: &#123; show: false &#125;, splitLine: &#123; show: false &#125;&#125;,yAxis: [ &#123; type: 'value', axisLine: &#123; show: false &#125;, axisLabel: &#123; show: false &#125;, axisTick: &#123; show: false &#125;, splitLine: &#123; show: false &#125;, min: function(value) &#123; return value.min * 0.8 &#125; &#125;, &#123; type: 'value', axisLine: &#123; show: false &#125;, axisLabel: &#123; show: false &#125;, axisTick: &#123; show: false &#125;, splitLine: &#123; show: false &#125;, max: function(value) &#123; return value.max * 2 &#125;, min: function(value) &#123; return value.min * 0.8 &#125; &#125;],series: [ &#123; name: '整体规模', type: 'line', yAxisIndex: 0, label: &#123; show: true &#125;, itemStyle: &#123; color: '#3AA4FF' &#125;, symbol: 'circle', symbolSize: 8, lineStyle: &#123; width: 1 &#125;, data: char1Line1 &#125;, &#123; name: '银行规模', type: 'line', yAxisIndex: 0, label: &#123; show: true, fontSize: 11 &#125;, itemStyle: &#123; color: '#BA70CC' &#125;, symbol: 'circle', symbolSize: 8, lineStyle: &#123; width: 1 &#125;, data: char1Line2 &#125;, &#123; name: '非银规模', type: 'line', yAxisIndex: 1, label: &#123; show: true &#125;, itemStyle: &#123; color: '#6678E7' &#125;, symbol: 'circle', symbolSize: 8, lineStyle: &#123; width: 1 &#125;, data: char1Line3 &#125;]&#125; 2.柱状图+折线图 2Y轴 2柱状图 2线图 设置2个Y轴，保留一个分割线 splitLine: { show: false} 设置两个柱状图的间隙 barGap: 0.05 设置柱状图的宽度，最小高度 颜色 barMinHeight: 15 ;barWidth: 20;itemStyle: { color: &#39;#FFDCC0&#39; } 设置线的颜色 节点大小 颜色 线宽等 itemStyle: { color: &#39;#3981F4&#39;} ; lineStyle: { width: 1 };symbolSize: 8 option 设置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177var char2XData = ['2017-09', '2017-10', '2017-11', '2017-12', '2018-01', '2018-02', '2018-03', '2018-04', '2018-05', '2018-06', '2018-07' ]var char2Bar1 = [30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30]var char2Bar2 = [10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10]var char2Line1 = [0.15, 0.13, 0.15, 0.16, 0.13, 0.12, 0.11, 0.1, 0.09, 0.09, 0.08 ]var char2Line2 = [ 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.06, 0.05, 0.16, 0.05, 0.06 ] option = &#123; title: &#123; text: '单位：亿元', right: 400, textStyle: &#123; fontFamily: 'PingFangSC-Regular', fontWeight: 'normal', fontSize: 12, color: '#333333' &#125; &#125;, tooltip: &#123; trigger: 'axis' &#125;, legend: &#123; data: ['刚性逾期', '不良资产', '逾期率', '不良率'], right: 10 &#125;, grid: &#123; left: '1%', right: '3%', bottom: '3%', containLabel: true &#125;, xAxis: &#123; type: 'category', data: char2XData, boundaryGap: ['5%', '5%'], axisLine: &#123; lineStyle: &#123; color: '#333', width: 0.5 &#125; &#125;, axisLabel: &#123; fontSize: 9, interval: 0, // rotate: 30 &#125;, axisTick: &#123; show: false &#125;, splitLine: &#123; show: false &#125; &#125;, yAxis: [ &#123; type: 'value', axisLine: &#123; show: false &#125;, axisLabel: &#123; // show:false, fontSize: 10 &#125;, axisTick: &#123; show: false &#125;, splitLine: &#123; // show:false, &#125; // min: function(value) &#123; // return value.min * 0.8; // &#125;, &#125;, &#123; type: 'value', axisLine: &#123; show: false &#125;, axisLabel: &#123; // show:false, fontSize: 10, showMaxLabel: false, formatter: ' &#123;value&#125;%', &#125;, axisTick: &#123; show: false &#125;, splitLine: &#123; show: false &#125;, max: function(value) &#123; return value.max * 2 &#125; &#125; ], series: [ &#123; name: '刚性逾期', type: 'bar', yAxisIndex: 0, barWidth: 20, barMinHeight: 15, barGap: 0.05, label: &#123; show: true, position: 'top', fontSize: 10, color: '#333333' &#125;, itemStyle: &#123; color: '#FFDCC0' &#125;, data: char2Bar1 &#125;, &#123; name: '不良资产', type: 'bar', yAxisIndex: 0, barWidth: 20, barMinHeight: 15, barGap: 0.05, label: &#123; show: true, position: 'top', fontSize: 10, color: '#333333', offset: [6, 0] &#125;, itemStyle: &#123; color: '#AECDFF' &#125;, data: char2Bar2 &#125;, &#123; name: '逾期率', type: 'line', yAxisIndex: 1, label: &#123; show: true, position: 'top', distance: 2, fontSize: 9, color: '#333333' &#125;, itemStyle: &#123; color: '#FF6B2C' &#125;, symbol: 'circle', symbolSize: 8, lineStyle: &#123; width: 1 &#125;, data: char2Line1 &#125;, &#123; name: '不良率', type: 'line', yAxisIndex: 1, label: &#123; show: true, position: 'bottom', fontSize: 9, color: '#333333' &#125;, itemStyle: &#123; color: '#3981F4' &#125;, symbol: 'circle', symbolSize: 8, lineStyle: &#123; width: 1 &#125;, data: char2Line2 &#125; ] &#125; 饼图 圆环图1231.上图又单圆环图；双圆环图2.radius 支持设置成百分比，相对于容器高宽中较小的一项的一半3.center 第一项是相对于容器宽度，第二项是相对于容器高度 1.单圆环图 右侧标记 data 数组 数组内的百分比加起来为100% 右侧标记是 用markLine 文字label：（formatter + rich）富文本实现 两个折现 是markLine （x，y） 数组实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102var appExposureRatiosDTO = &#123; "percent": "0.2538", "title": "全集团风险敞口", "top20WarnAssetPool": "739.62", "totalAssetPoolValue": "2914.24"&#125;var top20 = Number(appExposureRatiosDTO.top20WarnAssetPool).toFixed(0)var pieData = [ &#123; value: appExposureRatiosDTO.percent&#125;, &#123; value: 1-appExposureRatiosDTO.percent&#125;]option = &#123; color: ['#FE7011', '#FFDABB'], // tooltip: &#123; // trigger: 'item', // formatter: '&#123;a&#125; &lt;br/&gt;&#123;b&#125; : &#123;c&#125; (&#123;d&#125;%)' // &#125;, series: &#123; name: '全集团风险敞口', type: 'pie', // 支持设置成百分比，相对于容器高宽中较小的一项的一半。 radius: ['80%', '60%'], // 第一项是相对于容器宽度，第二项是相对于容器高度。 center: ['30%', '50%'], data: pieData, labelLine: &#123; show: false, length: 50 &#125;, markLine: &#123; symbol: 'none', lineStyle: &#123; color: '#FF6B2C ', width: 2.5, type: 'dotted' &#125;, label: &#123; fontSize: 10, show: true, color: '#333', formatter: function(pramas) &#123; var v1 = '前20大风险系客户\n风险敞口' var v2 = top20 var v3 = '亿元' if (pramas.dataIndex === 0) &#123; return ( '&#123;name|' + v1 + '&#125;' + '\n' + '&#123;number|' + v2 + '&#125;' + '&#123;unit|' + v3 + '&#125;' ) &#125; return '' &#125;, rich: &#123; name: &#123; align: 'center', fontSize: 12, color: '#666666', lineHeight: 16 &#125;, number: &#123; align: 'left', color: '#FE7011', padding: [0, 2, 6, 20], fontSize: 26, fontFamily: 'JCHEadA' &#125;, unit: &#123; align: 'left', color: '#FF6B2C', fontSize: 11, padding: [0, 0, 12, 0] &#125; &#125; &#125;, data: [ [ &#123; x: '70%', y: '10%' &#125;, &#123; x: '70%', y: '30.2%' &#125; ], [ &#123; x: '36%', y: '10%' &#125;, &#123; x: '70%', y: '10%' &#125; ] ] &#125;, label: &#123; show: false &#125; &#125; &#125; 1.单圆环图 右侧标记 两组数据 每组都是和100% 图例在下面 中间有文字提示 图例是html 中心文字使用 graphic 设置左侧上的中心对齐 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465var pieData = &#123; "assetPoolRatio": "0.8278", "outRiskRatio": "0.7926", "title": "全集团风险客户"&#125;var color1 = ['#FFDABB', '#EEEEEE']var color2 = ['#FF6B2C', '#ddd']var pieData1 = [pieData.assetPoolRatio,1-pieData.assetPoolRatio]var pieData2 = [pieData.outRiskRatio,1-pieData.outRiskRatio]var centerText = (pieData.title.length &gt; 5) ? (pieData.title.substring(0,5) + '\n' + pieData.title.substring(5)) : pieData.title option = &#123; // 中心提示lablegraphic:&#123; type:"text", left:"center", top:'center', zlevel:100, z:2, style:&#123; text: centerText, textAlign:'center', fontSize:11, color:'#333333' &#125;,&#125;,series: [ &#123; name: '风险资产', type: 'pie', // 支持设置成百分比，相对于容器高宽中较小的一项的一半。 radius: ['80%', '65%'], // 第一项是相对于容器宽度，第二项是相对于容器高度。 center: ['50%', '50%'], data:pieData1, label: &#123; show: false &#125;, itemStyle: &#123; color: function(params) &#123; return color1[params.dataIndex] &#125; &#125; &#125;, &#123; name: '出险资产', type: 'pie', // 支持设置成百分比，相对于容器高宽中较小的一项的一半。 radius: ['65%', '51%'], // 第一项是相对于容器宽度，第二项是相对于容器高度。 center: ['50%', '50%'], data:pieData2, label: &#123; show: false &#125;, itemStyle: &#123; color: function(params) &#123; return color2[params.dataIndex] &#125; &#125; &#125;]&#125; 雷达图 官方文档 series设置 type: &#39;radar&#39; 1.设置 指标类型 格式 2.设置splitArea分割区域 颜色5个 3.设置axisLine 颜色 1234567891011121314151617181920212223242526272829303132333435363738394041radar: [ &#123; indicator: [ &#123; text: '指标一' &#125;, &#123; text: '指标二' &#125;, &#123; text: '指标三' &#125;, &#123; text: '指标四' &#125;, &#123; text: '指标五' &#125; ], center: ['25%', '50%'], radius: 120, startAngle: 90, splitNumber: 4, shape: 'circle', name: &#123; formatter:'【&#123;value&#125;】', textStyle: &#123; color:'#72ACD1' &#125; &#125;, splitArea: &#123; areaStyle: &#123; color: ['rgba(114, 172, 209, 0.2)', 'rgba(114, 172, 209, 0.4)', 'rgba(114, 172, 209, 0.6)', 'rgba(114, 172, 209, 0.8)', 'rgba(114, 172, 209, 1)'], shadowColor: 'rgba(0, 0, 0, 0.3)', shadowBlur: 10 &#125; &#125;, axisLine: &#123; lineStyle: &#123; color: 'rgba(255, 255, 255, 0.5)' &#125; &#125;, splitLine: &#123; lineStyle: &#123; color: 'rgba(255, 255, 255, 0.5)' &#125; &#125; &#125;] 设置data 两组数据对比 设置各组数据对应的 个个点连线颜色 lineStyle 123456789101112131415161718192021222324252627282930313233343536series: [ &#123; name: '雷达图', type: 'radar', itemStyle: &#123; emphasis: &#123; // color: 各异, lineStyle: &#123; width: 4 &#125; &#125; &#125;, data: [ &#123; value: [100, 8, 0.40, -80, 2000], name: '图一', symbol: 'rect', symbolSize: 5, lineStyle: &#123; normal: &#123; type: 'dashed' &#125; &#125; &#125;, &#123; value: [60, 5, 0.30, -100, 1500], name: '图二', areaStyle: &#123; normal: &#123; color: 'rgba(255, 255, 255, 0.5)' &#125; &#125; &#125; ] &#125;] 仪表盘中国地图 准备每个省份的数据 设置 visualMap 小地图颜色 type: &#39;piecewise&#39; 分段型视觉映射组件（visualMapPiecewise）;连续型视觉映射组件（visualMapContinuous） pieces 分段型 每一段的样式可以设置，根据数据的数值区间 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100var mydata = [ &#123;"name": "西藏","value": "5",'percent':'1' &#125;, &#123;"name": "新疆","value": "4" ,'percent':'1' &#125;, &#123;"name": "广西","value": "3" ,'percent':'1' &#125;, &#123;"name": "重庆","value": "2" ,'percent':'1' &#125;, &#123;"name": "河南","value": "1" ,'percent':'1' &#125;, &#123;"name": "江苏","value": "0" ,'percent':'1' &#125;, &#123;"name": "上海","value": "0" ,'percent':'1' &#125;, &#123;"name": "辽宁","value": "0" ,'percent':'1' &#125;, &#123;"name": "黑龙江","value": "0" ,'percent':'1' &#125;, &#123;"name": "湖南","value": "0",'percent':'1%' &#125;, &#123;"name": "安徽","value": "0" ,'percent':'1%' &#125;, &#123;"name": "山东","value": "0" ,'percent':'1%' &#125;, &#123;"name": "天津","value": "0" ,'percent':'1%' &#125;, &#123;"name": "河北","value": "0" ,'percent':'1%' &#125;, &#123;"name": "浙江","value": "0",'percent':'1%' &#125;, &#123;"name": "江西","value": "0" ,'percent':'1%' &#125;, &#123;"name": "湖北","value": "0" ,'percent':'1%' &#125;, &#123;"name": "云南","value": "0" ,'percent':'1%' &#125;, &#123;"name": "甘肃","value": "0" ,'percent':'1%' &#125;, &#123;"name": "山西","value": "0" ,'percent':'1%' &#125;, &#123;"name": "内蒙古","value": "0" ,'percent':'1%' &#125;, &#123;"name": "陕西","value": "0" ,'percent':'1%' &#125;, &#123;"name": "吉林","value": "0" ,'percent':'1%' &#125;, &#123;"name": "福建","value": "0" ,'percent':'1%' &#125;, &#123;"name": "贵州","value": "0" ,'percent':'1%' &#125;, &#123;"name": "广东","value": "0" ,'percent':'1%' &#125;, &#123;"name": "青海","value": "0" ,'percent':'1%' &#125;, &#123;"name": "北京","value": "0" ,'percent':'1%' &#125;, &#123;"name": "四川","value": "0" ,'percent':'1%' &#125;, &#123;"name": "宁夏","value": "0" ,'percent':'1%' &#125;, &#123;"name": "海南","value": "0" ,'percent':'1%' &#125;, &#123;"name": "台湾","value": "0" ,'percent':'1%' &#125;, &#123;"name": "香港","value": "0" ,'percent':'1%' &#125;, &#123;"name": "澳门","value": "0" ,'percent':'1%' &#125;, &#123;"name": "南海诸岛","value": "0",'percent':'1%' &#125;]let a2 = 0.01;for (var i = 0; i &lt; mydata.length; i++)&#123; if (i == 5) &#123; a2 = Number(mydata[i]["value"]) &gt; a2 ? Number(mydata[i]["value"]) : a2; &#125;&#125;console.log(a2)var option = &#123; //左侧小导航图标 visualMap: &#123; type: 'piecewise', show : true, splitNumber:2, left:"15px", bottom:"7.5%", color: ['#E74040' ,'#dee4ff'], pieces: [ &#123;min: a2, label: '风险资产规模区域占比前五大省市'&#125;, &#123;max: a2,label: '其他风险资产所在区域'&#125;, ], inRange: &#123; color: ['#dee4ff', '#E74040'], symbolSize: [30, 100] &#125;, outOfRange: &#123; color: ['#dee4ff', '#E74040'], symbolSize: [30, 100] &#125;, &#125;, //配置属性 series: [&#123; name: '数据', type: 'map', mapType: 'china', data:mydata, roam: false, //是否开启鼠标缩放和平移漫游 //高亮状态下的多边形和标签样式。 itemStyle:&#123; // normal:&#123;label:&#123;show:true&#125;&#125;, emphasis:&#123;label:&#123;show:true&#125;&#125;, borderWidth:1, // borderColor:'rgba(0,0,0,0.3)', borderColor:'#fff', &#125;, label:&#123; show:true, color:'#333', fontSize:'9', // formatter:'', formatter: function (params) &#123; if (Number(params.data.value ) &gt; a2)&#123; return params.data.name + '\n' + params.data.percent + '%'; &#125; return ""; &#125;, &#125;, &#125;],&#125;;]]></content>
      <categories>
        <category>ECharts</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery学习笔记03]]></title>
    <url>%2F2018%2F05%2F22%2F%E5%89%8D%E7%AB%AF%E6%8A%80%E5%B7%A7%2FjQuery03%2F</url>
    <content type="text"><![CDATA[jQuery特殊属性操作val方法 val方法用于设置和获取表单元素的值，例如input、textarea的值 1234//设置值$("#name").val(“张三”);//获取值$("#name").val(); 12345678910111213141516171819console.log($('.section1 #btn').val()) // hehe$('.section1 #btn').val('add') // addconsole.log($('.section1 #btn').attr('value'))// 如果是默认值 清空内容$('.section1 #txt').focus(function()&#123; if($('.section1 #txt').val() === '洋酒')&#123; $('.section1 #txt').val('') &#125;&#125;) // 失去焦点的时候 如果为空 给个默认值$('.section1 #txt').blur(function()&#123; if($('.section1 #txt').val() === '')&#123; $('.section1 #txt').val('洋酒') &#125;&#125;) html() 方法 和text() 方法 html方法相当于innerHTML text方法相当于innerText 1234567891011121314151617//设置内容$(“div”).html(“&lt;span&gt;这是一段内容&lt;/span&gt;”);//获取内容$(“div”).html()//设置内容$(“div”).text(“&lt;span&gt;这是一段内容&lt;/span&gt;”);//获取内容$(“div”).text()console.log($('.section2 div').html()) // &lt;h3&gt;我是标题&lt;/h3&gt;console.log($('.section2 div').text()) // 我是标题$('.section2 div').text('&lt;p&gt;我是文本&lt;/p&gt;') console.log($('.section2 div').html()) // &amp;lt;p&amp;gt;我是文本&amp;lt;p&amp;gt; 字符串$('.section2 div').html('&lt;p&gt;我是文本&lt;/p&gt;') console.log($('.section2 div').html()) // &lt;p&gt;我是文本&lt;/p&gt; 区别：html方法会识别html标签，text方法会那内容直接当成字符串，并不会识别html标签。 width() / height() 方法 设置或者获取高度 1234//带参数表示设置高度$(“img”).height(200);//不带参数获取高度$(“img”).height(); 获取网页的可视区宽高1234//获取可视区宽度$(window).width();//获取可视区高度$(window).height(); scrollTop与scrollLeft 设置或者获取垂直滚动条的位置距窗口的左侧的偏移量 距离顶部的偏移量 123456789//获取页面被卷曲的高度$(window).scrollTop();//获取页面被卷曲的宽度$(window).scrollLeft();$(window).scroll(function()&#123; console.log($(window).scrollTop()) console.log($(window).scrollLeft())&#125;) 固定导航案例 下滑到一定的长度 导航栏悬浮固定 12345678910111.判断卷的高度 与 topPart的高度2.大于 的话navbar 固定定位3.设置main 有marginTopif($(window).scrollTop() &gt;= $('.top').height())&#123; $('.nav').addClass('fixed') $('.main').css('marginTop',$('.nav').height() + 10)&#125;else&#123; $('.nav').removeClass('fixed') $('.main').css('marginTop',10)&#125; 小火箭返回顶部案例 当页面超出去1000px的时候，让小火箭显示出来,如果小于1000，就让小火箭隐藏 123456789101112131415161718 $(window).scroll(function()&#123; if($(window).scrollTop() &gt;= 1000)&#123; $('.actGop').stop().fadeIn(1000) &#125;else&#123; $('.actTop').stop().fadeOut(1000) &#125;&#125;)function getScroll()&#123; return &#123; left:window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0, top:window.pageXOffset || document.documentElement.scrollTop || document.body.scrollTop || 0 &#125;&#125;$('.actGotop').click(function()&#123; $('html,body').stop().animate(&#123;scrollTop:0&#125;,3000) // screenTop 为0 $(window).scrollTop(0)&#125;) offset方法与position方法 offset方法获取元素距离document的位置，position方法获取的是元素距离有定位的父元素的位置。 1234//获取元素距离document的位置,返回值为对象：&#123;left:100, top:100&#125;$(selector).offset();//获取相对于其最近的有定位的父元素的位置。$(selector).position(); jQuery事件机制 JavaScript中已经学习过了事件，但是jQuery对JavaScript事件进行了封装，增加并扩展了事件处理机制。jQuery不仅提供了更加优雅的事件处理语法，而且极大的增强了事件的处理能力。 jQuery事件发展历程(了解)简单事件绑定&gt;&gt;bind事件绑定&gt;&gt;delegate事件绑定&gt;&gt;on事件绑定(推荐) 12345678910111213141516171819202122231.bind() 方式 参数是一个对象，有多个时间的name，func 2.click() 方法 简单事件，给自己注册的事件3.delegate(ele.funname,callback) - 给父元素注册委托事件 最终还有子元素来执行 - 第一个参数 事件名 - 第二个参数 回调函数$('.section6 p').bind(&#123; // click:function()&#123; // console.log('p bind click') // &#125;, mouseenter:function()&#123; console.log('p bind mouseenter') &#125;,&#125;)$('.section6 div').click(function()&#123; console.log('selft click')&#125;)// 例子：给div 注册一个委托事件 最终不是由自己执行，而是由P执行$('.section6 #box').delegate('p','click',function()&#123; console.log(this) // &lt;p&gt;44444&lt;/p&gt;&#125;) 简单事件注册 123click(handler) 单击事件mouseenter(handler) 鼠标进入事件mouseleave(handler) 鼠标离开事件 缺点：不能同时注册多个事件 bind方式注册事件 12345//第一个参数：事件类型//第二个参数：事件处理程序$("p").bind("click mouseenter", function()&#123; //事件响应方法&#125;); 缺点：不支持动态事件绑定 delegate注册委托事件 123456// 第一个参数：selector，要绑定事件的元素// 第二个参数：事件类型// 第三个参数：事件处理函数$(".parentBox").delegate("p", "click", function()&#123; //为 .parentBox下面的所有的p标签绑定事件&#125;); 缺点：只能注册委托事件，因此注册时间需要记得方法太多了 on注册事件 on注册事件(重点) jQuery1.7之后，jQuery用on统一了所有事件的处理方法。 最现代的方式，兼容zepto(移动端类似jQuery的一个库)，强烈建议使用。 on注册简单事件12// 表示给$(selector)绑定事件，并且由自己触发，不支持动态绑定。$(selector).on( "click", function() &#123;&#125;); on注册委托事件12// 表示给$(selector)绑定代理事件，当必须是它的内部元素span才能触发这个事件，支持动态绑定$(selector).on( "click",“span”, function() &#123;&#125;); on注册事件的语法：12345// 第一个参数：events，绑定事件的名称可以是由空格分隔的多个事件（标准事件或者自定义事件）// 第二个参数：selector, 执行事件的后代元素（可选），如果没有后代元素，那么事件将有自己执行。// 第三个参数：data，传递给处理函数的数据，事件触发的时候通过event.data来使用（不常使用）// 第四个参数：handler，事件处理函数$(selector).on(events[,selector][,data],handler); 事件的执行顺序1234567891011121314151617181920/*- p自己注册事件 简单事件- 父级div自己执行- 给div 里面的p 执行委托事件- btn 自己注册事件 创建p添加div p无事件注册*/$('.section7 p').on('click', function ()&#123; console.log('.section7 p -&gt; on')&#125;)$('.section7 div').on('click',function()&#123; console.log('.section7 div -&gt; on')&#125;) $('.section7 div').on('click','.section7 p',function()&#123; console.log('.section7 div -&gt; (div .section7 p))')&#125;)$('.section7 #btn').on('click',function()&#123; $('&lt;p&gt;新创建的P元素&lt;/p&gt;').appendTo($('.section7 div'))&#125;) 表格删除功能 清空所有/ 删除一行 / 添加 一行 123456789101112131415161718192021 // 清空所有 empty 清空自己内部的所有组件$('.seciton8 clerarbtn').on('click',function()&#123; $('.seciton8 #j_tbody').empty()&#125;) // 删除一行 删除按钮 自己删除 / 代理onbody注册 ，让删除button执行// 1. remove 自己从父view 中移除$('.seciton8 .row_dele_btn').on('click',function()&#123; $(this).parent().parent().remove()&#125;) // 2$('.seciton8 #j_tbody').on('click','.seciton8 .row_dele_btn',function()&#123; $(this).parent().parent().remove()&#125;)// 添加一行$('.seciton8 .add_button').on('click',function()&#123; $('&lt;tr&gt; &lt;td&gt;jQuery111&lt;/td&gt; &lt;td&gt;adddrow11&lt;/td&gt; &lt;td&gt;&lt;a href="javascrip:;" class="row_dele_btn"&gt;DELETE&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt;').appendTo("#j_tbody");&#125;) 移除事件绑定 unbind方式（不用） 12$(selector).unbind(); //解绑所有的事件$(selector).unbind("click"); //解绑指定的事件 undelegate方式（不用） 12$( selector ).undelegate(); //解绑所有的delegate事件$( selector).undelegate( “click” ); //解绑所有的click事件 off方式（推荐） 1234// 解绑匹配元素的所有事件$(selector).off();// 解绑匹配元素的所有click事件$(selector).off("click"); 触发事件12$(selector).click(); //触发 click事件$(selector).trigger("click"); jQuery事件对象 jQuery事件对象其实就是js事件对象的一个封装，处理了兼容性。 12345678910//screenX和screenY 对应屏幕最左上角的值//clientX和clientY 距离页面左上角的位置（忽视滚动条）//pageX和pageY 距离页面最顶部的左上角的位置（会计算滚动条的距离）//event.keyCode 按下的键盘代码//event.data 存储绑定事件时传递的附加数据//event.stopPropagation() 阻止事件冒泡行为//event.preventDefault() 阻止浏览器默认行为//return false:既能阻止事件冒泡，又能阻止浏览器默认行为。 阻止冒泡和阻止浏览器的默认行为12345678910111213141516171819202122/*阻止 默认preventDefault() 阻止默认事件stopPropagation() 组织冒泡 return false 既能阻止事件冒泡 也能阻止浏览器的默认行为console.log(e.cancelBubble)*/ $('.section11 #link').on('click',function(e)&#123;// e.preventDefault() // e.stopPropagation() // alert('11') // alert之后继续跳转链接 // return false; // console.log(e.cancelBubble) // undefined&#125;)$('body').on('click',function()&#123; alert('112')&#125;) 五星级评分案例 点击之前的变实心 / 鼠标hover实实 变换 123456789101112131415161718192021222324252627/*1. 给li 注册鼠标经过事件 让自己和前面的兄弟都变实心2. 给ul 注册鼠标离开事件 让所有的li变成空心 2-1. 找到current 让current和current前面的变成实心 3.li注册点击事件 点击的加上current class 移除其他兄弟current*/var wjx_k = "☆";var wjx_s = "★"; //li mounseenter 之前的都变实心$('.section14 .comment&gt;li').on('mounseenter',function()&#123; $(this).text(wjx_s).prevAll().text(wjx_s) $(this).nextAll().text(wjx_k)&#125;)// li click 记录current$('.section14 .comment&gt;li').on('click',function()&#123; $(this).addClass('current').siblings().removeClass('current')&#125;)// ul 离开事件$('.section14 .comment').on('',function()&#123; // 所有的li 为空心 $(this).children().text(wjx_k) // Curren之前的类 -&gt; 实心 $('.comment&gt;li.current').text(wjx_s).prevAll().text(wjx_s)&#125;) jQuery补充知识点delay的用法123function funn15()&#123; $('.section12 div').css('display','block').fadeIn(1000).delay(8000).fadeOut(1000)&#125; 链式编程 通常情况下，只有设置操作才能把链式编程延续下去。因为获取操作的时候，会返回获取到的相应的值，无法返回 jQuery对象。 1end(); // 筛选选择器会改变jQuery对象的DOM对象，想要回复到上一次的状态，并且返回匹配元素之前的状态。 【案例：五角星评分案例.html】 each方法 jQuery的隐式迭代会对所有的DOM对象设置相同的值，但是如果我们需要给每一个对象设置不同的值的时候，就需要自己进行迭代了。 作用：遍历jQuery对象集合，为每个匹配的元素执行一个函数123// 参数一表示当前元素在所有匹配元素中的索引号// 参数二表示当前元素（DOM对象）$(selector).each(function(index,element)&#123;&#125;); 多库共存 jQuery使用$作为标示符，但是如果与其他框架中的$冲突时，jQuery可以释放$符的控制权. 1var c = $.noConflict();//释放$的控制权,并且把$的能力给了c]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery学习笔记02]]></title>
    <url>%2F2018%2F05%2F21%2F%E5%89%8D%E7%AB%AF%E6%8A%80%E5%B7%A7%2FjQuery02%2F</url>
    <content type="text"><![CDATA[jQuery方法 学习CSS/Class/attr/prop/show()/slideDown()/fadeIn()/自定义动画/动画队列/停止动画stop()/动态创建节点配合几个案例练习；tab栏切换/美女相册/轮播图/手风琴/城市选择/微博发布案例/弹幕效果 CSS操作 1.修改单个样式css(name,value) 1$('.section1 li').css('fontSize','20') 2.修改多个样式 css(k1,v1).css(k2,v2).css(k3,v3) css({key1:value1,key2:value2}) 12345678910// 链式$("li").css("backgroundColor", "pink").css("color", "red").css("fontSize", "32px");// 对象形式$("li").css(&#123; backgroundColor:"pink", color: "red", fontSize:"32px", border: "1px solid black"&#125;); 3.获取css 样式 css(name) 12345671.隐式迭代 全部设置，取出时按第一个2.设置操作的时候：会给jq内部的所有对象都设置上相同的值。3.获取的时候：只会返回第一个元素对应的值。$('.section1 li').eq(0).css('fontSize','20px')$('.section1 li').eq(1).css('fontSize','21px')$('.section1 li').eq(2).css('fontSize','22px')console.log($('.section1 li').css('fontSize')) // -&gt; 20px Class操作 增删改查判断1234567891011121314151617181920// 增1$('.section2 input').eq(0).click(function()&#123; $('li').addClass('basic')&#125;)// 增2$('.section2 input').eq(1).click(function()&#123; $('li').addClass('bigger')&#125;)// 删除1$('.section2 input').eq(2).click(function()&#123; $('li').removeClass('bigger')&#125;)// 判断$('.section2 input').eq(3).click(function()&#123; console.log($('li').hasClass('bigger'))&#125;)// 切换 有删除 没有添加 toggle$('.section2 input').eq(4).click(function()&#123; $('li').toggleClass('basic')&#125;) tab栏切换123456789function fun3()&#123; // tab 选中的添加active 其他的移除 active // main 选中添加selected 其他的移除 selected $('.tab .tab-item').mouseenter(function()&#123; $(this).addClass('active').siblings().removeClass('active') var index = $(this).index() $('.products .main').eq(index).addClass('selected').siblings().removeClass('selected') &#125;)&#125; 属性操作 标签的属性 img 的src / alt / title 等属性 样式：在style里面写的，用css来操作属性：在里面里面写的，用attr方法操作。 用法和css一样 单个/多个/获取 1234567 1. 单个attr(k1,v1) 2. 多个attr(k1,v1).attr(k2,v2) 3. attr(&#123;k1:v1,k2:v2,k3:v3&#125;) 4. attr(name) 获取name 的属性值$('.section4 img').attr('alt','XXXXX')console.log($('.section4 img').attr('alt')) 美女相册点击小图，显示大图并更换提示文字 把点击的a标签的文字，传入下面ID为image 的src中 a标签title 替换P标签的内容 123456789$('.section5 #imagegallery a').click(function()&#123; var asrc = $(this).attr('href') var astr = $(this).attr('title') $('#image').attr('src',asrc) $('#des').text(astr) return false // 组织默认操作&#125;) prop 方法 只设置bool 类型 使用方法和attr 一样 选中/不选中 获取bool类型 123456$('.section6 input').eq(0).click(function()&#123; $('#ck').prop('checked',true) &#125;)$('.section6 input').eq(1).click(function()&#123; $('#ck').prop('checked',false) &#125;) 表格全选案例 thead input -&gt; tbody inputtbody input 选择的个数 0 false， 总个数 true -&gt;(决定) thead input 1234567891011121314151. 头部全选 下面的所有的li状态跟着变$('#j_cbAll').click(function()&#123; var che = $(this).prop('checked') $('#j_tb input').prop('checked',che)&#125;)2.下面的全部选中，头部的input也选中$('#j_tb input').click(function()&#123; var chedinput = $('#j_tb input:checked') var all = $('#j_tb input') if(chedinput.length == all.length)&#123; $('#j_cbAll').prop('checked',true) &#125;else&#123; $('#j_cbAll').prop('checked',false) &#125;&#125;) 三组基本动画show() show()动画 不传参数没有动画效果 show(speed) speed:100/fast:200ms/normal:400ms/slow:600 show(speed,callback) 1234567891011121314151617$(".section8 input").eq(0).click(function()&#123; // show1.无参数直接显示 $('.section8 div').show() // show2设置速度 $('.section8 div').show('slow') // show3 设置回调 $('.section8 div').show(300,function()&#123; console.log('anomation done') &#125;)&#125;)$(".section8 input").eq(1).click(function () &#123; $("div").hide();&#125;) slideDowm() slideDowm() slideUp() 滑入滑出 如果不传参数，默认nomarl 400msslideToggle 如果时滑入 就执行滑出动画，切换动画 123456789$(".section8 input").eq(0).click(function()&#123; $('.section8 div').slideDown(1000)&#125;)$(".section8 input").eq(1).click(function () &#123; $("div").slideUp()&#125;)$(".section8 input").eq(2).click(function () &#123; $("div").slideToggle()&#125;) fadeIn() fadeIn() fadeOut() fadeToggle() 淡入/淡出/切换淡入淡出 123456789$(".section8 input").eq(0).click(function()&#123; $('.section8 div').fadeIn(1000)&#125;)$(".section8 input").eq(1).click(function () &#123; $("div").fadeOut()&#125;)$(".section8 input").eq(2).click(function () &#123; $("div").fadeToggle()&#125;) 下拉菜单案例 mouseover：鼠标经过事件 mouseout:鼠标离开事件 mouseenter:鼠标进入事件 mouseleave：鼠标离开事件 1234567891011var $li = $(".wrap&gt;ul&gt;li");//给li注册鼠标经过事件，让自己的ul显示出来$li.mouseenter(function () &#123; //找到所有的儿子，并且还得是ul //stop：停止当前正在执行的动画 $(this).children("ul").stop().slideDown();&#125;); $li.mouseleave(function () &#123; $(this).children("ul").stop().slideUp();&#125;); 京东轮播图 左右侧切换加动画 1234567891011121314151617181920var count = 0;$(".arrow-right").click(function () &#123; count++; if(count == $(".slider li").length)&#123; count = 0; &#125; console.log(count); //让count渐渐的显示，其他兄弟渐渐的隐藏 $(".slider li").eq(count).fadeIn().siblings("li").fadeOut();&#125;); $(".arrow-left").click(function () &#123; count--; if(count == -1)&#123; count = $(".slider li").length - 1; &#125; console.log(count); //让count渐渐的显示，其他兄弟渐渐的隐藏 $(".slider li").eq(count).fadeIn().siblings("li").fadeOut();&#125;) 自定义动画 自定义动画 animate(obj,speed,style,callback) 第一个参数时动画的样式对象 第二个参数 speed 动画的执行时间 第三个参数 动画的执行效果 第四个参数 回调函数 停止动画 stop(clearQueue,jumpToEnd) clearQueue 是否清除动画队列 jumpToEnd 是否跳转到当前动画的最终结果 123456789101112131415$('.section9 input').eq(0).click(function()&#123; // $('.section9 #box1').animate(&#123;left:800&#125;,10000) $('.section9 #box1').animate(&#123;left:800&#125;,5000,'swing') // swing 秋千 摇摆 $('.section9 #box2').animate(&#123;left:800&#125;,5000,'linear') // linear 匀速 $('.section9 #box3').animate(&#123;left:800&#125;,5000,'linear',function()&#123; console.log('animate done liner 5s') &#125;) &#125;)1. stop:停止当前正在执行的动画2. clearQueue:是否清除动画队列 true false3. jumpToEnd:是否跳转到当前动画的最终效果 true false4 .stop().animate();$('.section9 input').eq(1).click(function()&#123; $(".section9 #box1").stop(true, true);&#125;) 手风琴案例 设置所有的默认图片 li鼠标进入一个展开其他隐藏 移除鼠标 全部设置默认值 1234567891011121314function fun12()&#123; // ul -&gt;6li li上 // 设置背景图 var lis = $('.section10 #box li') for (let i = 0; i &lt; lis.length; i++) &#123; lis.eq(i).css('backgroundImage','url(images/14-' + (i +1 ) + '.jpg)') &#125; // 所有的li 注册鼠标进入事件 lis.mouseenter(function()&#123; $(this).stop().animate(&#123;width:800&#125;).siblings().stop().animate(&#123;width:100&#125;) &#125;).mouseleave(function()&#123; lis.stop().animate(&#123;width:240&#125;) &#125;)&#125; 动画队列 把这些动画存储到一个动画队列里面 12345678910function fun13()&#123; $('.section11 #btn').click(function()&#123; $('.section11 div').animate(&#123;left:800&#125;) .animate(&#123;top:400&#125;) .animate(&#123;width:300,height:300&#125;) .animate(&#123;top:0&#125;) .animate(&#123;left:0&#125;) .animate(&#123;width:100,height:100&#125;) &#125;)&#125; jQuery 创建添加节点 移动到里面 ：append appendTo prepend prependTo ；追加到前后： after before 123456789101112131415161718// 创建jq对象var lis = $('&lt;a href="https://www.baidu.com" target="_blank"&gt;百度一下你不就知道')console.log(lis)$('.section12 div').append('&lt;a href="https://www.baidu.com" target="_blank"&gt;百度一下你不就知道') // 添加到子元素的最后面$('.section12 div').append($('p'))$('p').appendTo($('.section12 div'))// 添加到元素的前面$('.section12 div').prepend($('p'))$('p').prependTo($('.section12 div'))// after before $('.section12 div').after($("p"));$('.section12 div').before($("p")); 城市选择 案例 点击 &gt;&gt; &lt;&lt; &gt; &lt; 出发方法 全部移动 和选中部分移动 123456789101112131415161718192021 // &gt;&gt;$('.section13 #btn1').click(function()&#123; // 全部移入右边 $('#src-city&gt;option').appendTo($('#tar-city'))&#125;)// &lt;&lt;$('.section13 #btn2').click(function()&#123; // $('#tar-city&gt;option').appendTo($('#src-city')) $('#src-city').append($('#tar-city&gt;option'))&#125;)// &gt; $('.section13 #btn3').click(function()&#123; $('#src-city&gt;option:selected').appendTo($('#tar-city'))&#125;)// &lt;$('.section13 #btn4').click(function()&#123; $('#src-city').append($('#tar-city&gt;option:selected'))&#125;) 微博发布案例 将输入框文字 创建一个li 拼接到 ul 中 并将输入框清空 1234567891011121314151.获取input 的内容 $('input').val().trim() 判断长度2.拼接到后面的ul中 3.清空输入框$('.section14 #btn').click(function()&#123; var atext = $('.section14 #txt').val() if (atext.trim().length == 0)&#123; return &#125; // appendTo 拼入组件 在后面 // prependTo 拼入组件 在前面 $('&lt;li&gt;&lt;/li&gt;').text(atext).prependTo('.section14 #ul') // 清空输入框 $('.section14 #txt').val("")&#125;) 清空节点 删除节点 清空一个元素 html(&#39;&#39;) empty() remove() 复制节点 clone(bool) html(‘’) 会内存泄漏 清理门户 empty() remove() 复制节点 clone(bool) 参数bool 默认是false false 的时候深度复制，不会复制事件 true 深复制 会复制事件 1234567891011121314 1.深复制事件 $('.section15 .des').click(function()&#123; alert('p click') &#125;)$('.section15 .des').clone(true).appendTo('.section15 div')-------// 1$('.section15 div').html('')// 2$('.section15 div').empty()// 3$('.section15 div').remove() 弹幕效果 随机 XY 从右侧动画进入，出界面 隐藏123456&gt; 1. 随机色&gt; 2. 根据input内容 创建span &gt; 3 设置css 颜色 初始的left top 值（style中绝对定位） &gt; 4.设置动画 animate 5秒之内 left 修改为-1000 ，动画结束 移除span &gt; 5.清空输入输入框&gt; 6.监听键盘 keycode==13 的时候 出发发射按钮 12345678910111213141516171819202122232425262728var colors = ["red", "green", "hotpink", "pink", "cyan", "yellowgreen", "purple", "deepskyblue"]; $('.section16 #btn').click(function()&#123; var randcolor = colors[parseInt(Math.random()*colors.length)] var randy = parseInt(Math.random()*400) var atxe = $('.section16 #text').val() if(atxe.trim().length == 0) &#123;return &#125; $('&lt;span&gt;&lt;/span&gt;').text(atxe) .css('color',randcolor) .css('left','1400px') .css('top',randy) .animate(&#123;left:'-100px'&#125;,8000, 'linear',function()&#123; $(this).remove() &#125;) .appendTo('.section16 #boxDom') $('.section16 #text').val('')&#125;)// 回车触发$('.section16 #text').keyup(function(el)&#123; if(el.keyCode == 13)&#123; $('.section16 #btn').click() &#125;&#125;)]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery学习笔记01]]></title>
    <url>%2F2018%2F05%2F21%2F%E5%89%8D%E7%AB%AF%E6%8A%80%E5%B7%A7%2FjQuery01%2F</url>
    <content type="text"><![CDATA[jQuery基本概念 学习目标：学会如何使用jQuery，掌握jQuery的常用api，能够使用jQuery实现常见的效果。 为什么要学习jQuery？【01-让div显示与设置内容.html】 使用javascript开发过程中，有许多的缺点： 123451. 查找元素的方法太少，麻烦。2. 遍历伪数组很麻烦，通常要嵌套一大堆的for循环。3. 有兼容性问题。4. 想要实现简单的动画效果，也很麻烦5. 代码冗余。 jQuery初体验【02-让div显示与设置内容.html】 12345678910$(document).ready(function () &#123; $("#btn1").click(function () &#123; //隐式迭代：偷偷的遍历，在jQuery中，不需要手动写for循环了，会自动进行遍历。 $("div").show(200); &#125;); $("#btn2").click(function () &#123; $("div").text("我是内容"); &#125;);&#125;); 优点总结： 123451. 查找元素的方法多种多样，非常灵活2. 拥有隐式迭代特性，因此不再需要手写for循环了。3. 完全没有兼容性问题。4. 实现动画非常简单，而且功能更加的强大。5. 代码简单、粗暴。 没有对比，就没有伤害，有了对比，处处戳中要害。 什么是jQuery? jQuery的官网 http://jquery.com/jQuery就是一个js库，使用jQuery的话，会比使用JavaScript更简单。 js库：把一些常用到的方法写到一个单独的js文件，使用的时候直接去引用这js文件就可以了。（animate.js、common.js） 我们知道了，jQuery其实就是一个js文件，里面封装了一大堆的方法方便我们的开发，其实就是一个加强版的common.js，因此我们学习jQuery，其实就是学习jQuery这个js文件中封装的一大堆方法。 jQuery的版本 官网下载地址：http://jquery.com/download/jQuery版本有很多，分为1.x 2.x 3.x 大版本分类： 123451.x版本：能够兼容IE678浏览器2.x版本：不兼容IE678浏览器1.x和2.x版本jquery都不再更新版本了，现在只更新3.x版本。3.x版本：不兼容IE678，更加的精简（在国内不流行，因为国内使用jQuery的主要目的就是兼容IE678） 关于压缩版和未压缩版 12jquery-1.12.4.min.js:压缩版本，适用于生产环境，因为文件比较小，去除了注释、换行、空格等东西，但是基本没有颗阅读性。jquery-1.12.4.js:未压缩版本，适用于学习与开发环境，源码清晰，易阅读。 jQuery的入口函数使用jQuery的三个步骤： 1231. 引入jQuery文件2. 入口函数3. 功能实现 关于jQuery的入口函数： 12345678//第一种写法$(document).ready(function() &#123; &#125;);//第二种写法$(function() &#123; &#125;); jQuery入口函数与js入口函数的对比 121.JavaScript的入口函数要等到页面中所有资源（包括图片、文件）加载完成才开始执行。2.jQuery的入口函数只会等待文档树加载完成就开始执行，并不会等待图片、文件的加载。 jQuery对象与DOM对象的区别（重点）12341. DOM对象：使用JavaScript中的方法获取页面中的元素返回的对象就是dom对象。2. jQuery对象：jquery对象就是使用jquery的方法获取页面中的元素返回的对象就是jQuery对象。3. jQuery对象其实就是DOM对象的包装集（包装了DOM对象的集合（伪数组））4. DOM对象与jQuery对象的方法不能混用。 DOM对象转换成jQuery对象： 12var $obj = $(domObj);// $(document).ready(function()&#123;&#125;);就是典型的DOM对象转jQuery对象 jQuery对象转换成DOM对象： 12345var $li = $(“li”);//第一种方法（推荐使用）$li[0]//第二种方法$li.get(0) 【练习：隔行变色案例.html】 选择器什么是jQuery选择器jQuery选择器是jQuery为我们提供的一组方法，让我们更加方便的获取到页面中的元素。注意：jQuery选择器返回的是jQuery对象。 jQuery选择器有很多，基本兼容了CSS1到CSS3所有的选择器，并且jQuery还添加了很多更加复杂的选择器。【查看jQuery文档】 jQuery选择器虽然很多，但是选择器之间可以相互替代，就是说获取一个元素，你会有很多种方法获取到。所以我们平时真正能用到的只是少数的最常用的选择器。 基本选择器 名称 用法 描述 ID选择器 $(“#id”); 获取指定ID的元素 类选择器 $(“.class”); 获取同一类class的元素 标签选择器 $(“div”); 获取同一类标签的所有元素 并集选择器 $(“div,p,li”); 使用逗号分隔，只要符合条件之一就可。 交集选择器 $(“div.redClass”); 获取class为redClass的div元素 总结：跟css的选择器用法一模一样。 层级选择器 名称 用法 描述 子代选择器 $(“ul&gt;li”); 使用&gt;号，获取儿子层级的元素，注意，并不会获取孙子层级的元素 后代选择器 $(“ul li”); 使用空格，代表后代选择器，获取ul下的所有li元素，包括孙子等 跟CSS的选择器一模一样。 过滤选择器 这类选择器都带冒号: 名称 用法 描述 :eq（index） $(“li:eq(2)”).css(“color”, ”red”); 获取到的li元素中，选择索引号为2的元素，索引号index从0开始。 :odd $(“li:odd”).css(“color”, ”red”); 获取到的li元素中，选择索引号为奇数的元素 :even $(“li:even”).css(“color”, ”red”); 获取到的li元素中，选择索引号为偶数的元素 【案例：隔行变色】 筛选选择器(方法) 筛选选择器的功能与过滤选择器有点类似，但是用法不一样，筛选选择器主要是方法。 名称 用法 描述 children(selector) $(“ul”).children(“li”) 相当于$(“ul&gt;li”)，子类选择器 find(selector) $(“ul”).find(“li”); 相当于$(“ul li”),后代选择器 siblings(selector) $(“#first”).siblings(“li”); 查找兄弟节点，不包括自己本身。 parent() $(“#first”).parent(); 查找父亲 eq(index) $(“li”).eq(2); 相当于$(“li:eq(2)”),index从0开始 next() $(“li”).next() 找下一个兄弟 prev() $(“li”).prev() 找上一次兄弟 1234【案例：下拉菜单】this+children+mouseenter+mouseleave【案例：突出展示】siblings+find【案例：手风琴】next+parent【案例：淘宝精品】index+eq]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[W3C-HTML补充]]></title>
    <url>%2F2018%2F05%2F02%2F%E5%89%8D%E7%AB%AF%E6%8A%80%E5%B7%A7%2Fw3cschool-html%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[html介绍HTMLBase 相对链接设置基本的URL 也指定在永华点击链接时打开链接 以及在表单提交后浏览器行为；两个局部属性 href target href属性 置顶基本URL将解析文档中的相对的URL 123456789101112131415161718&lt;html&gt;&lt;head&gt; &lt;title&gt;Example&lt;/title&gt; &lt;base href="//www.w3cschool.cn/listings/"/&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;This is a test.&lt;/p&gt; &lt;a class='linka1' href="https://www.w3cschool.cn"&gt;Visit www.w3cschool.cn&lt;/a&gt; &lt;a class='linka2' href="/javascript.html"&gt;JavaScript&lt;/a&gt; &lt;a class='linka3' &gt;JavaScript&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;解析：1.在base中设置了href = //www.w3cschool.cn/listings/ ；设置了www.w3cschool.cn 服务器的名i 名称 设置了listings 服务器上的目录 2.linka1 制定了href 直接域名跳转3.linka2 指定了相对地址，那么浏览器就是域名相对地址4.不指定href 跳转上面base中设置的href meta元数据123456789101112131415161.meta的局部属性有 name content charset http-equiv 2.robots 元数据类型被广泛使用。它允许HTML文档的作者指定文档应如何被搜索引擎处理。 - noindex 不要索引此页面 - noarchive 不要创建此页面的存档或缓存版本 - nofollow 不要追踪（即抓取）此页面的链接3. http-equiv 设置 refresh ；content头设置为5，它要求浏览器每五秒重新加载页面。4. 如果content时时间和URL逗号分开，浏览器将在间隔过去之后加载指定的URL &lt;head&gt; &lt;title&gt;Example&lt;/title&gt; &lt;meta name="author" content="www.w3cschool.cn"/&gt; &lt;meta name="description" content="A simple example"/&gt; &lt;meta charset="utf-8"/&gt; &lt;meta http-equiv="refresh" content="5"/&gt; &lt;meta http-equiv="refresh" content="3; http://www.www.w3cschool.cn"/&gt;&lt;/head&gt; 元数据名称 描述 application name 当前页面所属Web应用程序的名称 author 作者 description 描述 generator 生成HTML的软件名称 keywords 关键字 多个用逗号隔开 HTML样式 style 具有属性 type media scoped；type始终为text/css media属性 允许指定将样式应用于文档为方式时间 1234567891011121314151617&lt;head&gt;&lt;style media="screen" type="text/css"&gt;a &#123; background-color: grey; color: white; padding: 0.5em;&#125;&lt;/style&gt;&lt;style media="print"&gt;a&#123; color:Red; font-weight:bold; font-style:italic&#125;&lt;/style&gt;&lt;/head&gt;当HTML在屏幕上显示时，浏览器将应用第一个样式，和打印页面时的第二种样式。 各种条件 设备 描述 all 默认值。任何设备 aural 语音合成器 braile 盲文设备 handheld 手持设备 projection 投影机 print 打印预览和打印页面时应用此样式 screen 显示在计算机屏幕上时应用此样式 tty 式应用于固定宽度的设备，例如电传 tv 电视 style 其他特性 根据宽度多种样式12345678910111213&lt;style media="screen AND (max-width:500px)" type="text/css"&gt;a &#123; background-color: grey; color: white; padding: 0.5em;&#125;&lt;/style&gt;&lt;style media="screen AND (min-width:500px)" type="text/css"&gt;a &#123; color:Red; font-style:italic;&#125;&lt;/style&gt; key value example width 指定浏览器窗口的宽度 width:200px height 指定浏览器窗口的高度 height:200px device-width 指定整个设备的宽度，而不仅仅是浏览器窗口 min-device-width:200px device-height 指定整个设备的高度，而不仅仅是浏览器窗口 min-device-height:200px resolution 指定设备的像素密度 max-resolution:600dp orientation 指定设备的方向;纵向和横向 orientation:portrait aspect-ratio 浏览器窗口设备的像素比率 aspect-ratio:16/9 device-aspect-ratio 定浏览器窗口或整个设备的像素比率 min-aspect-ratio:16/9 color monochrome 指定彩色或单色设备每像素的位数 min-monochrome:2 color-index 指定显示可以显示的颜色数 max-color-index:256 scan 指定电视的扫描模式。支持的值是渐进和交错 scan:interlace grid 指定设备的类型。网格设备使用固定网格显示内容;支持的值为0和1，其中1是网格设备 grid:0 资源链接 link 具有局部属性 href / rel / hreflang / media / type / sizes href 指定URL hreflang指定链接资源的语言 media 指定链接内容用于的设备 rel 指定文档与链接资源之间的关系类型 sizes 指定图表的大小 type 指定资源的MIME类型，例如text/css image/x-icon rel 决定浏览器如何处理link元素 stylesheet 加载外部的css样式表 prefetch 预加载资源 pingbak 指定pingback服务器，允许当其他网站链接到博客自动通知博客 license 指向与当前文档相关联的许可证的链接 icon 指定图表资源 help 与当前文档相关的帮助的链接 author 链接到文档的作者 alternate 指向文档替代版本的链接 sizes 属性已在HTML5中添加，属性 charset ， rev 和 target 在HTML5中已过时。 Script1231.script元素具有局部属性: type，src，defer，async，charset 2.defer 属性指示浏览器在页面加载和解析之前不执行脚本。当浏览器遇到具有defer属性的脚本时，它会阻止加载和执行脚本，直到HTML文档中的所有元素都已解析为止3.当使用 async 属性时，浏览器会异步加载和执行脚本，同时继续解析HTML中的其他元素，包括其他脚本元素 HTML 基本标签1.hgroup 元素允许您处理多个标头元素作为单个项目，而不会影响HTML文档的大纲。 1234 &lt;hgroup&gt; &lt;h1&gt;H1&lt;/h1&gt; &lt;h2&gt;H2&lt;/h2&gt;&lt;/hgroup&gt; 2.pre 预格式化内容 效果如下 var fruits = ["XML", "HTML", "CSS", "Java"]; for (var i = 0; i < fruits.length; i++) { document.writeln("I like " + fruits[i]); } 12345678&lt;pre&gt; &lt;code&gt; var fruits = ["XML", "HTML", "CSS", "Java"]; for (var i = 0; i &lt; fruits.length; i++) &#123; document.writeln("I like " + fruits[i]); &#125; &lt;/code&gt;&lt;/pre&gt; 3.HTML引用 blockquote blockquote 元素表示从另一个来源引用的块内容。;这个元素类似于 q 元素，但通常适用于较大数量的引用内容。可以使用 cite 属性以提供内容的原始源的URL。 123456&lt;body&gt; &lt;blockquote cite="http://en.wikipedia.org/wiki/Cascading_Style_Sheets"&gt; Cascading Style Sheets (CSS) is a style sheet language used for describing the look and formatting of a document written in a markup language. &lt;/blockquote&gt;&lt;/body&gt; HTML 页面内容 Article 标签;section元素应用于包含内容将在文档的大纲或目录中列出。nav 元素表示文档的一个部分包含到其他页面或同一页面的其他部分的链接。此元素标识文档的主要导航部分。details 元素创建一个节，用户可以展开该节以获取有关主题的更多详细信息。details 元素通常包含一个摘要元素，用于为详细信息部分创建标签或标题。header 元素表示节的标题。它可以包含任何您想要表示为头部的内容。footer 元素是页眉的补充，表示部分的页脚。页脚通常包含关于版块的摘要信息，并且可以包括作者的详细信息，权限信息。aside 元素表示仅与周围元素相关的内容。这类似于书或杂志中的侧边栏。 HTML 超链接 a标签 具有属性 href hreflang media rel target typehref地址： https / ftp / mailto； 例如， mailto:info@example.com href 外部看链接；在base中设置了绝对路径相对网址 ；内部超链接ID classname Target浏览器上下文 _blank 在新窗口中打开文档 _parent 打开父框架集中的文档 _self 在当前窗口中打开默认的 _top 在窗口中整个主题中打开文档 &lt;frame&gt; 在指定的框架中打开文档 :link :visited :hover :active LAHV HTML 格式化 abbr 标签元素表示缩写；可以使用 title 属性来提供缩写代表的扩展文本。 12345&lt;body&gt; The &lt;abbr title="Cascading Style Sheets"&gt;CSS&lt;/abbr&gt; is a style sheet language used for describing the look and formatting of a document written in a markup language.&lt;/body&gt; address元素 标记文档或文章元素的联系信息 121.当address元素是article元素的后代时，假定提供该文章的联系信息。2.当address元素是body元素的子代，并且在body和address元素之间没有article元素时，假设地址为整个文档提供联系信息。 b 元素标记指示任何额外强调或重要性的文本跨度I like HTML and CSS. 1I like &lt;b&gt;HTML&lt;/b&gt; and &lt;b&gt;CSS&lt;/b&gt;. bdi元素 bdi 元素标记为了文本方向性而与其他内容隔离的文本 bdo元素 指定一个明确的文本方向其内容，覆盖通常应用的自动方向性 cite元素 表示引用作品的标题，这样的书，文章或电影。它的样式约定是cite {font-style:italic; }。 code元素 元素标记了一段计算机代码 它的默认样式是 {font-family:monospace;} del元素 del 元素有两个局部属性: cite，datetime cite 属性指定文档的URL这解释了为什么文本被删除， datetime 属性指定进行修改的时间。 dfn元素 定义一个术语。它解释了词或短语的意义。The CSS 1The &lt;dfn title="Cascading Style Sheets"&gt;CSS&lt;/dfn&gt; em元素 表示具有强调应力的文本跨度I like HTML and CSS. 1&lt;em&gt;I&lt;/em&gt; like &lt;b&gt;HTML&lt;/b&gt; and &lt;b&gt;CSS&lt;/b&gt;. i元素 素表示文本具有与周围内容不同的性质 ins元素 ins 元素标记添加的文本I like HTML. 1&lt;ins&gt;I like &lt;mark&gt;HTML&lt;/mark&gt;.&lt;/ins&gt; kbd元素 表示用户输入This is an input. 1This is an &lt;kbd&gt;input&lt;/kbd&gt;. mark元素 是HTML5和表示突出显示的文本I like CSS. 1I like &lt;mark&gt;CSS&lt;/mark&gt;. ruby rt rp元素 Ruby字符是放置在字符上方或右侧的符号在诸如中文或日语的标志语言中帮助读者正确地发音字符。 ruby 元素表示一段文本包含一个ruby。您使用 ruby 元素元素 rt 和 rp 。 rt 元素标记ruby符号，而 rp 元素表示注释周围的圆括号由不支持ruby注释的浏览器显示。 rt 元素标记ruby符号，而 rp 元素表示注释周围的圆括号由不支持ruby注释的浏览器显示。CSS(Cascading Style Sheets)123456&lt;ruby&gt; CSS &lt;rp&gt;(&lt;/rp&gt; &lt;rt&gt;Cascading Style Sheets&lt;/rt&gt; &lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt; s元素 来标记文本不再正确或准确。样式约定是使用通过它绘制的线来显示文本: s {text-decoration:line-through;}HTML is now HTML4 HTML5. 1HTML is now &lt;s&gt;HTML4&lt;/s&gt; HTML5. samp元素 示来自程序或计算机系统的输出 small元素 标记精细打印和经常用于免责声明和澄清 strong元素. 元素标记重要的文本。 sub和sup元素. 分别表示下标和上标 time元素 time 元素有两个局部属性: datetime，pubdate 。如果存在布尔 pubdate 属性，那么时间元素假定为的发布日期整个HTML文档或最近的article元素 12345I bought a book at &lt;time datetime="15:00"&gt;3 o"clock&lt;/time&gt; on &lt;time datetime="2012-12-7"&gt;December 7th&lt;/time&gt; . u元素. 素通过添加下划线标记文本 var元素 var 元素标记编程上下文中的变量。 wbr元素 wbr称为安全断路。 12345This is a test: Super &lt;wbr&gt; loooooooooooooooooooooooooong &lt;wbr&gt; HTML列表 ul/li;ol/li 每个列表项都显示一个项目符号。您可以通过 list-style-typeCSS属性来控制要使用哪个样式项目符号。 HTML figure figure 和 figcaption 元素 figure标签规定独立的流内容（图像、图表、照片、代码等等） figcaption元素被用来为figure元素定义标题。 1234567&lt;figure&gt;&lt;figcaption&gt;Listing 01. Using the code element&lt;/figcaption&gt;&lt;code&gt; var fruits = ["CSS", "HTML", "CSS", "Javascript"];&lt;br&gt; document.writeln("I like " + fruits.length + " fruits");&lt;/code&gt;&lt;/figure&gt; HTML 图像 img 局部属性: src，alt，height，width，usemap，ismap 图像链接 &lt;a href=&quot;//www.w3cschool.cn/page.html&quot;&gt; &lt;img ismap src=&quot;http://www.www.w3cschool.cn/style/download.png&quot;/&gt; &lt;/a&gt; 客户端图像映射 客户端图像映射 客户端图像映射的关键元素是 map 与局部属性 name如果使用 id 属性，它必须具有与 name 属性相同的值。 map 元素可以有一个或多个 area 元素。shape 和 coords 属性一起工作。 coords 属性取决于 shape 属性的值。 shape 和 coords 属性一起工作。 coords 属性取决于 shape 属性的值。 rect 该值表示矩形区域。 coords属性必须由四个逗号分隔的整数组成，表示与以下内容的距离： 图像左边缘到矩形左边 图像顶边到矩形顶边 图像左边缘到矩形右边 图像顶边到矩形底边 circle 圆形区域。coords属性必须由三个逗号分隔的整数组成，表示以下内容： 从图像左边缘到圆心的距离 从图像顶边缘到圆心的距离 圆的半径 poly 此值表示多边形。 coords属性必须至少为六个逗号分隔的整数，每对表示多边形上的一个点 default 此值是默认区域，覆盖整个图像的其余部分。 将此值用于shape属性时，不需要坐标值 &lt;p&gt; &lt;img src="http://www.www.w3cschool.cn/style/download.png" usemap="#mymap"/&gt; &lt;/p&gt; &lt;map name="mymap"&gt; &lt;area href="a.html" shape="rect" coords="3,5,68,62" alt="test a" /&gt; &lt;area href="b.html" shape="rect" coords="70,5,130,62" alt="test b" /&gt; &lt;area href="c.html" shape="default" alt="test c" /&gt; &lt;/map&gt;]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[W3C-HTML]]></title>
    <url>%2F2018%2F05%2F01%2F%E5%89%8D%E7%AB%AF%E6%8A%80%E5%B7%A7%2Fw3cschool-html%2F</url>
    <content type="text"><![CDATA[基础元素文本格式化 加粗字体 / 斜体 / 大号字体 / 小号字体 / 下标 / 上标 / 插入字 / 删除字计算机输出标签：code/kbd/samp/var/pre引用，引文，标签定义 abbr/address/dbo/q/blockquote/cite/dfn 格式字体 123456789101112&lt;b&gt;加粗字体&lt;/b&gt;&lt;i&gt;斜体&lt;i&gt;---------------&lt;strong&gt;加粗字体&lt;/strong&gt;&lt;em&gt;斜体文字&lt;/em&gt;&lt;big&gt;字体放大&lt;/big&gt;&lt;small&gt;字体缩小&lt;/small&gt;&lt;sub&gt;下标&lt;/sub&gt;&lt;sup&gt;上标&lt;/sup&gt; 预格式文本 12345&lt;pre&gt;演示使用pre标签。 这里的空格 回车会保留输出&lt;/pre&gt; 计算机输出文本标签 12345678910111.这些标签常用于显示计算机/编程代码&lt;code&gt;计算机输出格式&lt;/code&gt;&lt;kbd&gt;键盘输入格式&lt;/kbd&gt;&lt;tt&gt;打字机文本&lt;/tt&gt;&lt;samp&gt;计算机代码样本&lt;/samp&gt;&lt;var&gt;计算机变量&lt;/var&gt; address 标签 1234567&lt;adress&gt; Written by &lt;a href="#"&gt;Jon Doe&lt;/a&gt;.&lt;br&gt; Visit us at:&lt;br&gt; Example.com&lt;br&gt; Box 564, Disneyland&lt;br&gt; USA&lt;/adress&gt; 缩写 /首字母缩写 123451.鼠标移入缩略语上，title会展示全部的文字&lt;abbr title="etcetera"&gt;etc.&lt;/abbr&gt;&lt;acronym title="world wide web"&gt;www&lt;/acronym&gt; 文字显示方向 1234561.下面的文字右向左显示&lt;p&gt;&lt;bdo&gt;我的文字是从右向左显示的&lt;/bdo&gt;&lt;/p&gt; 块饮用 123456&lt;p&gt;这是外面的文字 &lt;q&gt; 这是内部引入的文字 &lt;/q&gt;&lt;p&gt; 标记删除的文本/新替换的文本 12341.del 标签标识删除 ins标识替换的内容&lt;p&gt;世界上最伟大的语言是&lt;del&gt;Swift&lt;/del&gt; &lt;ins&gt;PHP&lt;/ins&gt;&lt;/p&gt; a标签链接 href / target / id 描述 href 指向的地址 12345671.href='/index.html' 指向本网站的一个页面2.href='https://wwww.xxx.com' 指向一个外部网址链接3.href='#' 一个空链接&lt;a href='/index.html'&gt;内部其他页面&lt;/a&gt;&lt;a href='http://www.may.com'&gt;外部网址&lt;/a&gt;&lt;a href='#'&gt;空地址&lt;/a&gt; target窗口打开方式 12345671.默认是空，可以设置为_blank/_top2.空本标签页打开 _blank 是新开窗口打开3._top 情况下 如果网址是根目录，并且返回最顶部 &lt;a href='https://www.baidu.com' target=''&gt;访问链接1&lt;/a&gt;&lt;a href='https://www.baidu.com' target='_blank'&gt;访问链接1&lt;/a&gt;&lt;a href="http://www.w3cschool.cn/" target="_top"&gt;点击这里!&lt;/a&gt; id 用于创建书签，跳转到一个ID相同元素位置 123451.已经存在一个id为tips 的元素2.三种方式跳转到上面元素的位置2.1 a标签内 id='tips'2.2 a href='#tips'2.3 a href='//www.w3cschool.cn/html_links.html#tips' 发送邮件 123456789101112131415161.电子邮件链接 mailto: 2.单词之间的空格使用%20代替 以确保浏览器可以正常显示&lt;p&gt;下面的是电子邮件链接&lt;p&gt;&lt;a href='mailto:ytxinana@163.com?Subject=Hellow%20email' target='_top'&gt;点击发送邮件&lt;a/&gt;3.更复杂的电子邮件 mailto:收件人?cc=抄送人&amp;bcc=密送人&amp;subject=主题&amp;body=正文&lt;p&gt;这是另一个电子邮件链接： &lt;a href="mailto:someone@example.com? cc=someoneelse@example.com&amp; bcc=andsomeoneelse@example.com&amp; subject=Summer%20Party&amp; body=You%20are%20invited%20to%20a%20big%20summer%20party!" target="_top"&gt;发送邮件!&lt;/a&gt;&lt;/p&gt; 头部 heade 标签 可以在头部区域添加的元素标签：title/base/meta/style/link/script/noscript base 定义所有链接的URL 123456789101.在head中配置 base 标签 该标签指定了所有的链接的默认url2.在body中img标签 设置的是相对地址，base中设置了URL，所有能正常访问3.在body中的a 标签 ，设置了绝对地址，但是没有设置taget跳转方式，base标签中设置了，点击链接，新开界面跳转&lt;head&gt; &lt;base href="http://www.w3cschool.cn/statics/images/w3c/" target="_blank"&gt;&lt;/head&gt;&lt;body&gt;&lt;img src='logo.png'&gt;&lt;a href='http://www.baidu.com'&gt;点击链接跳转&lt;/a&gt;&lt;/body&gt; meta 描述 html 文档的描述/关键词/作者/字符集 123456789101. 单标签 格式是name='' content=''&lt;meta name='keywords' content='html,css,xmk.js'&gt;&lt;meta name='description' content='html and css'&gt;&lt;meta name='auton' content='HH'&gt;&lt;!--美30秒刷新当前页面--&gt;&lt;meta http-equiv='refresh' content='30'&gt; link 元素 定义了文档与外部资源的关系 通常链接到样式css 123&lt;head&gt;&lt;link rel='stylesheet' type='text/css' href='mystyle.css'&gt;&lt;/head&gt; style元素 定义了html文档的样式文件引用地址 在style 中定义css样式 script元素 用于加载脚本文件 javascript CSS百科及常用嵌入方式 内联样式 / 内部样式 / 外部样式 img图像 必须要有的两个属性 src / alt; width/height 宽高可选； 是空标签，包含属性，并且没有闭合标签 &lt;img src=&#39;url&#39; alt=&#39;some_text&#39;&gt; src属性 可以是文件夹地址，可以是网络地址 alt属性；替换文本； 图片无法加载的时候，替换文本会告知信息 width/height 设置图像的高度/宽度 align 文本和图像对其方式 12341. align值可选 top/ bottom / middle / 默认是底部对其2. html5 之后已经废弃&lt;p&gt;这是一些文本。 &lt;img src="/statics/images/course/smiley.gif" alt="Smiley face" align="middle" width="32" height="32"&gt;这是一些文本。&lt;/p&gt; float:left 图片浮动的方式 123451. style="float:right"2. html5已经废弃&lt;p&gt;&lt;img src="/statics/images/course/smiley.gif" alt="Smiley face" style="float:right" width="32" height="32"&gt; 一个带图片的段落，图片浮动在这个文本的右边。&lt;/p&gt; 创建图片映像 分别监听图片点击的某一部分 123456789101112131415161.原图 usemap='#planemap'2.&lt;map&gt; 定义图像地图3.&lt;area&gt; 定义图像地图中可以点击区域4. area 的属性 alt/shanpe/coords/target/href/ - rect 的时候 coords ='x1,y1,x2,y2' - circ 的时候 coords ='x,y,radius' &lt;p&gt;点击太阳或其他行星，注意变化：&lt;/p&gt;&lt;img src="/statics/images/course/planets.gif" width="145" height="126" alt="Planets" usemap="#planetmap"&gt;&lt;map name="planetmap"&gt; &lt;area shape="rect" coords="0,0,82,126" target="_blank" alt="Sun" href="/statics/images/course/sun.gif"&gt; &lt;area shape="circle" coords="90,58,3" target="_blank" alt="Mercury" href="/statics/images/course/merglobe.gif"&gt; &lt;area shape="circle" coords="124,58,8" target="_blank" alt="Venus" href="/statics/images/course/venglobe.gif"&gt;&lt;/map&gt; table 表格12345678910111213141516171819html表格结构1.&lt;table&gt;&lt;/table&gt; 定义表格 &lt;thead&gt;&lt;/thead&gt; 头部 &lt;tbody&gt;&lt;/tbody&gt; 内容2.&lt;tr&gt;&lt;/tr&gt; 定义行3.&lt;th&gt;&lt;/th&gt; 定义列 标题栏的列4.&lt;td&gt;&lt;/td&gt; 定义列 普通的列5.常用的标签table 定义表格 th 定义头tr 定义行td 定义列caption 表格的标题colgroup 定义表格列的组col 定义列的属性thead 表格的页眉tbody 表格主体tfoot 表格的页脚 表格边框属 boder=&#39;1&#39; 表头 th 1234561.在th标签中定义2.设置主要的公共属性 align / dir / width / height&lt;tr&gt; &lt;th&gt;Header 1&lt;/th&gt; &lt;th&gt;Header 2&lt;/th&gt;&lt;/tr&gt; 设置没有边框的表格 默认是没有边框的，或者&lt;table border=&#39;0&#39;&gt; 带标题的表格 &lt;caption&gt; 合并行/和并列 colspan=&#39;2&#39; rowspan=&#39;2&#39; 1234567891011121314151617181920212223242526271.合并列 colspan="2" th占了2个列的位置，所以之后的tr中td 会多出来&lt;table border="1"&gt;&lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th colspan="2"&gt;Telephone&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt;Bill Gates&lt;/td&gt; &lt;td&gt;555 77 854&lt;/td&gt; &lt;td&gt;555 77 855&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;2.合并行 rowspan="2" 合并2列 相当于和 下一行的 第一列合并在一起，所以下一行的td少一个&lt;table border="1"&gt;&lt;tr&gt; &lt;th&gt;First Name:&lt;/th&gt; &lt;td&gt;Bill Gates&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;th rowspan="2"&gt;Telephone:&lt;/th&gt; &lt;td&gt;555 77 854&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt;555 77 855&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 表格内的标签 一个td中 可以有 p标签；可以ul/li；也可以嵌套一个table 1234567891011121314151617181920212223242526272829303132333435&lt;table border="1"&gt;&lt;tr&gt; &lt;td&gt; &lt;p&gt;这是一个段落&lt;/p&gt; &lt;p&gt;这是另一个段落&lt;/p&gt; &lt;/td&gt; &lt;td&gt; 这个单元格包含一个表格: &lt;table border="1"&gt; &lt;tr&gt; &lt;td&gt;A&lt;/td&gt; &lt;td&gt;B&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;C&lt;/td&gt; &lt;td&gt;D&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt;这个单元格包含一个列表 &lt;ul&gt; &lt;li&gt;apples&lt;/li&gt; &lt;li&gt;bananas&lt;/li&gt; &lt;li&gt;pineapples&lt;/li&gt; &lt;/ul&gt; &lt;/td&gt; &lt;td&gt;HELLO&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 单元格边距 cellpadding=&quot;10&quot; 1&lt;table border='1' cellpadding='10'&gt; 单元格间距 cellspacing=&#39;10&#39; 12345678910111213141516171819202122232425262728293031323334353637381. border 设置table 和td 的border 都是12. 默认cellspacing是1，就是td之间 和table 之间 间距离 是13. 设置 cellspacing 为0 之后，border 会重叠显示&lt;h4&gt;没有单元格间距:&lt;/h4&gt;&lt;table border="1"&gt; &lt;tr&gt; &lt;td&gt;First&lt;/td&gt; &lt;td&gt;Row&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Second&lt;/td&gt; &lt;td&gt;Row&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;h4&gt;单元格间距="0":&lt;/h4&gt;&lt;table border="1" cellspacing="0"&gt; &lt;tr&gt; &lt;td&gt;First&lt;/td&gt; &lt;td&gt;Row&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Second&lt;/td&gt; &lt;td&gt;Row&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;h4&gt;单元格间距="10":&lt;/h4&gt;&lt;table border="1" cellspacing="10"&gt; &lt;tr&gt; &lt;td&gt;First&lt;/td&gt; &lt;td&gt;Row&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Second&lt;/td&gt; &lt;td&gt;Row&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; html列表 ul/ol (无序列表/有序列表)12345678910111213141516171.无序列表 `ul/li` 无序索引样式 默认是disc / circle / square / none style='list-style-type:disc' style='list-style-type:circle' style='list-style-type:square'2.有序列表 `ol/li` `start="50"` 有序的索引默认 是number 可设置大些字母/小写字母/大写阿拉伯数字/小写阿拉伯数字 type='A' type='a' type='I' type='i'3.自定义列表 dl dt dd 4.总结列表标签ol 定义有序列表ul 定义无序列表li 定义列表项dl 自定义列表dt 自定义列表项目dd 定义自定义列表的描述 自定义列表一二级 123456789101.dt一级 dd二级2.&lt;dt&gt; 与 &lt;dd&gt; 在其中数量不限、对应关系不限&lt;dl&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt;&lt;/dl&gt; 嵌套列表 123456789101112131415161718191最外层 默认是disc 2层样式是circle3层样式是square&lt;ul&gt; &lt;li&gt;咖啡&lt;/li&gt; &lt;li&gt;茶 &lt;ul&gt; &lt;li&gt;红茶&lt;/li&gt; &lt;li&gt;绿茶 &lt;ul&gt; &lt;li&gt;中国&lt;/li&gt; &lt;li&gt;欧洲&lt;/li&gt; &lt;ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;牛奶&lt;/li&gt;&lt;/ul&gt; html表单 form from 属性 action 1234567891011121314151617181.表单本身看不见，文本框默认是20字节宽度2.表单是包含表单元素的区域，允许再表单中输入内容，文本域 下拉列表，单选框，复选框3.input 输入标签输入类型 有 type='text' / type='password' / type='radio' / type='checkbox' / type='submit' 4.总结标签form 定义一个用户输入的表单input 定义输入域textarea 定义文本域lable 定义input元素的标签，一般为输入的标题filedset 定义一组相关的表单元素，用外框包含起来legend 定义了fieldset元素的标题select 定义下拉选项列表optgroup 定义选项组option 定义下拉列表的选项button 定义点击按钮datalist 执行预先定义的输入空间选项列表keygen 定义表单的密钥生成器output 定义一个计算结果 输入框表单 内容输入 123456789101112131415&lt;form action=''&gt;Name:&lt;input type='text' name='name'&gt; &lt;br&gt;Age:&lt;input type='text' name='age'&gt; &lt;br&gt;Username:&lt;input type='text' name='user'&gt; &lt;br&gt;Password:&lt;input type='password' name='passw'&gt; &lt;br&gt;&lt;input type='radio' name='sex' value='male'&gt;&lt;input type='radio' name='sex' value='female'&gt;&lt;input type='checkbox' name='vehicle' value='Bike'&gt; I have a bike &lt;br&gt;&lt;input type='checkbox' name='vehicle' value='car'&gt; i have a car&lt;/form&gt; 输入框表单 推荐按钮 点开submint 时 会讲user=’33232’ 通过get方式传入到php 文件中，action.php 通过get方法获取到传入值 123456&lt;form name='input' action='html_form_action.php' method='get'&gt;Username:&lt;input type='text' name='user'&gt;&lt;input type='submit' value='submit'&gt;&lt;/form&gt; 下拉列表 select/option 默认选择第一个，如果需要指定第三个，在第三个option中 写入属性selected 1234567&lt;form&gt; &lt;select name='cars'&gt; &lt;option value='volvo'&gt;Volvo&lt;/option&gt; &lt;option value='saab'&gt;Saab&lt;/option&gt; &lt;option value='fiat' selected&gt;Fiat&lt;/option&gt; &lt;/select&gt;&lt;/form&gt; 文本域 12345671.cols 列数 控制一行显示字数2.rows 行数，控制最多显示多少行。超出了之后scroll。&lt;form&gt; &lt;textarea rows='40' cols='80' &gt; 文本域很多内容ss..d，s.d.sdm.，f.f &lt;/textarea&gt;&lt;/form&gt; 带边框的表单 fieldset 12345678&lt;form action=''&gt; &lt;fieldset&gt; &lt;legend&gt;Personal Information:&lt;/legend&gt; Name:&lt;input type='text' size='30'&gt;&lt;br&gt; E-mail:&lt;input type='text' size='30'&gt;&lt;br&gt; Data of Birth:&lt;input type='text' size='10'&gt; &lt;/fieldset&gt;&lt;/form&gt; 用表单发送电子邮件 123456789101112131415161718192021&lt;form action='mallto:someine@example.com' method='post' enctype='text/plain'&gt; Name:&lt;br&gt; &lt;input type='text' name='name' value='your name'&gt;&lt;br&gt; E-mail:&lt;br&gt; &lt;input type='text' name='mail' value='your email'&gt;&lt;br&gt; Comment:&lt;br&gt; &lt;input type='text' name='comment' value='your comment' size['50'&gt;&lt;br&gt; send-time:&lt;br&gt; &lt;select name='time'&gt; &lt;option value='2016'&gt;2016&lt;/option&gt;&lt;/br&gt; &lt;option value='2017'&gt;2017&lt;/option&gt;&lt;/br&gt; &lt;option value='2018'&gt;2018&lt;/option&gt;&lt;/br&gt; &lt;select&gt; &lt;input type=''submit value='Send'&gt; &lt;input type='reset' value='Reset'&gt; &lt;/form&gt; html框架 iframe 内联框架 一个文档中镶嵌另一个文档，&lt;iframe src=&#39;url&#39;&gt;&lt;/iframe&gt; 语法：URL指向不同的网页 设置宽高 width / height 移除边框 frameborder=&#39;0&#39; 嵌套实例 a标签刷新 iframe 12345678910111.因为 a 标签的 target 属性是名为 iframe_a 的 iframe 框架，所以在点击链接时页面会显示在 iframe框架中2.标准属性 - class 元素的类名 - id 规定元素的唯一地址 - style 规定元素的行内样式 - title 规定元素的额外信息&lt;iframe src='/staic/demosource/demo.iframs.html' name='iframe_a'&gt;&lt;/iframe&gt;&lt;p&gt; &lt;a href='https://www.baidu.com' target='iframe_a'&gt;这是一个链接，taget指向上面的iframe&lt;a/&gt;&lt;/p&gt; html颜色 RGB1231.web 安全色216种 适应256色调色板2.颜色名 141 宗，（17标准颜色 加上124）3.17种标准色：黑色，蓝色，水，紫红色，灰色，绿色，石灰，栗色，海军，橄榄，橙，紫，红，白，银，蓝绿色，黄色， html 脚本 JavaScript JavaScript 是可以插入的HTML页面的编程代码JavaScript 使HTML页面具有更强的动态和交互性 script标签 121.script 既可以包含脚本语言，也可以用src属性指向外部脚本文件 - 如果使用src 属性，则script是必须是空的 noscript标签121.不支持 JavaScript 的浏览器会使用 noscript 元素中定义的内容（文本）来替代。&lt;noscript&gt;抱歉，你的浏览器不支持 JavaScript!&lt;/noscript&gt; html字符实体 某些字体是预留的 不能使用包含这些字符的文本 链接 比如 大于号，空格 结合音标符等 列出常用的字符实体 1234567891011121314151617显示结果 描述 实体名称 实体编号 空格 &amp;nbsp; &amp;#160;&lt; 小于号 &amp;lt; &amp;#60;&gt; 大于号 &amp;gt; &amp;#62;&amp; 和号 &amp;amp; &amp;#38;" 引号 &amp;quot; &amp;#34;' 撇号 &amp;apos; (IE不支持)&amp;#39;￠ 分 &amp;cent; &amp;#162;£ 镑 &amp;pound; &amp;#163;¥ 人民币/日元 &amp;yen; &amp;#165;€ 欧元 &amp;euro; &amp;#8364;§ 小节 &amp;sect; &amp;#167;© 版权 &amp;copy; &amp;#169;® 注册商标 &amp;reg; &amp;#174;™ 商标 &amp;trade; &amp;#8482;× 乘号 &amp;times; &amp;#215;÷ 除号 &amp;divide; &amp;#247; html URL url 是一个网址 IP地址，dns解析 url 统一资源定位符 1234567scheme + '://' + host + '.' + domain + :port + path + filename1.scheme 定义因特网服务的类型 http2.host 定义域主机 www3.domain 因特网域名 mayt.cn4.:port 端口:80805.path 定义服务器上的文件路径 如果省略 文档必须位于网站的根目录6.filename 定义文档/资源的名称 URL 字符编码 1231.URL 只能使用 ASCII字符集2.URL 编码 使用%其后跟随的16进制来替换非ASCII字符3.不能包含空格 html速查列表 上面知识总结速查 原文链接 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697981.基本文档&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;文档标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 可见文本... &lt;/body&gt;&lt;/html&gt;2.基本标签（Basic Tags）&lt;h1&gt;最大的标题&lt;/h1&gt;&lt;h2&gt; . . . &lt;/h2&gt;&lt;h3&gt; . . . &lt;/h3&gt;&lt;h4&gt; . . . &lt;/h4&gt;&lt;h5&gt; . . . &lt;/h5&gt;&lt;h6&gt;最小的标题&lt;/h6&gt; &lt;p&gt;这是一个段落。&lt;/p&gt;&lt;br&gt; （换行）&lt;hr&gt; （水平线）&lt;!-- 这是注释 --&gt;3.文本格式化（Formatting）&lt;b&gt;粗体文本&lt;/b&gt;&lt;code&gt;计算机代码&lt;/code&gt;&lt;em&gt;强调文本&lt;/em&gt;&lt;i&gt;斜体文本&lt;/i&gt;&lt;kbd&gt;键盘输入&lt;/kbd&gt; &lt;pre&gt;预格式化文本&lt;/pre&gt;&lt;small&gt;更小的文本&lt;/small&gt;&lt;strong&gt;重要的文本&lt;/strong&gt; &lt;abbr&gt; （缩写）&lt;address&gt; （联系信息）&lt;bdo&gt; （文字方向）&lt;blockquote&gt; （从另一个源引用的部分）&lt;cite&gt; （工作的名称）&lt;del&gt; （删除的文本）&lt;ins&gt; （插入的文本）&lt;sub&gt; （下标文本）&lt;sup&gt; （上标文本）4.链接（Links）普通的链接：&lt;a href="链接地址"&gt;链接文本&lt;/a&gt;图像链接： &lt;a href="http://www.example.com/"&gt;&lt;img src="URL" alt="替换文本"&gt;&lt;/a&gt; 邮件链接： &lt;a href="mailto:webmaster@example.com"&gt;发送e-mail&lt;/a&gt;书签： &lt;a id="tips"&gt;提示部分&lt;/a&gt; &lt;a href="#tips"&gt;跳到提示部分&lt;/a&gt;5.图片（Images）&lt;img src="URL" alt="替换文本" height="42" width="42"&gt;6.表格（Tables）&lt;table border="1"&gt; &lt;tr&gt; &lt;th&gt;表格标题&lt;/th&gt; &lt;th&gt;表格标题&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;表格数据&lt;/td&gt; &lt;td&gt;表格数据&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;7.表单（Forms）&lt;form action="demo_form.php" method="post/get"&gt; &lt;input type="text" name="email" size="40" maxlength="50"&gt; &lt;input type="password"&gt; &lt;input type="checkbox" checked="checked"&gt; &lt;input type="radio" checked="checked"&gt; &lt;input type="submit" value="Send"&gt; &lt;input type="reset"&gt; &lt;input type="hidden"&gt; &lt;select&gt; &lt;option&gt;苹果&lt;/option&gt; &lt;option selected="selected"&gt;香蕉&lt;/option&gt; &lt;option&gt;樱桃&lt;/option&gt; &lt;/select&gt; &lt;textarea name="comment" rows="60" cols="20"&gt; &lt;/textarea&gt; &lt;/form&gt;8.实体（Entities）&amp;lt; 等同于 &lt;&amp;gt; 等同于 &gt;&amp;copy; 等同于 © html媒体（Media） 音效 音乐 视频 动画 HTML插件object/embed object 元素 1234567891011121.定义了嵌入的对象2.具有局部属性 data type. height width usemap name form 3.用于插入（java小程序 PDF阅读器 Flash 播放器）// 嵌入动画&lt;object width='400' height='500' data='bookmark.swf'&gt;&lt;/object&gt;嵌入html&lt;object width="100%" height="100px" data="/statics/demosource/snippet.html"&gt;&lt;/object&gt;嵌入图片&lt;object data='apic.png'&gt;&lt;/object&gt; embed 元素 html中object和embed标签的区别 11.embed 和object标签一样 HMTL 音频（Audio）12345678多媒体标签 embed 定义内嵌对象 HTML4不支持 html5支持object 内嵌对象param 定义对象的参数 audio 定义声音video 定义视频source 定义media元素的多媒体元素track 规定media元素的字幕或其他包含文本的文件 歌词? 使用embed 12345671.embed在HTML4中无效2.不同的浏览器对音频格式的支持也不同。3.如果浏览器不支持该文件格式，没有插件的话就无法播放该音频。4.如果用户的计算机未安装插件，无法播放音频。5.如果把该文件转换为其他格式，仍然无法在所有浏览器中播放&lt;embed height='50' width='300' src='horse.mp3'&gt; 使用object 123451.不同的浏览器对音频格式的支持也不同。2.如果浏览器不支持该文件格式，没有插件的话就无法播放该音频。3.如果用户的计算机未安装插件，无法播放音频。4.如果把该文件转换为其他格式，仍然无法在所有浏览器中播放&lt;object height='50' width='300' data='horse.mp3'&gt;&lt;/object&gt; 使用Audio 123456781. &lt;audio&gt; 标签来描述 MP3 文件(Internet Explorer、Chrome 以及 Safari 中是有效的), 2. 同样添加了一个 OGG 类型文件(Firefox 和 Opera浏览器中有效).如果失败，它会显示一个错误文本信息:&lt;audio controls&gt; &lt;source src='horse.mp3' type='audio/mp3'&gt; &lt;source src='horse.ogg' type='audio/ogg'&gt; Your browser does not support this audio format&lt;/audio&gt; 兼容性解决办法 1234561.html5 audio 会先尝试以mp3 ogg 来播放音乐，如果失败，将使用&lt;embed&gt;&lt;audio controls width='100' height='100'&gt; &lt;source src='horse.mp3' type='audio/mpeg'&gt; &lt;source src='horse.mp3 type=''audio/ogg'&gt; &lt;embed height='50' width='100' src='horse.mp3'&gt;&lt;/audio&gt; 使用超链接121.如果网页只指向媒体文件，大多数浏览器会使用辅助应用程序来播放文件&lt;a href='horse.mp3'&gt; click play the sound&lt;a&gt; HMTL 视频（videos）1234567891011121314151.可以使用 embed object video 标签&lt;video controls width='320' height='240'&gt; &lt;source src='movie.mp4' type='video/mp4'&gt; &lt;source src='movie.ogg' type='video/ogg'&gt; &lt;source src='movie.webm' type='video/webm'&gt; &lt;object data='movie.mp4' width='320' height='240'&gt; &lt;object src='movie.swf' width='320' height='240'&gt; &lt;/video&gt;2.ogg：带有 Theora 视频编码和 Vorbis 音频编码的 Ogg 文件3.mp4：带有 H.264 视频编码和 AAC 音频编码的 mp4 文件 4.webm：带有 VP8 视频编码和 Vorbis 音频编码的 webm 文件 html 扩展阅读]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数式编程-链式编程]]></title>
    <url>%2F2017%2F06%2F13%2F2017b%2F%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-%E9%93%BE%E5%BC%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1 函数式编程，链式编程定义 准备工作：自定义一个基类重写description 打印model 的时候能打印所有的属性 OC 中应用函数式编程，方法后面拼接()要能继续执行下去，所有要有返回值，使用block，返回值式自己。 方法的实现： 直接返回return，简写如下： 2 Swift是适合函数式编程 ，方法后面带有(),如果需要执行下去，加上返回值是自己的就可以链式编程下去。 形式 实现 3 响应式编程RAC - 集成注意点 选择框架 纯 swift 项目，继续使用 ReactiveCocoa 。但是 RAC 依赖于 ReactiveSwift ，等于你引入了两个库。 纯 OC 项目，需要使用 ReactiveObjC 。这个库里面包含原来 RAC 2的全部代码。 项目是 swift 和 OC 混编，需要同时引用 ReactiveCocoa 和 ReactiveObjCBridge 。但是 ReactiveObjCBridge 依赖于 ReactiveObjC ，所以你就等于引入了 4 个库。 集成环境配置 如果项目不是纯OC项目，那么编辑Podfile文件添加了pod ‘ReactiveCocoa’, ‘~&gt; 5.0.3’以后一定别忘了添加一行use_frameworks!用于生成动态链接库。 Xcode8导入时因为Swift2.3与Swift3.0的关系，导入后，无法成功编译程序，工程会弹出一个选择框，最好选第一个later，跳过swift编译。之后修改pod项目的Bulid Settings里搜swift_version之后把Swift Language Version变成3.0在使用command+shift+k进行clear下项目就OK了。 4 RAC应用 iOS中的事件 目标（方法），代理，通知，KVO，时钟，网络 rac_signalForControlEvents target rac_signalForSelector 代理 rac_addObserverForName 通知 rac_valuesAndChangesForKeyPath KVO 创建信号RACSignal createSignal 信号， RACSignal 状态： 热信号：有订阅者，一旦订阅信息，就会执行 冷信号 只是定义，没有订阅，只是信号对象，不会工作 5 订阅者： 视图控制器需要知道加载数据的情况 订阅三种类型，next ID类型，error：出错处理，completion表示信号完成 加载过后订阅 6 RAC系统学习 ReactiveCocoa常见类有哪些？ RACSignal:表示有数据传递的时候 RACDisposable:取消订阅信号 RACSubscriber:订阅者,发送数据]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>runloop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[runTime]]></title>
    <url>%2F2017%2F02%2F13%2F2017b%2FrunTime%2F</url>
    <content type="text"><![CDATA[1. runTime 方法 class_copyPropertyList 获取类属性列表使用class_copyPropertyList()方法 C语言函数，copy之后需要free() 使用字典转模型 获得self的属性列表，遍历字典，如果key 值在数组中，进行KVC赋值， cz_objectProperties方法会调用很多变，需要进行关联缓存处理 从关联对象中获取对象属性，如果有，直接返回 获取之后的数组，objc_setAssociatedObject 添加关联对象 2.方法交换 load 方法中交换， 在类被加载到运行时的时候，就会被执行 method_exchangeImplementations() 执行之后，交换2个方法 调用setImage：相当于调用cz_setImage： 调用cz_setImage：相当于调用setImage：]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>runTime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[runloop解决Cell上主线程卡顿]]></title>
    <url>%2F2017%2F02%2F12%2F2017b%2Frunloop%E8%A7%A3%E5%86%B3Cell%E4%B8%8A%E4%B8%BB%E7%BA%BF%E7%A8%8B%E5%8D%A1%E9%A1%BF%2F</url>
    <content type="text"><![CDATA[1解决cell上的主线程加载卡顿问题 通过添加runloop 观察者，卡顿等待的时候进行处理 视频地址 http://v.youku.com/v_show/id_XODgxODkzODI0.html RunLoopMode 5 种mode 使用 C 创建观察者 获取当前的runloop: CFRunLoopRef runloop = CFRunLoopGetCurrent(); 创建观察者 参数1：分配者，NUll 或者Defaul ,参数2:活动标志，等待前处理，参数3:重复，参数4:从0开始，参数5：监听到的回调函数地址，参数6:观察者上下文，结构体指针 上面参数callout,需要传入函数的地址，观察者，活动状态，本文背景是等待的情况下，传入的info 添加观察者 在回调中回去self，获取不到，需要用上下文中的info参数传递， 在上面回调中处理cell中添加的任务 cell中的任务加载block中，将代码块添加到数组中,延迟执行 将任务加入到任务数组中 callback 方法中，执行任务，执行之后删除任务]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>runloop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片打码(系统自带 VS openCV)]]></title>
    <url>%2F2017%2F02%2F10%2F2017b%2F%E5%9B%BE%E7%89%87%E6%89%93%E7%A0%81(%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%B8%A6%20VS%20openVC)%2F</url>
    <content type="text"><![CDATA[1.实用系统自带的API进行图片打码 原图片进行打码，没有头像检测，全部打码 获取图像上下文， 获取宽高 获取颜色空间 创建图像内容上下文 根据上下文绘制图片 获取上下文绘制的图片空间，内存地址 根据内存中地址，运用C函数，自己定义算法进行打码处理，（可以局部打码） 根据像素点处理好的图片内存，获取图片数据集合， 输出图片 释放内存]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>openVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片转化为视频]]></title>
    <url>%2F2017%2F02%2F03%2F2017b%2F%E5%9B%BE%E7%89%87%E8%BD%AC%E5%8C%96%E4%B8%BA%E8%A7%86%E9%A2%91%2F</url>
    <content type="text"><![CDATA[图片转为视频流 使用 AVAssetWriter. AVAssetWriterInputPixelBufferAdaptor 处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// 图片转为视频频- (void) testchangeImageToVideo&#123; NSArray *imageArr = [NSArray arrayWithObjects:[[UIImage imageNamed:@"114.png"] CGImage],[[UIImage imageNamed:@"114.png"] CGImage],[[UIImage imageNamed:@"placeholderImage.png"] CGImage],[[UIImage imageNamed:@"dfd.png"] CGImage],[[UIImage imageNamed:@"viewbg.png"] CGImage], nil]; CGSize size = CGSizeMake(480, 320); NSString *betaCompressionDirectory = [NSHomeDirectory() stringByAppendingPathComponent:@"Documents/Movie.m4v"]; NSError *error = nil; unlink([betaCompressionDirectory UTF8String]); AVAssetWriter *videoWriter = [[AVAssetWriter alloc] initWithURL:[NSURL fileURLWithPath:betaCompressionDirectory] fileType:AVFileTypeQuickTimeMovie error:&amp;error]; NSParameterAssert(videoWriter); if(error) NSLog(@"error = %@", [error localizedDescription]); NSDictionary *videoSettings = [NSDictionary dictionaryWithObjectsAndKeys:AVVideoCodecH264, AVVideoCodecKey, [NSNumber numberWithInt:size.width], AVVideoWidthKey, [NSNumber numberWithInt:size.height], AVVideoHeightKey, nil]; AVAssetWriterInput *writerInput = [AVAssetWriterInput assetWriterInputWithMediaType:AVMediaTypeVideo outputSettings:videoSettings]; NSDictionary *sourcePixelBufferAttributesDictionary = [NSDictionary dictionaryWithObjectsAndKeys: [NSNumber numberWithInt:kCVPixelFormatType_32ARGB], kCVPixelBufferPixelFormatTypeKey, nil]; AVAssetWriterInputPixelBufferAdaptor *adaptor = [AVAssetWriterInputPixelBufferAdaptor assetWriterInputPixelBufferAdaptorWithAssetWriterInput:writerInput sourcePixelBufferAttributes:sourcePixelBufferAttributesDictionary]; NSParameterAssert(writerInput); NSParameterAssert([videoWriter canAddInput:writerInput]); if ([videoWriter canAddInput:writerInput]) NSLog(@"I can add this input"); else NSLog(@"i can't add this input"); [videoWriter addInput:writerInput]; [videoWriter startWriting]; [videoWriter startSessionAtSourceTime:kCMTimeZero]; // insert demo debugging code to write the same image repeated as a movie CGImageRef theImage = [[UIImage imageNamed:@"114.png"] CGImage]; dispatch_queue_t dispatchQueue = dispatch_queue_create("mediaInputQueue", NULL); int __block frame = 0; [writerInput requestMediaDataWhenReadyOnQueue:dispatchQueue usingBlock:^&#123; while ([writerInput isReadyForMoreMediaData])&#123; if(++frame &gt;= imageArr.count * 40)&#123; [writerInput markAsFinished]; [videoWriter finishWriting]; break; &#125; int idx = frame/40; CVPixelBufferRef buffer = (CVPixelBufferRef)[self pixelBufferFromCGImage:(__bridge CGImageRef)([imageArr objectAtIndex:idx]) size:size]; if (buffer)&#123; if(![adaptor appendPixelBuffer:buffer withPresentationTime:CMTimeMake(frame, 20)]) NSLog(@"FAIL"); else NSLog(@"Success:%d", frame); CFRelease(buffer); &#125; &#125; &#125;];NSLog(@"outside for loop");&#125;- (CVPixelBufferRef )pixelBufferFromCGImage:(CGImageRef)image size:(CGSize)size&#123; NSDictionary *options = [NSDictionary dictionaryWithObjectsAndKeys: [NSNumber numberWithBool:YES], kCVPixelBufferCGImageCompatibilityKey, [NSNumber numberWithBool:YES], kCVPixelBufferCGBitmapContextCompatibilityKey, nil]; CVPixelBufferRef pxbuffer = NULL;CVReturn status = CVPixelBufferCreate(kCFAllocatorDefault, size.width, size.height, kCVPixelFormatType_32ARGB, (__bridge CFDictionaryRef) options, &amp;pxbuffer); // CVReturn status = CVPixelBufferPoolCreatePixelBuffer(NULL, adaptor.pixelBufferPool, &amp;pxbuffer); NSParameterAssert(status == kCVReturnSuccess &amp;&amp; pxbuffer != NULL); CVPixelBufferLockBaseAddress(pxbuffer, 0); void *pxdata = CVPixelBufferGetBaseAddress(pxbuffer); NSParameterAssert(pxdata != NULL); CGColorSpaceRef rgbColorSpace = CGColorSpaceCreateDeviceRGB(); CGContextRef context = CGBitmapContextCreate(pxdata, size.width, size.height, 8, 4*size.width, rgbColorSpace, kCGImageAlphaPremultipliedFirst); NSParameterAssert(context); CGContextDrawImage(context, CGRectMake(0, 0, CGImageGetWidth(image), CGImageGetHeight(image)), image); CGColorSpaceRelease(rgbColorSpace); CGContextRelease(context); CVPixelBufferUnlockBaseAddress(pxbuffer, 0); return pxbuffer; &#125;]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>实用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swiftSQLite]]></title>
    <url>%2F2016%2F09%2F28%2F2016b%2FswiftSQLite%2F</url>
    <content type="text"><![CDATA[使用FMDB 存储本地数据，增删改查 创建管理类 使用当前用户的ID， 返回需要的字典数组 回滚的处理 从本地加载数据，和网络请求数据的参数一样，方便处理，在viewModel中，内部处理VC不关心是从本地还是从网络数据 ViewModel 中，不改变控制器代码，增加本地数据读取 加载完成网络数据时，把数据存入本地数据库中， 仿SDWebImage 固定时间清楚缓存 SDWebImage 的监听系统时间， 在程序中，没有通过sql 指定字段的值，就使用default 的值替代 清楚缓存 如果超过了7天之后，把日期小于7天前的日期数据删除]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Swift学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>SQLite</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift泛型]]></title>
    <url>%2F2016%2F09%2F27%2F2016b%2Fswift%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[1.类型约束 你可以在一个类型参数名后面放置一个类名或者协议名，并用冒号进行分隔，来定义类型约束，它们将成为类型参数列表的一部分。对泛型函数添加类型约束的基本语法如下所示（作用于泛型类型时的语法与之相同）： 下面展示了 findIndex(ofString:in:) 函数的泛型版本 findIndex(ofString:in:)。请注意这个函数返回值的类型仍然是 Int?，这是因为函数返回的是一个可选的索引数，而不是从数组中得到的一个可选值。需要提醒的是，这个函数无法通过编译，原因会在例子后面说明： 上面所写的函数无法通过编译。问题出在相等性检查上，即 if value == valueToFind。不是所有的 Swift 类型都可以用等式符（==）进行比较。比如说，如果你创建一个自定义的类或结构体来表示一个复杂的数据模型，那么 Swift 无法猜到对于这个类或结构体而言“相等”意味着什么。 Swift 标准库中定义了一个 Equatable 协议，该协议要求任何遵循该协议的类型必须实现等式符（==）及不等符(!=) ,所有的 Swift 标准类型自动支持 Equatable 协议 findIndex(of:in:) 唯一的类型参数写做 T: Equatable，也就意味着“任何符合 Equatable 协议的类型 T 2.关联类型 定义一个协议时，有的时候声明一个或多个关联类型作为协议定义的一部分将会非常有用。关联类型为协议中的某个类型提供了一个占位名（或者说别名），其代表的实际类型在协议被采纳时才会被指定。你可以通过 associatedtype 关键字来指定关联类型。 协议没有指定容器中元素的类型，只指定了遵守协议，必须实现的方法，同时声明了associatedtype 的ItemType 关联类型。这个协议无法定义 ItemType 是什么类型的别名，这个信息将留给遵从协议的类型来提供 intStack 遵守Container 协议，需要实现协议的方法，指定关联类型的真是类型。 由于swift中的类型推导，不用写typealias ItemType = Int ,省略这一句，会推导append(item:) 方法，传的是什么类型， Stack 遵守Container协议，stack 是范型，具体的类型，有外部就决定 append(item:) 传入的是范型的类型：代码如下 3.范型where 语句 为关联类型定义约束也是非常有用的，可以在参数列表中通过where语句，为关联类型定义约束。 where 使用场景 可以通过where 语句，要求关联类型遵守特定的协议，以及某个参数的类型必须和关联类型的类型相同， 可以通过where语句，紧跟参数列表后面来定义where语句，where子句后面跟一个或者多个针对关联类型的约束，以及一个或者多个参数类型和关联类型的相等关系。 可以在函数体或类型大括号之前添加where语句 例子检验2个容器是不是相同，其中元素个数，顺序，顺序上的值是否都相同？ 这个函数接受 someContainer 和 anotherContainer 两个参数。参数 someContainer 的类型为 C1，参数 anotherContainer 的类型为 C2。C1 和 C2 是容器的两个占位类型参数，函数被调用时才能确定它们的具体类型 C1 必须符合 Container 协议（写作 C1: Container）。 C2 必须符合 Container 协议（写作 C2: Container）。 C1 的 ItemType 必须和 C2 的 ItemType类型相同 ，C1 的 ItemType 必须符合 Equatable 协议，第三个和第四个要求被定义为一个 where 子句，写在关键字 where 后面，它们也是泛型函数类型参数列表的一部分 someContainer和 anotherContainer可以通过!= 操作其中的元素]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Swift学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>swift泛型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift协议]]></title>
    <url>%2F2016%2F09%2F26%2F2016b%2Fswift%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[1.协议 协议的语法： 定义协议 遵守协议：在类型名称后面，加上协议名称，用: 隔开，协议之间用,隔开 继承父类的子类的时候，应该把父类写在协议前面， 12protocol SomeProtocol &#123;&#125;class SomeClass: SomeSuperClass, FirstProtocol, AnotherProtocol &#123;&#125; 属性要求 协议中定义了属性，遵守该协议的实例或类型，必须有这个属性 协议的中定义属性，只指定属性的名称和类型，还指定属性的可读性，可写性， 方法要求 和普通方法一样，但不需要{} 和方法体，方法的参数列表也不支持默认值 Mutating 方法要求 如果你在协议中定义了一个实例方法，该方法会改变遵循该协议的类型的实例，那么在定义协议时需要在方法前加 mutating 关键字。这使得结构体和枚举能够遵循此协议并满足此方法要求。 构造器要求 协议可以要求遵循协议的类型实现指定的构造器。你可以像编写普通构造器那样，在协议的定义里写下构造器的声明，但不需要写花括号和构造器的实体 实现的时候，遵守代理的构造器方法需要加上关键字required 如果一个类是定义了final,不需要在写required，因为不会有子类，final是为了防止重写 如果子类重写了父类的指定构造器，并且指定构造器遵循了某个协议，该方法同时需要写关键字required和overri 协议作为类型 1234567891011class Dice &#123; let sides: Int let generator: RandomNumberGenerator init(sides: Int, generator: RandomNumberGenerator) &#123; self.sides = sides self.generator = generator &#125; func roll() -&gt; Int &#123; return Int(generator.random() * Double(sides)) + 1 &#125;&#125; Dice 类提供了一个名为 roll 的实例方法，用来模拟骰子的面值。它先调用 generator 的 random() 方法来生成一个 [0.0,1.0) 区间内的随机数，然后使用这个随机数生成正确的骰子面值。因为 generator 遵循了 RandomNumberGenerator 协议，可以确保它有个 random() 方法可供调用 2.委托（代理）模式 protocol - delegate 3.通过扩展添加协议一致性，通过扩展遵循协议 当一个类型已经符合了某个协议中的所有要求，却还没有声明遵循该协议时，可以通过空扩展体的扩展来遵循该协议： 4.协议类型的集合，协议的继承 协议能够继承一个或多个其他协议，可以在继承的协议的基础上增加新的要求 例子中定义了一个新的协议 PrettyTextRepresentable，它继承自 TextRepresentable 协议。任何遵循 PrettyTextRepresentable 协议的类型在满足该协议的要求时，也必须满足 TextRepresentable 协议的要求 5.类类型专属协议 只适用一某种类型 6.协议合成 有时候需要同时遵循多个协议，你可以将多个协议采用 SomeProtocol &amp; AnotherProtocol 这样的格式进行组合，称为 协议合成（protocol composition）。你可以罗列任意多个你想要遵循的协议，以与符号(&amp;)分隔。 7.检查协议一致性 Circle，Country，遵守了HasArea协议，协议中有只读的area属性 Animal 没有遵守HasArea协议 上面三个各自实例，判断是不是符合某个协议的，使用as?, 返回可选值，进行可选值绑定 8.可选的协议要求 可选的时候使用optional 关键字 可选要求用在你需要和 Objective-C 打交道的代码中。协议和可选要求都必须带上@objc属性 1234@objc protocol CounterDataSource &#123; optional func incrementForCount(count: Int) -&gt; Int optional var fixedIncrement: Int &#123; get &#125;&#125; 8.协议扩展 协议可以通过扩展来为遵循协议的类型提供属性、方法以及下标的实现。通过这种方式，你可以基于协议本身来实现这些功能，而无需在每个遵循协议的类型中都重复同样的实现，也无需使用全局函数 扩展RandomNumberGenerator协议,增加randomBool() 方法 12345extension RandomNumberGenerator &#123; func randomBool() -&gt; Bool &#123; return random() &gt; 0.5 &#125;&#125; 提供默认实现 为协议扩展添加限制条件 在扩展协议的时候，可以指定一些限制条件，只有遵循协议的类型满足这些限制条件时，才能获得协议扩展提供的默认实现。这些限制条件写在协议名之后，使用 where 子句来描述 textualDescription返回整个集合的文本描述，讲文本描述用，拼接起来，包括在【】中 Hamster 结构体符合TextRepresentable协议，放在一个数组中，array 符合CollectionType协议， 可以进行textualDescription方法， 如果多个协议扩展都为同一个协议要求提供了默认实现，而遵循协议的类型又同时满足这些协议扩展的限制条件，那么将会使用限制条件最多的那个协议扩展提供的默认实现]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Swift学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>protocol</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift扩展Extensions]]></title>
    <url>%2F2016%2F09%2F25%2F2016b%2Fswift%E6%89%A9%E5%B1%95Extensions%2F</url>
    <content type="text"><![CDATA[1.Extension 扩展 就是为一个已有的类、结构体、枚举类型或者协议类型添加新功能 语法：extension SomeType { } 可以使用的功能： 添加计算行属性，计算类型属性 定义实例方法和类型方法 提供新的构造器 定义下标 定义和使用新的嵌套类型 使用已有类型符合某个协议。 计算型属性 为一个类增加计算属性 构造器 扩展能为类添加新的便利构造器，但是它们不能为类添加新的指定构造器或析构器。指定构造器和析构器必须总是由原始的类实现来提供 方法 扩展可以为已有类型添加新的实例方法和类型方法 使用: 3.repetitions({ print(“Hello!”)}) 可变实例方法： 结构体和枚举中，修改self或其属性方法，必须加上mutating 下标 扩展可以为已有类型添加新下标。这个例子为 Swift 内建类型 Int 添加了一个整型下标。该下标 [n] 返回十进制数字从右向左数的第 n 个数字 嵌套类型 为Int添加了嵌套枚举，用来表示是正数，负数，0]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Swift学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>extension</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift错误处理]]></title>
    <url>%2F2016%2F09%2F24%2F2016b%2Fswift%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[1.表示并抛出错误 在 Swift 中，错误用符合Error协议的类型的值来表示 12345enum VendingMachineError: Error &#123; case invalidSelection //选择无效 case insufficientFunds(coinsNeeded: Int) //金额不足 case outOfStock //缺货&#125; swift 枚举，创建一组错误状态，枚举关联值，可以提供错误状态额外信息，遇见错误的时候，可以抛出异常，使用throw throw VendingMachineError. insufficientFunds(coinsNeeded: 5) 2.处理错误 swift 中有4中错误处理方法： 可以讲函数抛出的异常，传递给调用函数的代码 使用do-cantch 语句处理错误 讲错误当作可选项处理 断言此处不会出现错误 3.用 throwing 函数传递错误 在函数声明参数列表之后加上throw，在箭头（-&gt;） 前面 func canThrowErrors() throws -&gt; String 因为vend(itemNamed:)方法能抛出错误，所以在调用的它时候在它前面加了try关键字。 4.用 Do-Catch 处理错误 如果在do子句中的代码抛出了一个错误，这个错误会与catch子句做匹配，从而决定哪条子句能处理它。 5.将错误转换成可选值 try? 如果someThrowingFunction()抛出一个错误，x和y的值是nil。否则x和y的值就是该函数的返回值 6.禁用错误传递 有时你知道某个throwing函数实际上在运行时是不会抛出错误的，在这种情况下，你可以在表达式前面写try! 7.指定清理操作 可以使用defer语句在即将离开当前代码块时执行一系列语句。该语句让你能执行一些必要的清理工作，不管是以何种方式离开当前代码块的——无论是由于抛出错误而离开，还是由于诸如return或者break的语句 上面的代码使用一条defer语句来确保open(:)函数有一个相应的对close(:)函数的调用。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Swift学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图文混排]]></title>
    <url>%2F2016%2F09%2F24%2F2016b%2F%E5%9B%BE%E6%96%87%E6%B7%B7%E6%8E%92%2F</url>
    <content type="text"><![CDATA[1.NSTextAttachment 实现图文混排 图片附件 lineHeight 大致和字体的大小相等 bounds ,x,y 决定内部子控件相对远点的位置 图片属性文本 12345678910111213141516func textTextKit()&#123; let attchment = NSTextAttachment() // 图片附件 attchment.image = UIImage(named: "hehheheh"); // lineHeight 大致和字体的大小相等 let height = lable.font.lineHeight // frame x,y 决定当前控件，相对父控件的位置 // bounds ,x,y 决定内部子控件相对远点的位置 attchment.bounds = CGRect(x: 0, y: -4, width: height, height: height) //图片属性文本 let attst1 = NSAttributedString(attachment: attchment) let attrStrM = NSMutableAttributedString(string: "我") attrStrM.append(attst1) attrStrM.append(NSAttributedString(string: "99999")) lable.attributedText = attrStrM &#125; {% asset_img 图文混排1.png 400 %} 2.TextKit 重绘实现图文混排 NSTextStorage 管理NSLayoutManager 对象，字符或者属性变化的时候，通知LayoutManager重新布局并显示文本 NSLayoutManager 负责协调布局，显示NSTextStorage对象中保存的字符，将字形设置为一系列NSTextContainer 对象，然后以系列文本视图对象显示 NStextContainer 也可以定义一个排除路径，定义一下矩形区域，在layoutSubviews中更新调用 12345678// 属性文本存储 是 NSMutableAttributedString子类private lazy var textStore = NSTextStorage()// 负责文本“字形”布局private lazy var layoutManager = NSLayoutManager()// 设定文本绘制的的范围private lazy var textContainer = NSTextContainer () 代码实现 在init方法中设置prepareTextSystem 1.准备文本 2.设置对象关系 3.在layoutSubviews指定区域 4.重写drawText 方法，重新绘制 绘制类似油画，后绘制的内容，会把之前绘制的内容覆盖 定义只读属性urlRanges:[NSRange]? 字符串中的网址range 在touchesBegan 中判断点击的index 在不在urlRanges 中，如果在，显示点击变色 获取点击的索引 判断点击的字符 indx 是不是再urlRanges范围内，如果在就高亮 需要重绘，调用setNeedsDisplay函数，但是不是drawrect 3.UITextView 的XIB处理 进制滚动 拖拽回收键盘 4.切换键盘 自定义view 点击切换，如果是nil显示，如果不是nil,隐藏 刷新键盘 reloadInputViews 5. UITextView 的常用的三个方法 是否为空 hasText() -&gt; Bool 插入字符串 insertText(_ text: String ) 向前删除 deleteBackward() 插入字符串 textVIew.replace(&lt;#T##range: UITextRange##UITextRange#&gt;, withText: &lt;#T##String#&gt;) 6.监听键盘的方法 监听键盘通知， 获取键盘高度和键盘动画 设置底部约束高度 更新约束 执行动画 12// 监听键盘通知，NotificationCenter.default.addObserver(self, selector: #selector(keybordChanged), name: NSNotification.Name.UIKeyboardWillChangeFrame, object: nil); 123deinit &#123; NotificationCenter.default.removeObserver(self)&#125; 12345678910111213guard let rect = (noti.userInfo?[UIKeyboardFrameEndUserInfoKey] as? NSValue)?.cgRectValue, let duration = (noti.userInfo?[UIKeyboardAnimationDurationUserInfoKey] as? NSNumber)?.doubleValue else&#123; return &#125;// 设置底部约束高度let offsite = view.bounds.height - rect.origin.y// 更新约束viewToButtonH.constant = offsite// 执行动画UIView.animate(withDuration: duration) &#123; self.view.layoutIfNeeded()&#125; 7.图文混排，图片插入文字中 获取表情中的图像属性文本 使用attemnet 设置当前的textview的属性文本，可变的 将图像的属性文本插入到当前的光标位置 记录光标位置 重新设置文本 回复光标位置 1234567891011121314151617181920// 获取表情中的图像属性文本 使用attemnetlet imageText = NSAttributedString(string: "ceshi", attributes: [NSFontAttributeName:UIFont.systemFont(ofSize: 12)])// 设置当前的textview的属性文本，可变的let attrStrM = NSMutableAttributedString(attributedString: textVIew.attributedText)// 将图像的属性文本插入到当前的光标位置attrStrM.replaceCharacters(in: textVIew.selectedRange, with: imageText)// 记录光标位置let range = textVIew.selectedRange// 重新设置文本textVIew.attributedText = attrStrM// 回复光标位置textVIew.selectedRange = NSRange(location: range.location + 1, length: 0) 8. 变量可变字符串寻找图片附件 字典中包含 NSAttachment key 说明是图片，否则是文本 12345678let aAttr = NSAttributedString(string: "ceshi", attributes: [NSFontAttributeName:UIFont.systemFont(ofSize: 12)])aAttr.enumerateAttributes(in: NSRange(location: 0, length: aAttr.length), options: []) &#123; (dic, range, _) in // 字典中包含 NSAttachment key 说明是图片，否则是文本 let arrrment = dic["NSAttachment"] &#125; 9.UIcode编码 uiicode 的编码，展现是啊用UTF8 1-4个字节表示一个字符 实例化字符扫描 从code中 扫描出16进制的数值 使用uint32的数值，生成UTF8 的字符 1234567let code = "0x1f633"let scanner = Scanner(string: code)var result :uint = 0scanner.scanHexInt32(&amp;result)let c = Character(UnicodeScalar(result)!)let emojy = String(c)print("\(emojy)") uibutton 的设置nil 设置图像，如果图像为nil,会清空图像，避免复用 设置标题 10.图片拉伸处理]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Swift学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义刷新控件]]></title>
    <url>%2F2016%2F09%2F24%2F2016b%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%B7%E6%96%B0%E6%8E%A7%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[1.自定义刷新控件 -控制逻辑 创建JYRefreshControl 基于UIControl 控制逻辑判断 2.自定义刷新控件视图 -控制界面显示或者动画 创建XIB实现UI view布局，通过control 得到父视图高度控制view的变化 3. JYRefreshControl 初始化init方法，创建UI，此时没有设置高度，没有frame 创建scrollview 记录父视图 创建refreshView负责视图展示 12345678init()&#123; super.init(frame: CGRect()) setupUI()&#125;required init?(coder aDecoder: NSCoder) &#123; super.init(coder: aDecoder); setupUI()&#125; 设置刷新状态的枚举 重写父类的方法willMove toSuperView 上记录父视图，添加观察者 重写父类的移除视图的时候移除观察者 实现KVO 方法，根据监听到的父视图的滑动，设置view的frame，把高度传到refreshView中 根据滑动的高度，设置frame 在拖拽的时候进行状态判断 不在拖拽的时候，状态是拖拽了，松手刷新，状态设置为刷新，执行beginRefreshing beginRefreshing() 方法 endRefreshing() 方法 4.JYNomalRefreshView init 方法 加载loadnib 方法 nibName 可以是子类，通过nibName 的改变切换不同的显示内容，在View 的拖出来的视图，是可选的，子类不一定有 在state的didset方法中设置UI ios 中旋转动画默认是 1.顺时针的旋转， 2.就近原则 实现同方向旋转，减少一个极小的值 如果旋转360，使用CABaseAnimation动画 5.刷新动画 awakeFromNib() 进行动画的执行 通过2张图片合成，实现1张GIF效果 使用CABasicAnimation 动画实现无限旋转 实现CGAffineTransform缩放动画，设置layer的锚点，先设置center，或者frame，再设置锚点，]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Swift学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GCD调度组]]></title>
    <url>%2F2016%2F09%2F24%2F2016b%2FGCD%E8%B0%83%E5%BA%A6%E7%BB%84%2F</url>
    <content type="text"><![CDATA[GCD 调度组-oc 调度组是最重要的一监听一组任务的完成 创建调度组 创建队列 调度组监听队列调度任务 1234567891011121314dispatch_group_t group = dispatch_group_create();dispatch_queue_t que = dispatch_get_global_queue(0, 0);dispatch_async(que, ^&#123; NSLog(@"aaaaa%@",[NSThread currentThread]);&#125;);dispatch_async(que, ^&#123; NSLog(@"bbbbb%@",[NSThread currentThread]);&#125;);dispatch_async(que, ^&#123; NSLog(@"ccccccc%@",[NSThread currentThread]);&#125;);dispatch_group_notify(group, que, ^&#123; NSLog(@"come herer%@",[NSThread currentThread]);&#125;); {% asset_img GCD调度组1.png %} 调度的入组出组 入组，出组，相互对应，不多不少。 1234567891011121314151617181920212223242526dispatch_group_t group = dispatch_group_create();dispatch_queue_t que = dispatch_get_global_queue(0, 0);dispatch_group_enter(group); // 入组dispatch_async(que, ^&#123; NSLog(@"aaaaa%@",[NSThread currentThread]); dispatch_group_leave(group); // 出组&#125;);dispatch_group_enter(group);dispatch_async(que, ^&#123; NSLog(@"bbbbb%@",[NSThread currentThread]); dispatch_group_leave(group);&#125;);dispatch_group_enter(group);dispatch_async(que, ^&#123; NSLog(@"ccccccc%@",[NSThread currentThread]); dispatch_group_leave(group);&#125;);dispatch_group_notify(group, que, ^&#123; NSLog(@"come herer%@",[NSThread currentThread]);&#125;); GCD 调度组-swift 为了监听所有图像缓存，使用DispatchGroup enter 之后跟随block block 中有leave，配对存在 1234567891011121314151617func textGroup()&#123; let group = DispatchGroup() let queue = DispatchQueue.global() group.enter() queue.async &#123; print("aaaaa\(Thread.current)") group.leave() &#125; group.enter() queue.async &#123; print("bbbbb\(Thread.current)") group.leave() &#125; group.notify(queue: DispatchQueue.main) &#123; print("come here is end \(Thread.current)") &#125; &#125;]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Swift学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift自动引用计数]]></title>
    <url>%2F2016%2F09%2F23%2F2016b%2Fswift%E8%87%AA%E5%8A%A8%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1.自动引用计数实践 ARC 初始化 12345678910var reference1: Person?var reference2: Person?var reference3: Person?reference1 = Person(name: "John Appleseed")reference2 = reference1reference3 = reference1reference1 = nilreference2 = nil // 此时person对象还没有释放，reference3 = nil // 执行之后，对象进行释放，打印deinit 方法// 打印 “John Appleseed is being deinitialized 2.类实例之间的循环强引用 Person 和Apartment 3.解决实例之间的循环强引用 — 弱引用（weak reference） Swift 提供了两种办法用来解决你在使用类的属性时所遇到的循环强引用问题：弱引用（weakreference）和无主引用（unownedreference ） 4.解决实例之间的循环强引用 — 无主引用（unowned reference ） 在前面加上关键字unowned表示这是一个无主引用 Person和Apartment的例子展示了两个属性的值都允许为nil，并会潜在的产生循环强引用。这种场景最适合用弱引用来解决。 Customer和CreditCard的例子展示了一个属性的值允许为nil，而另一个属性的值不允许为nil，这也可能会产生循环强引用。这种场景最适合通过无主引用来解决。 5.无主引用以及隐式解析可选属性 在这种场景中，两个属性都必须有值，并且初始化完成后永远不会为nil。在这种场景中，需要一个类使用无主属性，而另外一个类使用隐式解析可选属性 Country的构造函数调用了City的构造函数。然而，只有Country的实例完全初始化后，Country的构造函数才能把self传给City的构造函数 为了满足这种需求，通过在类型结尾处加上感叹号（City!）的方式，将Country的capitalCity属性声明为隐式解析可选类型的属性。这意味着像其他可选类型一样，capitalCity属性的默认值为nil，但是不需要展开它的值就能访问它 由于capitalCity默认值为nil，一旦Country的实例在构造函数中给name属性赋值后，整个初始化过程就完成了。这意味着一旦name属性被赋值后，Country的构造函数就能引用并传递隐式的self。Country的构造函数在赋值capitalCity时，就能将self作为参数传递给City的构造函数 6.闭包引起的循环强引用 Swift 提供了一种优雅的方法来解决这个问题，称之为闭包捕获列表（closure capture list） 定义了一个类，一个懒加载属性，懒加载属性是个闭包，内部强引用了类的2个属性 实例化对象 实例和闭包的引用关系如下： 7.解决闭包引起的循环强引用 在定义闭包时同时定义捕获列表作为闭包的一部分，通过这种方式可以解决闭包和类实例之间的循环强引用 捕获列表中的每一项都由一对元素组成，一个元素是weak或unowned关键字，另一个元素是类实例的引用（例如self）或初始化过的变量（如delegate = self.delegate!）。这些项在方括号中用逗号分开 1234lazy var someClosure: (Int, String) -&gt; String = &#123; [unowned self, weak property= self. property!] (index: Int, stringToProcess: String) -&gt; String in // 这里是闭包的函数体&#125; 8.使用弱引用和无主引用 在闭包和捕获的实例总是互相引用并且总是同时销毁时，将闭包内的捕获定义为无主引用。 相反的，在被捕获的引用可能会变为nil时，将闭包内的捕获定义为弱引用。弱引用总是可选类型，并且当引用的实例被销毁后，弱引用的值会自动置为nil。这使我们可以在闭包体内检查它们是否存在。 注意如果被捕获的引用绝对不会变为nil，应该用无主引用，而不是弱引用。]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Swift学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDwebImage实现图片下载-圆角]]></title>
    <url>%2F2016%2F09%2F23%2F2016b%2FSDwebImage%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8B%E8%BD%BD-%E5%9C%86%E8%A7%92%2F</url>
    <content type="text"><![CDATA[1.设置UIImageView分类异步处理图片 SDWebImage 的实现远离 downloadImage 是SDWebImage 的核心方法 图像下载完成之后，会自动保存在沙盒中，文件路径是URL的md5 如果沙盒中已经存在缓存的图像，后续使用SD通过URL加载图像，都会加载本地沙盒图像 不会发起网络请求，同时回调方法，同样会调用 方法还是原来的方法，调用还是原来的调用，不过内部不会再次发起网络请求 设置图片的异步设置，并且同一个方法中可以设置圆角半径 12345678910111213func jy_setImage(urlString:String?,placeholerImage:UIImage?,isAvatar:Bool = false)&#123; guard let urlStr = urlString ,let url = URL(string: urlStr) else &#123; image = placeholerImage return &#125; sd_setImage(with: url, placeholderImage: placeholerImage, options: [], progress: nil) &#123;[weak self] ( image, _, _, _) in if isAvatar &#123; self?.image = image?.getRoundedImage(size: (self?.bounds.size)!) &#125; &#125;&#125; 异步下载图片封装，得到Image 1234567static func jy_downImage(urlString:String?,complention:@escaping (UIImage?, Data?, Error?, Bool)-&gt;())-&gt;()&#123; guard let urlStr = urlString ,let url = URL(string: urlStr) else &#123; return &#125; SDWebImageManager.shared().imageDownloader?.downloadImage(with: url, options: [], progress: nil, completed: complention)&#125; 2.修复图片拉伸，压缩影响性能 根据尺寸重新绘图 设置尺寸 开启图像上下文 绘图，指定固定区域 取得结果 关闭上下文 123456let rect = CGRect(origin: CGPoint(), size: size)UIGraphicsBeginImageContextWithOptions(size, true, 0)aimage.draw(in: rect)let result = UIGraphicsGetImageFromCurrentImageContext()UIGraphicsEndImageContext()return result 设置圆角图片 设置区域 开启图像上下文 背景颜色填充，填充整个区域 设置路径，设置裁剪 开始绘图，指定固定区域 设置边线，颜色填充，边线宽度，填充 取得结果 关闭上下文 12345678910111213let rect = CGRect(origin: CGPoint(), size: size)UIGraphicsBeginImageContextWithOptions(size, true, 0)backGroudColor?.setFill()UIRectFill(rect)let path = UIBezierPath(ovalIn: rect)path.addClip()self.draw(in: rect)UIColor.red.setStroke()path.lineWidth = 2 // 默认是1path.stroke()let result = UIGraphicsGetImageFromCurrentImageContext()UIGraphicsEndImageContext()return result]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>实用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现cell处理]]></title>
    <url>%2F2016%2F09%2F22%2F2016b%2F%E5%AE%9E%E7%8E%B0cell%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[实现微博cell处理 单条微博的处理 / 图片高度自适应 1.多张，单张图片高度的处理 单条微博的视图模型 如果没有任何父类，如果希望在开发时调试，输出调试信息，需要 遵守CustomStringConvertible协议 实现desciription 是计算型属性 123var description:String &#123;return status.description&#125; 视图列表模型 中引用视图模型 listViewModel -&gt; aViewModel 1234567891011121314var arrary = [WBStatusViewModel]()// for 循环遍历返回的数组，字典转模型for dict in list ??[ ] &#123; guard let model = WBStatus.yymodel(with:dict) else &#123; continue &#125; // 根据转的model，初始化ViewModel，拼接到数组中 arrary.append(WBStatusViewModel(model:model)) // 如果是上拉刷新，数据拼接末尾，不是上拉刷新，拼接在数组前面 if pullUp &#123; self.statusList +=arrary &#125;else&#123; self.statusList = arrary + self.statusList &#125; &#125; ViewModel中增加储值属性，使用内存换CPU，cell中不用重复计算 增加会员image，认证image，数字字符串，储值属性，在cell中直接赋值 一个xib中拖出来N个View，如果功能独立，可以创建view方便处理 创建view添加到Cell上 2.图片的处理 九宫格的创建，9个UIImageView for循环设置frame 九宫格视图的计算 设置外边距，内边距 根据外边距，内边距，设置view宽度，设置PictureView的宽度，高度（1*1） 根据count计算列数， 根据列数，计算view的高度 1234567891011func calcPictureViewSize(count:Int?)-&gt;CGSize&#123; guard let count = count else&#123; return CGSize() &#125; // 计算配图视图高度 // 外边距 let WBStatusPictureViewOuterMargin = CGFloat(12) /// 内边界 let WBStatusPictureViewInnerMargin = CGFloat(3) /// view视图的W let height = WBStatusPictureViewOuterMargin + CGFloat(row) * pitureWith + CGFloat(row-1)*WBStatusPictureViewInnerMargin return CGSize(width: pictureItmeWidth, height: height)&#125; 3.单图的处理 使用GCD调度组，下载一个图片之后处理单张图片的大小，保存下来 在viewMolde 中增加方法，使用储值属性记录imageSize 在listModel每次下载完成一张图片之后进行调用刷新PictureSize 等调度组完成之后，之后再回调。 当一个图过宽或者过窄的时候需要程序处理 在PictureView 中设置statusMolde 根据model的pictureSize 处理宽高，处理单图，处理无图 4.cell的自动布局，和缓存行高 自动布局 设置tableView预估行高，和rowHeight 是自动计算 有一个从上到下的约束，lable 到下边距是&gt;= 一个数组 123let table = UITableView()table.rowHeight = UITableViewAutomaticDimensiontable.estimatedRowHeight = 300; 缓存行高 取消xib 中&gt;= 约束，设置为=约束 取消table.rowHeight = UITableViewAutomaticDimension 计算cell高度思路 计算文字，转发文字的长度 计算的高度，使用存储属性记录，设置好image更新高度后再计算一边 总结缓存行高 5.选中的某个cell后快速的恢复到选中前的状态 tableView 如何让选中的某个cell后快速的恢复到选中前的状态(选中时的灰色动态消失)?]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>实用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift学习笔记《5》- 实用]]></title>
    <url>%2F2016%2F09%2F21%2F2016b%2Fswift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8A5%E3%80%8B%2F</url>
    <content type="text"><![CDATA[1.setValue:forKeyPath实现原理 setValue:forKeyPath实现原理 先看有没有对应key值的set方法，如果有set方法，就会调用set方法，给对应的属性赋值 如果没有set方法，去查看有没有跟key值相同并且带有下划线的成员属性，如果有的话，就给带有下划线的成员属性赋值， 如果没有跟key 值相同并且带有下划线的成员属性，还会去找没有跟key 值相同的成员属性，如果有直接给它赋值， 如果没有直接报错 2. button 颜色显示系统tineColor的解决办法 button 颜色显示系统tine的解决办法 在Assets 中设置图片的Render为Orignnal Image 使用代码设置 imageWithRenderingMode: 123UIImage *image = [UIImage imageNamed:@"aimage"];UIImage *oriImage = [image imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal]; 3.导航条隐藏 导航条隐藏 导航条或者导航条上的控件设置透明度是没有效果的 self.navigationController.navigationBar.alpha = 0; 如果需要设置透明背景，设置导航条背景，BackgroundImage必须默认模式是UIBarMetricsDefafault 当背景图片设置为nil 的时候，ShadowImage 系统会自动生成一张半透明的图片，设置为导航条背景 4.Transform 使用make 是相对于最原始的位置做的形变 使用CGAffineTransformTranslate 是相对于上一次做形变 5.view 的任意拖拽 在touchMoved a 方法里，计算XY方向的偏移量，设置view的transform， 6.事件传递： 如果父控件不能接收触摸事件，那么子控件就不可能接收到触摸事件， 如何找到最合适的控件来处理事件、 判断自己能否接收触摸事件 触摸点是否在自己身上 从后往前便利子控件，重复前面的2个步骤 如果没有符合条件的子控件 ，那么就自己最适合处理 7.tableView 的缩进处理 取消自动调整滚动视图的间距，- VC+NAV 会自动调整tanleView的contentInset 如果设置了tableview的缩进，记得设置scrollIndictiorInsets; navBar 相融的问题，不显示在底部,从隐藏到显示，控制animated 就是可以的 8.实现图片的，下拉放大，上推隐藏，直至隐藏渐变显示导航条 放大代码实现 下拉，contentOffset 是负值 向上移动的时候，当超过64的时候，不再移动 动态变化设置图片的透明度 根据推的长度，控制显示状态栏是黑色还是白色 如果不设置背景颜色，拖拽手势返回的时候，右上角会有黑色，设置导航栏的背景色是白色 9.实现图片的压缩处理圆角处理(加入线程) 使用CoreGraphisc是耗时操作，讲图片处理放在全局队列中，结果放在主线程中 1-(void)cz_coreImageWithSize:(CGSize)size fillColor:(UIColor*)fillColor complection:(void(^)(UIImage*image))complection; 具体实现如下 10.Xcode 使用 替换已有类名：.h选中要改的类名 —&gt; 菜单栏选中 Edit —&gt; Refactor —&gt; Rename 替换已有类名： Xcode 修改应用的名字找到 TARGETS 中的 Build Setting , 搜索 Product Name－&gt;双击修改]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Swift学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift学习笔记《4》]]></title>
    <url>%2F2016%2F09%2F21%2F2016b%2Fswift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8A4%E3%80%8B%2F</url>
    <content type="text"><![CDATA[1.swift Protocol 设置可选协议方法 需要遵守NSObjectProtocol 协议 协议需要是 @objec 方法是需要@object optional 123@objc protocol CircleDelegate:NSObjectProtocol &#123; @objc optional func cirelcPrint()&#125; 定义delegate 属性 weak var delegate:CircleDelegate? 调用代理方法 delegate?.cirelcPrint?() protocol mutating 关键字 使用mutation 关键字来标记一个会修改结构体的刚发 class 中不需要使用mutating标记，因为类总方法通常可以修改类属性 可以给系统方法增加写extion,遵守代理 2.switchCase case let x where x.hasSuffix(“peper”): print(“li it a spicy”) 可以在case中使用where 进行判断 3.元组 取元组可以根据属性，也可以根据下标取 123let amutule : (min:Int,max:Int,sum:Int) = (2,4,6)print(amutule.sum)print(amutule.2) 4.函数的不确定参数个数 传入一个不确定参数类别，计算和 12345678func sumOfnumbers(numbers:Int...)-&gt;Int&#123; var sum = 0 for numbe in numbers &#123; sum += numbe &#125; return sum&#125;print("\(sumOfnumbers(numbers: 2,3,4,5,5))") 5.函数作为一个参数，传入另一个函数中 一个函数传入一个参数，一个判断条件的函数参数，返回值是bool 在函数内部，传参数1，调用函数参数判断 6.函数作为返回值 函数作为返回值 适用的时候，生产函数类型的变量，调用变量（函数）方法 7.集合map的使用 使用map 批量操作集合内的元素 匹配符合集合的元素批量处理，也可以进行判断，不符合条件的为0 如果一个闭包的类型已知，并且作为回调函数，可以忽略参数类型和返回值，单个闭包语句，会把它语句的值当作返回值返回 可以通过参数所在的位置，替代参数名来引用参数，在非常短的闭包中非常有用 8.setter 和getter 方法 在setter 中新值是newValue 可以在set 后面显示设置一个别名 9.监测API 可用性 监测API 可用性 iOS 10 1234567func textAPI()&#123; if #available(iOS 10, macOS 10.12,*) &#123; // 在iOS 10使用，MacOS 10。12使用 &#125;else&#123; // 使用先前的iOS，macOS的API &#125;&#125; 10.swift 数组 数组的CRUD 123456789101112131415var aArray = Array(repeating: 0.4, count: 3);//aArray.isEmpty//aArray.append(&lt;#T##newElement: Double##Double#&gt;)//aArray.insert(&lt;#T##newElement: Double##Double#&gt;, at: &lt;#T##Int#&gt;)//aArray.remove(at: &lt;#T##Int#&gt;)//aArray.removeLast()for (indx,value) in aArray.enumerated() &#123;print("\(indx)----\(value)")&#125; 11.swift字符串 字符串的CRUD 12345678910111213141516171819202122232425func textString()&#123; var astring = "Guten Tag!" if astring.isEmpty &#123; // 空字符串 &#125; print("\(astring[astring.startIndex])") // G print("\(astring[astring.index(before: astring.endIndex)])") // ! print("\(astring[astring.index(after: astring.startIndex)])") // u // let aindex = astring.index(astring.startIndex, offsetBy: 7); // print("\(astring[aindex])") // a astring.insert("!", at: astring.endIndex) astring.insert(contentsOf: "there".characters, at: astring.index(before: astring.endIndex)) // 前缀 - 后缀 _ = astring.hasPrefix("acutnr") _ = astring.hasSuffix("!")&#125; 12.范型 实用方法： 在尖括号里面写一个名族创建一个范型函数或者类型 定一个函数，传入一个未知类型参数，重复N词，返回数组，数组红元素类型就是传入的类型 使用范型- 重新实现可选类型 定义可选类型的枚举 使用赋值 实现方法，限定参数遵守协议，类型是相同的 比较两个数组中相同的元素，有返回true，没有返回false 可以计算 两个集合中相同的元素返回 在类型名之后使用where 制定类型的需求 比如，限定类型实现某一个协议，限定两个类型是相同的，或者限定某个类必须有一个特定的父类” where T.Iterator.Element: Equatable, T.Iterator.Element == U.Iterator.Element 12345678910func anyCommonElements&lt;T:Sequence,U:Sequence&gt;(_ lhs :T,_ rhs: U)-&gt;Bool where T.Iterator.Element:Equatable,T.Iterator.Element == U.Iterator.Element&#123; for lhsElement in lhs &#123; for rhsElement in rhs &#123; if lhsElement == rhsElement &#123; return true &#125; &#125; &#125; return false&#125; 13.集合操作 a.intersection(b) A和B集合的交集 (A&amp;B) a.symmtriDifference(b) A +B - (A&amp;B) a.union(b) A+B a.subtracting(b) A-(A&amp;B) 14.递归枚举 在枚举成员前面，加上 indirect 关键字，是可以递归的 12345enum ArithmeticExpression &#123; case number(Int) indirect case addition(ArithmeticExpression,ArithmeticExpression) indirect case multiplication(ArithmeticExpression,ArithmeticExpression) &#125; 调用枚举 1234let five = ArithmeticExpression.number(5)let foure = ArithmeticExpression.number(4)let sum = ArithmeticExpression.addition(five, foure)let procuct = ArithmeticExpression.multiplication(sum, .number(2)) 操作能可以递归的枚举，需要可以递归的函数， 如果是纯数字，直接返回该值，如果是加法，或者乘法，计算左右的算法的值，然后相加，乘 12345678910func evaluate(_ expression:ArithmeticExpression) -&gt; Int&#123; switch expression &#123; case let .number(value): return value case let .addition(left, right): return evaluate(left) + evaluate(right) case let .multiplication(left, right): return evaluate(left) * evaluate(right) &#125;&#125; 15.Swift 下标 subscript 写法： 定义下标使用subscript关键字，指定一个或多个输入参数和返回类型 与实例方法不同的是，下标可以设定为读写或只读 1234567891011subscript (index:Int)-&gt;Int&#123; get&#123; //返回一个适当的int 类型的操作 return 0 &#125; set(newValue)&#123; // 执行适当的赋值操作 &#125;&#125; 下标可以接受任意数量的入参，并且这些入参可以是任意类型。下标的返回值也可以是任意类型。下标可以使用变量参数和可变参数，但不能使用输入输出参数，也不能给参数设置默认值 定义了一个Matrix结构体，用于表示一个Double类型的二维矩阵 123456789101112131415161718192021222324struct Matrix &#123; let rows: Int, columns: Int var grid: [Double] init(rows: Int, columns: Int) &#123; self.rows = rows self.columns = columns grid = Array(repeating: 0.0,count: rows * columns) &#125; func indexIsValidForRow(row: Int, column: Int) -&gt; Bool &#123; return row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; column &gt;= 0 &amp;&amp; column &lt; columns &#125; // N 行 * N 列的矩阵 subscript(row: Int, column: Int) -&gt; Double &#123; get &#123; assert(indexIsValidForRow(row: row, column: column), "Index out of range") return grid[(row * columns) + column] &#125; set &#123; assert(indexIsValidForRow(row: row, column: column), "Index out of range") grid[(row * columns) + column] = newValue &#125; &#125;&#125; 使用 16.swift析构过程 析构器用deinit 表示 – 构造器init deinit {} 17.swift访问控制 模块和源文件 使用import 导入另外一个模块 访问级别 五种不同的访问级别 开放访问／公开访问 —–同一模块下的任意文件，任意方法，任意实体 内部访问 —-在模块内访问任何实体，到那时不能从外部导入模块访问 文件私有访问 只能在定义的文件内部访问 私有访问限制 只能在定义的作用域内访问 开放访问权限最高，私有访问最低访问级别 开放访问只作用于类类型和类的成员，和公开访问区别如下 开放访问的类，可以在模块内，模块外继承，公开访问和更严的访问级别的类，只能在他们定义的模块内部被继承 开放访问的类成员，可以在模块内，模块外的子类重写，公开访问只能在定义的模版内部重写。 默认访问级别 interal 级别 单目标程序，是为整个程序服务的，默认interal 即可。 访问控制语法 通过 open,public,internal,filepart,private , 修饰符，声明实体的访问级别： 子类的访问级别不得高于父类的访问级别 函数的访问级别 18.Pch 文件创建 工程 - &gt;TARGETS -&gt; Bulid Settings -&gt;搜索prefix -&gt; LLVM -Language 下的Precompile Prefix Header 设置置为YES，默认是NO。 LLVM -Language 设置下，Prefix Header pch文件路径]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Swift学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift学习笔记《3》-技巧]]></title>
    <url>%2F2016%2F09%2F21%2F2016b%2Fswift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8A3%E3%80%8B%2F</url>
    <content type="text"><![CDATA[1.swift打印 自定义printLog 12345678func printLog&lt;T&gt;(message : T, fileName : String = __FILE__, lineNum : Int = __LINE__) &#123; #if DEBUG // 处理fileName let file = (fileName as NSString).lastPathComponent print("\(file):[\(lineNum)]") #endif&#125; 2.获取命名空间 let nas = Bundle.main.infoDictionary![&quot;CFBundleExecutable&quot;] as! String 3.try 的三种方式 JSONObjectWithData(data: NSData, options opt: NSJSONReadingOptions)函数会抛出异常 throws 需要用try 获取 try 需要用do catch 错误放在catch 中的error中 12345do &#123; let aaa = try JSONObjectWithData()&#125;catch&#123; print(\(error)) &#125; try? 如果没有值，返回nil 返回值是可选类型 try!相当于告诉系统一定没有异常，发生异常会崩溃 4.storyBoard Refrence 方式1 选中需要的控制器 选择导航条的editor 选择下拉菜单 refector to sroryboard 方式2 在控件库中拖入storyboard refrence 新建一个storyboard 点击storyboard refrence 关联到建立的storyboard， 原来的控件中就可以与 storyboard refrence 连线跳转 5.swift封装 AFN 设置网络工具枚举 POST，GET 1234enum RequestMothod:String &#123;case POST = "POST"case GET = "GET"&#125; 封装网络请求单例类 1234567class NetworkTools : AFHTTPSessionManager &#123; static let shareTools : NetworkTools = &#123; let tools = NetworkTools() tools.responseSerializer.acceptableContentTypes?.insert("text/plain") return tools &#125;&#125; AFN 内部方法的封装 封装POST，GET 用一个方法封装 使用关键字 typealias 设置方法的block ，参数是返回值，错误信息，返回值是空(rest:Any,error:Error )-&gt;() 定义方法中的参数，type ,urlstring ,pramas, 上面的回调的block 在方法中定义成功的闭包，失败的闭包，用于传进AFN的方法参数，12345678910111213141516171819202122232425// 内部封装AFN 请求extension AFNNetWorkTool &#123; //typealias callBack = (_ aresult:AnyObject?,_ erro:Error)-&gt;() func afnRequest(methodType:AFNnetRequsetType,urlString:String,parames:[String:AnyObject]?,finished:@escaping (_ result:Any?,_ error:Error?)-&gt;())&#123; // 定义成功的回调 let seccessBlck = &#123; (task:URLSessionDataTask,resuurt:Any?)-&gt;() in finished(resuurt,nil) &#125; // 定义失败的回调 let faitureBlock = &#123; (tast:URLSessionDataTask?,error:Error)-&gt;() in finished (tast,error) &#125; if methodType == .GET &#123; get(urlString, parameters: parames, progress: nil, success: seccessBlck, failure: faitureBlock) &#125;else&#123; post(urlString, parameters: parames, progress: nil, success: seccessBlck, failure: faitureBlock) &#125; &#125;&#125; 6 Alamofire 监测网络 使用alamofire 监测网络状况 123456789101112131415let NetworkManager = NetworkReachabilityManager(host: "www.baidu.com")NetworkManager!.listener = &#123; status in print("") switch status &#123; case .NotReachable: print("") case .Unknown: print("") case .Reachable(.EthernetOrWiFi): print("") case .Reachable(.WWAN): print("") &#125; &#125;NetworkManager!.startListening() 7.UIWebView 自动填充账户密码 每次输入网页需要填充账户名密码十分麻烦，结合safari开模拟查看网页上标签 123let js = "document.getElementById('userId').value = '1606020376@qq.com';" + "document.getElementById('passwd').value = 'haomage';" webView.stringByEvaluatingJavaScriptFromString(js) 8.双击底部tabbarItem刷新数据 判断索引是当前，并且将要点击是当前 让滑倒顶部 刷新数据，延迟加载 清除角标 1234567891011let index = childViewControllers.index(of: viewController)if selectedIndex == 0 &amp;&amp; selectedIndex == index&#123; let nav = childViewControllers[0] as! UINavigationController let vc = nav.childViewControllers[0] as! HomeVC vc.tableView?.setContentOffset(CGPoint(x: 0, y: -64), animated: true) DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 1 , execute: &#123; vc.loadData() &#125;) vc.tabBarItem.badgeValue = nil UIApplication.shared.applicationIconBadgeNumber = 0&#125; 9. 毛玻璃 - 高斯模糊 Vleual Effect View 选择，extra Light 就可以 子视图添加在View上，并且不透明 10.POP 基本概念 支持3种动画类型 弹力动画POPSPringAnimation 衰减动画 POPDelayAnimation 基本动画 POPBasicAnimation 如果需要做延时动画需要如下代码 12// 5秒之后的延迟anim.beginTime = CACurrentMediaTime( ) + CFTimeInterval ( 5) 11.Block 的延时执行，需要的时候再执行 当前方法不能执行，使用属性记录，在需要的时候再执行 123// 定义一个属性，是可选的闭包，// 闭包有参数无返回值 private var comlentionBlock:( (clasName:String? ) -&gt; ( ) )? 当属性引用闭包，闭包右修改了属性，必发生循环引用，在闭包中使用【weak self】 12.单例方法严谨 单例如果调用了init方法，和share方法，得到的是不同的对象， init 用private 修饰，外部只能使用share 方法 1234static let share = CZEmotionManager()private init() &#123; loadPackAges()&#125; 13.加载bundle中的图片素材 通过mainBundle，找到素材bundle 找到素材plist的path，plist转为数组 1234567guard let path = Bundle.main.path(forResource: "HHEmotion.bundle", ofType: nil), let bundle = Bundle(path: path) , let plistpath = bundle.path(forResource: "emotion.plist", ofType: nil), let arry = NSArray(contentsOfFile: plistpath) as? [[String:String]] else &#123; return &#125;print("\(arry)") 14.过滤数组 - 尾随闭包的简单写法 OC 中过滤数组，使用谓词 swift 中，过滤使用filter， P是数组，判断数组中的模型的一个属性的值是不是相等 直接过滤 尾随闭包： 如果是尾随闭包只有一句，并且是返回，闭包格式可以省略，参数省略之后，可以使用0,1….以此替代原有的参数 return 也可以省略 15.测试正则表达式 匹配中间带【】的字符，任何字符都行 字符中 【】() 是正则表达式的关键字，如果参与匹配，需要转义 匹配所有项 for循环所有项，根据所有项所在的range，匹配出字符串 16.图片拉伸处理 根据图片的size，设置拉伸的rect 拉伸图片 1234var image = UIImage(named: "ceshiimage")let size = image?.size ?? CGSize()let inset = UIEdgeInsetsMake(size.height*0.5, size.width*0.5, size.height*0.5, size.width*0.5)image = image?.resizableImage(withCapInsets: inset) 17.UIColor 16进制转RGB 写分类 根据16进制 位运算，有移得出相对应的RGB的数值 生成颜色 1234567891011static func jy_colorWithHex(hex:u_int)-&gt;UIColor&#123; let red = Float((hex &amp; 0xFF0000) &gt;&gt; 16) let green = Float((hex &amp; 0x00FF00) &gt;&gt; 8) let blue = Float(hex &amp; 0x0000FF) return UIColor.init(colorLiteralRed: red/255.0, green: green/255.0, blue: blue/255.0, alpha: 1.0); &#125;]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Swift学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift学习笔记《2》-swift语法]]></title>
    <url>%2F2016%2F09%2F21%2F2016b%2Fswift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8A2%E3%80%8B%2F</url>
    <content type="text"><![CDATA[1.常量变量 let var 2.数据类型 整型，浮点型，对象类型，结构体类型（swift中大部分类改为了结构体） 整型 Int8 有符号8位整型 Int16 有符号16位整型 Int 32 有符号32位整型 Int 64 有符号64位整型 Int 与平台有关，默认相当于OC中NSInteger UInt8 无符号8位整型 UInt16,UInt32,UInt64 浮点型 Float 32位浮点型 Double 64位浮点型 基本运算 相同运算符之间才能参与运算，因为swift中没有隐式转换 3.逻辑分支 if switch 三目运算符 等判断语句 guard运算符(守护) 当条件表达式位true的时候跳过else语句，继续向下执行 当条件表达式为false的时候进入else语句中，break，continue，return，throw等跳出12345guard 条件表达式 else &#123; // 条换语句 break&#125;语句组 switch语句 switch 的case之后不必须加break case不在只是Int，可以是浮点，字符串，区间(0..&lt;10,0…10) 一个case 可以判断多个值，用，隔开 4.循环 for循环 开区间(0..&lt;10)，闭区间(0…10) for循环打印字典时可以使用元组 while，do-while 循环 使用repeat while循环代替do-while循环 i++已经被弃用，使用i=i+1； 5.字符串 String 是结构体，性能比NSString 高 String的长度，astring.characters.count 字符串长度 str1 + str2 两个字符串相加 字符串的格式化输出 1String(format: "%02d:%02d", arguments: [min, second]) 字符串的截取 暂时先转为NSString 进行截取 1234let myStr = "www.520it.com"var subStr = (myStr as NSString).substringFromIndex(4)subStr = (myStr as NSString).substringToIndex(3)subStr = (myStr as NSString).substringWithRange(NSRange(location: 4, length: 5)) 6数组 Array 一个范型数组 数组声明方法 12var stuArray1:Array&lt;String&gt;var stuArray2: [String] 数组的 增- 删- 改- 查 12345678// 添加数据array.append("yz")// 删除元素array.removeFirst()// 修改元素array[0] = "why"// 取值array[1] 数组的合并 同类型的两个数组可以直接相加 12345678910// 数组合并// 注意:只有相同类型的数组才能合并var array = ["why", "lmj","lnj"]var array1 = ["yz", "wsz"]var array2 = array + array1;// 不建议一个数组中存放多种类型的数据var array3 = [2, 3, "why"]var array4 = ["yz", 23]array3 + array4 7.字典 Dictionary 是个范型集合 声明方式 12var dict1: Dictionary&lt;Int, String&gt;var dict2: [Int: String] 字典的增 -删- 改- 查 123456789// 添加数据dict["height"] = 1.88dict["weight"] = 70.0// 删除字段dict.removeValueForKey("height")// 修改字典dict["name"] = "lmj"// 查询字典dict["name"] 字典的遍历 使用元组 字典的合并 1234567// 字典的合并var dict1 = ["name" : "yz", "age" : 20]var dict2 = ["height" : 1.87, "phoneNum" : "+86 110"]// 字典不可以相加合并for (key, value) in dict1 &#123; dict2[key] = value&#125; 8.元组 是swift中特有的定义一组数据，类型可相同可不相同 1234567891011121314151617// 元组:HTTP错误// let array = [404, "Not Found"]// 写法一:let error = (404, "Not Found")print(error.0)print(error.1)// 写法二:let error = (errorCode : 404, errorInfo : "Not Found")print(error.errorCode)print(error.errorInfo)// 写法三:let (errorCode, errorIno) = (404, "Not Found")print(errorCode)print(errorIno) 9.可选类型 可选类型的取值，有值或者是空值 可选类型的使用 使用场景 1234567// 该方式利用类型推导let url = NSURL(string: "www.520it.com")// 通过url来创建request对象:在使用可选类型前要先进行判断是否有值// 该语法成为可选绑定(如果url有值就解包赋值给tempURL,并且执行&#123;&#125;)if let tempUrl = url &#123; let request = NSURLRequest(URL: tempUrl)&#125; 10.函数 函数的格式 123456789func 函数名(参数列表) -&gt; 返回值类型 &#123; 代码块 return 返回值&#125;func 函数名(参数1:参数1类型，参数2：参数2类型) -&gt; 返回值类型 &#123; 代码块 return 返回值&#125; 函数 外部参数和内部参数 变量名前加标签就是外部参数 方法重写 子类重新调用父类方法是重写，override 方法重载 方法名相同但是参数不同，称为方法重载 1234567891011// num1和a是外部参数的名称func ride(num1 num1 : Int, a num2 : Int, b num3 : Int) -&gt; Int &#123; return num1 * num2 * num3&#125;var result1 = ride(num1: 20, a: 4, b: 5)// 方法的重载:方法名称相同,但是参数不同,可以称之为方法的重载(了解)func ride(num1: Int, _ num2 :Int) -&gt; Int &#123; return num1 * num2&#125;var result2 = ride(20, 20) 函数的默认参数 不传的话有个默认值123func makecoffee(type :String = "卡布奇诺") -&gt; String &#123; return "制作一杯\(type)咖啡。"&#125; 可变参数 可以接受不确定数量的输入类型参数，但必须是相同类型，在参数类型后面拼接… 来实现123456789func sum(numbers:Double...) -&gt; Double &#123; var total: Double = 0 for number in numbers &#123; total += number &#125; return total&#125;sum(100.0, 20, 30)sum(30, 80) 函数引用类型-指针传递 默认是值传递，不改变外部变量的值，如果想改变，需要传地址 传入的地址必须是变量 swift提供inout 关键字实现 11.swift中类的使用 定义类的时候可以没有父类，需要父类的话大多可以使用NSObject 作为父类，非OC的NSObject 类的属性 分为 储值属性，算值属性，类属性 储值属性 计算型属性 不存储实际值，提供getter 和可选的setter间接获取或设置其他属性， 一般只提供getter 方法，如果只实现了getter 方法，则为只读属性，可以省略get{},直接return 类属性 所有的类和类的实例都有一份类属性，如果在某一处更新后，该类属性就会被修改 类属性使用static 关键字修改， 监听属性的修改 在oc中使用set 方法监听 在swift中，使用属性观察者监听和相应属性值的变化 使用属性的will set 方法监测新值，在didset中监测旧值 willSet (new){ } didSet(old){} 在didset中生成计算型属性的值 didSet 属性直接赋值不会调用didSet方法，而是在初始化之后再赋值才能调用 12345var expires_in: NSTimeInterval = 0 &#123; didSet &#123; expiresDate = NSDate(timeIntervalSinceNow: expires_in) &#125;&#125; 12.类的构造函数 构造函数的基本使用 类的属性必须有值，如果不是在初始化的时候复制，在构造方法中给类属性赋值，123456789101112class Person: NSObject &#123; var name : String var age : Int // 重写了NSObject(父类)的构造方法 override init() &#123; name = "" age = 0 &#125;&#125;// 创建一个Person对象let p = Person() 初始化的时候给属性赋值 如果在自定义对象的时候给属性赋值，自定义init方法，会覆盖init方法，不会有默认的初始化方法1234567891011class Person: NSObject &#123; var name : String var age : Int // 自定义构造函数,会覆盖init()函数 init(name : String, age : Int) &#123; self.name = name self.age = age &#125;&#125;// 创建一个Person对象let p = Person(name: "why", age: 18) 13 字典转模型 (初始化时传入字典) 字典取值是NSObject 是任意类型 可以通过as转换之后再赋值，不同类型不能直接赋值 12345678910111213class Person: NSObject &#123; var name : String var age : Int // 自定义构造函数,会覆盖init()函数 init(dict : [String : NSObject]) &#123; name = dict["name"] as! String age = dict["age"] as! Int &#125;&#125;// 创建一个Person对象let dict = ["name" : "why", "age" : 18]let p = Person(dict: dict) 14 字典转模型 (KVC 转化) kvc 不能保证全部复制，所以属性要有默认值，基本数据类型默认值是0，对象结构体定义为可选即可1234567891011121314151617class Person: NSObject &#123; // 结构体或者类的类型,必须是可选类型.因为不能保证一定会赋值 var name : String? // 基本数据类型不能是可选类型,否则KVC无法转化 var age : Int = 0 // 自定义构造函数,会覆盖init()函数 init(dict : [String : NSObject]) &#123; // 必须先初始化对象 super.init() // 调用对象的KVC方法字典转模型 setValuesForKeysWithDictionary(dict) &#125;&#125;// 创建一个Person对象let dict = ["name" : "why", "age" : 18]let p = Person(dict: dict) 15闭包的介绍 闭包就是匿名函数 block 的写法 12345678类型：返回值(^block的名称)(block的参数列表)------值：^(参数列表)&#123; // 执行的代码&#125; swift的写法 定义网络请求的类 123func loadRequest(callBack:()-&gt;())&#123; callBack()&#125; 使用闭包 123httpTool.loadRequest( &#123; ( )-&gt;( ) in tableView.reloadData&#125;) 闭包总结 12345678闭包的写法：类型： （型参列表）-&gt;( 返回值 )值：&#123; ( 型参列表 ) -&gt; 返回值类型 in // 执行代码&#125; 尾随闭包 如果闭包没有参数没有返回值，( ) -&gt; ( ) in可以省略 如果闭包是作为函数的最后一个参数，则可以将闭包写在（）后面 如果函数只有一个参数，且最后一个参数是闭包，那么（）也可以不写，直接在方法名后面拼接{} 12345678910111213141516171819省略前httpTool.loadRequest(&#123; ( ) -&gt; ( ) in print(完全不省略)&#125;)省略1httpTool.loadRequest(&#123; print(省略括号 in)&#125;)省略2httpTool.loadRequest( )&#123; print(小括号前置)&#125;省略3httpTool.loadRequest&#123; print(终结版尾随闭包)&#125; 16.闭包的循环引用 deinit{}实现deinit 函数，检测一个对象是否销毁 swift 循环引用的三种方式 使用weak，使用【weak self】，使用unowned 关键字 使用weak 关键字对控制器持有，weakself是可选类型，使用时强行解包，因为一定有值 12345weak var weakSelf = selfhttpTool.loadData &#123; print("加载数据完成,更新界面:", NSThread.currentThread()) weakSelf!.view.backgroundColor = UIColor.redColor()&#125; 使用 【weak self】 【weak self 】写在闭包中，在闭包中使用的self 都是weak的 1234httpTool.loadData &#123;[weak self] () -&gt; () in print("加载数据完成,更新界面:", NSThread.currentThread()) self!.view.backgroundColor = UIColor.redColor()&#125; unowned 类似oc的unretain ,即使原来引用的对象释放了，也会对释放的对象，持有一个无效的引用，不是可选的，不可能指向nil 1234httpTool.loadData &#123;[unowned self] () -&gt; () in print("加载数据完成,更新界面:", NSThread.currentThread()) self.view.backgroundColor = UIColor.redColor()&#125; 17.懒加载 希望所有的对象，只有加载的时候才能加入到内存中， lazy 关键字，是专门修饰懒加载属性的 格式 1lazy var 变量名 = &#123; 创建变量代码 &#125;() 使用 123456// 懒加载的本质是,在第一次使用的时候执行闭包,将闭包的返回值赋值给属性// lazy的作用是只会赋值一次lazy var array : [String] = &#123; () -&gt; [String] in return ["why", "lmj", "lnj"]&#125;() 18.便利构造函数 convenience : 便利,使用convenience修饰的构造函数叫做便利构造函数 便利构造函数通常用在对系统的类进行构造函数的扩充时使用 便利构造函数的特点 便利构造函数，一般写在extension中 便利构造函数，在init前面添加convenience 关键字 在便利构造器中需要明确调用self.init(), 而且是先调用。 在继承中，重写父类的方法中，初始化自己的方法中，先初始化自己的属性，之后调用父类的super.init() 19 #Selector() 事件监听 事件监听本质发送消息.但是发送消息是OC的特性 将方法包装成@SEL –&gt; 类中查找方法列表 –&gt; 根据@SEL找到imp指针(函数指针) –&gt; 执行函数 如果swift中将一个函数声明称private,那么该函数不会被添加到方法列表中 如果在private前面加上@objc,那么该方法依然会被添加到方法列表中 20.类型转换 类型转换在 Swift 中使用is和 as操作符实现 ，你也可以用它来检查一个类型是否实现了某个协议，就像在检验协议的一致性部分讲述的一样。 定一个类MediaItem，name 属性,init(name:) 方法 其2个子类Movie，Song 检查类型 is判断是一个实例，是否属于特定子类 if item is Movie 向下转型 使用子类特有的属性和方法，使用as 转化为子类 as?和as! 21.Any 和 AnyObject 的类型转换 Any 表示任何类型，包括函数类型 AnyObject表示任何类型的实例 123456789101112131415161718192021222324252627282930313233for thing in things &#123; switch thing &#123; case 0 as Int: print("zero as an Int") case 0 as Double: print("zero as a Double") case let someInt as Int: print("an integer value of \(someInt)") case let someDouble as Double where someDouble &gt; 0: print("a positive double value of \(someDouble)") case is Double: print("some other double value that I don't want to print") case let someString as String: print("a string value of \"\(someString)\"") case let (x, y) as (Double, Double): print("an (x, y) point at \(x), \(y)") case let movie as Movie: print("a movie called '\(movie.name)', dir. \(movie.director)") case let stringConverter as String -&gt; String: print(stringConverter("Michael")) default: print("something else") &#125;&#125;// zero as an Int// zero as a Double// an integer value of 42// a positive double value of 3.14159// a string value of "hello"// an (x, y) point at 3.0, 5.0// a movie called 'Ghostbusters', dir. Ivan Reitman// Hello, Michael 22.在一个类型中嵌套另外一个类型 BlackjackCard（二十一点）,结构体中，嵌套Suit,Rank 两个枚举 1234567891011121314151617181920212223242526272829303132333435363738394041struct BlackjackCard &#123; // 嵌套的 Suit 枚举 enum Suit: Character &#123; case Spades = "♠", Hearts = "♡", Diamonds = "♢", Clubs = "♣" &#125; // 嵌套的 Rank 枚举 enum Rank: Int &#123; case Two = 2, Three, Four, Five, Six, Seven, Eight, Nine, Ten case Jack, Queen, King, Ace struct Values &#123; let first: Int, second: Int? &#125; var values: Values &#123; switch self &#123; case .Ace: return Values(first: 1, second: 11) case .Jack, .Queen, .King: return Values(first: 10, second: nil) default: return Values(first: self.rawValue, second: nil) &#125; &#125; &#125; // BlackjackCard 的属性和方法 let rank: Rank, suit: Suit var description: String &#123; var output = "suit is \(suit.rawValue)," output += " value is \(rank.values.first)" if let second = rank.values.second &#123; output += " or \(second)" &#125; return output &#125;&#125; 初始化 let theAceOfSpades = BlackjackCard(rank: .Ace, suit: .Spades) 使用：let heartsSymbol = BlackjackCard.Suit.Hearts.rawValue]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Swift学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift学习笔记《1》]]></title>
    <url>%2F2016%2F09%2F21%2F2016b%2Fswift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%8A1%E3%80%8B%2F</url>
    <content type="text"><![CDATA[1.UIButton button 的初始化，点击事件 button 传入参数，和不传入参数市一样的，好像只写方法名 button 的属性 123456view.backgroundColor=UIColor.greenlet btn = UIButton(type: .system)btn.setTitle("button", for: .normal)btn.frame=CGRect(x: 100, y: 100, width: 100, height: 100)btn.addTarget(self, action: #selector(btnClick), for: .touchUpInside)view.addSubview(btn) 123func btnClick(buttt:UIButton) &#123;print(buttt) &#125; 2.UITableView 懒加载 lazy 关键字 + var 属性名 ：[集合中的类型] = { 设置return 类型 } ( ) mark 的标记 // MARK:懒加载 123lazy var dataSoure: [String] = &#123; return ["11","22","33","44","55"]&#125;() tableView的属性 跟OC类似， 1234567class ViewController: UIViewController,UITableViewDelegate,UITableViewDataSource &#123; override func loadView() &#123; let tv = UITableView(frame: UIScreen.main.bounds) tv.dataSource=self tv.delegate=self view=tv &#125; tableView的代理设置 实现代理，是在类后面逗号隔开 tableView的代理方法实现 数据源方法写在extension 中，提高代码的可读性 123456789101112131415161718// extension 想当于 OC中的categoryextension ViewController : UITableViewDelegate, UITableViewDataSource &#123; func numberOfSections(in tableView: UITableView) -&gt; Int &#123; return 1 &#125; func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return 5 &#125; //MARK: -数据源方法 func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; var cell = tableView.dequeueReusableCell(withIdentifier: "cell2") if cell==nil &#123; cell=UITableViewCell(style: .default, reuseIdentifier: "cell2") &#125; cell?.textLabel?.text = dataSoure[indexPath.row] return cell! &#125;&#125; 3.swift - TabBar 结构是tabBar 包括四个navigationController 123456789tabBar.tintColor=UIColor.orangeaddSelfChildViewController(childVC: BillListVC(), title: "账单", imageString: "home_tabbar_zd")addSelfChildViewController(childVC: StatementVC(), title: "报表", imageString: "home_tabbar_bb")addSelfChildViewController(childVC: InvoiceListVC(), title: "发票", imageString: "home_tabbar_fp")addSelfChildViewController(childVC: PartnerVC(), title: "伙伴", imageString: "home_tabbar_hb") 123456789101112131415private func addSelfChildViewController(childVC: UIViewController,title:String,imageString:String) &#123; childVC.tabBarItem.image=UIImage(named: imageString) childVC.tabBarItem.selectedImage=UIImage(named: imageString.appending("_h")) childVC.tabBarItem.title=title childVC.title=title; let nav = UINavigationController(rootViewController: childVC) addChildViewController(nav)&#125; 字符串用appdend ,拼接字符用+号 命名空间 可以被修改 12let nas = Bundle.main.infoDictionary! ["CFBundleExecutable"] as! String 从plist 获取json 进行解析。 从本地加载转化位nsdata, 使用JSONSeriralation 转化为数组，打印数组中的字典 contentsOfFile 方法是可选类型，调用 JSONSerialization.jsonObject 方法是需要强制解包， 打印 数组中的字典是时候，需要 声明数组中的数据类型 123456789101112131415let path = Bundle.main.path(forResource: "home.plist", ofType: nil)if let filePath = path&#123; do &#123; let data = NSData(contentsOfFile: filePath) let diarry:Any = try JSONSerialization.jsonObject(with: data! as Data, options: JSONSerialization.ReadingOptions.mutableContainers) for adic in diarry as! [[String:String]] &#123; print(adic) &#125; print(diarry) &#125; catch &#123; print("读取本地数据出现错误！") &#125;&#125; 4.swift-基类未登录界面 抽取基类，控制器作为子类 判断登录状态，如果登录就加载子类视图，如果没有登录加载未登录界面 设置自定义视图，流出接口方法，进行切换图片和文字 首页转盘图片动画 登录注册的代理方法 app的appearance tabbar,navigaitionBar 上代码 三目运算符 判断登录状态 12345let isHadLoggin :Bool = falselazy var nologvvv : NoLogView = NoLogView.shareNoLogView()override func loadView() &#123; isHadLoggin ? super.loadView(): setNoLogView()&#125; 根据控制器的不同，设置未登录页界面的图片和文字 123456789func setUpNologViewInfo(imageString:String,title:String)&#123; rotationView.isHidden=true iconImageView.image=UIImage(named: imageString) messageLable.text=title&#125; 设置首页转轮动画 1234567891011121314151617func addRotationAnimation()&#123; let animation = CABasicAnimation(keyPath: "transform.rotation.z") animation.fromValue = 0 animation.toValue = M_PI * 2 animation.repeatCount=MAXFLOAT animation.isRemovedOnCompletion = false animation.duration = 10 // 结束一次动画的时长 rotationView.layer.add(animation, forKey: "homeRotation")&#125; 设置代理 继承 NSObjectProtocol 设置代理属性 使用weak 关键字，可选类型 使用不用判断代理 直接使用 12345678protocol NoLogViewDelegate :NSObjectProtocol&#123; func registButtonWillClick() func logginButtonWillClick()&#125;weak var delegate:NoLogViewDelegate?delegate?.registButtonWillClick() 5.自定义转场动画 转场动画 需要两个VC，一个VC，弹出另外一个VC 需要一个Animator 工具类，遵守UIViewControllerTransitioningDelegate 负责处理动画，和告诉谁是处理展现的控制器 需要一个控制器，继承 UIPresentationController， 是Animator 工具类告诉代理，此控制器处理展现View 上代码 创建 HomePopOverAnimator， 12345678private lazy var homeAnimator : HomePopOverAnimator = HomePopOverAnimator()func changeAccoountBook()&#123; let vc = LeftChoseAccountBookVC() vc.modalPresentationStyle = .custom vc.transitioningDelegate = homeAnimator present(vc, animated: true, completion:nil)&#125; HomePopOverAnimator 处理 HomePopOverAnimator 遵守UIViewControllerTransitioningDelegate 协议，实现协议方法 在代理中创建负责展现view的HomeUIPresentationVC ，继承自UIPresentationController HomePopOverAnimator负责处理开始，结束动画，需要遵守UIViewControllerAnimatedTransitioning 协议 1234567891011121314151617181920212223// MARK:- 自定义转场代理的方法extension HomePopOverAnimator : UIViewControllerTransitioningDelegate &#123; // 告诉代理，谁是处理展示的VC public func presentationController(forPresented presented: UIViewController, presenting: UIViewController?, source: UIViewController) -&gt; UIPresentationController?&#123; let homePrentVC = HomeUIPresentationVC(presentedViewController: presented, presenting: presenting) return homePrentVC &#125; // 告诉代理，谁处理开始动画 public func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -&gt; UIViewControllerAnimatedTransitioning?&#123; isPresented = true return self &#125; // 告诉代理，谁处理结束动画 public func animationController(forDismissed dismissed: UIViewController) -&gt;UIViewControllerAnimatedTransitioning?&#123; isPresented = false return self &#125;&#125; UIViewControllerAnimatedTransitioning 代理 弹出和消失动画代理的方法，根据上下文处理动画形式 12345678910111213141516// MARK:- 弹出和消失动画代理的方法extension HomePopOverAnimator:UIViewControllerAnimatedTransitioning&#123; func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -&gt; TimeInterval&#123; return 1 &#125; func animateTransition(using transitionContext: UIViewControllerContextTransitioning)&#123; if isPresented &#123; animationForStartAnimation(ransitionContext: transitionContext) &#125;else&#123; animationForEndAnimation(ransitionContext: transitionContext) &#125; &#125;&#125; 私有方法，开始动画，结束动画，transition 动画 123456789101112131415161718192021222324252627// 开始动画private func animationForStartAnimation(ransitionContext: UIViewControllerContextTransitioning)&#123; // 获取view，将view加到contenterView上，执行动画 let containerView = ransitionContext.containerView let prentedView = ransitionContext.view(forKey: .to) containerView.addSubview(prentedView!) prentedView?.transform = CGAffineTransform.init(translationX: -containerView.bounds.size.width, y: 0) // prentedView?.layer.anchorPoint = CGPoint(x: 0.5, y: 0) UIView.animate(withDuration: transitionDuration(using: ransitionContext), animations: &#123; prentedView?.transform = CGAffineTransform.identity &#125;) &#123; (Bool) in ransitionContext.completeTransition(true) &#125;&#125;// 结束动画private func animationForEndAnimation(ransitionContext: UIViewControllerContextTransitioning)&#123; // 获取view， 执行消失动画 let containerView = ransitionContext.containerView let dismissView = ransitionContext.view(forKey: .from) UIView.animate(withDuration: transitionDuration(using: ransitionContext), animations: &#123; dismissView?.transform = CGAffineTransform.init(translationX: -containerView.bounds.size.width, y: 0) &#125;) &#123; (Bool) in dismissView?.removeFromSuperview() ransitionContext.completeTransition(true) &#125;&#125; HomeUIPresentationVC处理 负责显示的View ，左侧抽屉一半view，下面一层蒙版，能响应点击消失 设置需要展现视图的大小，设置遮盖为button，响应点击事件 12345678// 懒加载控件lazy var coverBGView :UIButton = UIButton()// 重写layoutsubviews 设置弹出视图的大小override func containerViewWillLayoutSubviews()&#123; super.containerViewWillLayoutSubviews() presentedView?.frame = CGRect(x: 0, y: 0, width: UIScreen.main.bounds.size.width*0.6, height: UIScreen.main.bounds.size.height) setCoverbgViews()&#125; 设置遮罩 frame和 响应方法 12345678910111213141516171819202122232425 extension HomeUIPresentationVC &#123; func setCoverbgViews()&#123; // 设置大小，插入到contenderView的最底层 coverBGView.titleLabel?.text="" coverBGView.frame = containerView!.bounds coverBGView.backgroundColor = UIColor.init(white: 0.8, alpha: 0.2) coverBGView.addTarget(self, action: #selector(tapCoverBgView), for: .touchUpInside) containerView?.insertSubview(coverBGView, at: 0) &#125; &#125; extension HomeUIPresentationVC &#123; @objc func tapCoverBgView(tap:UITapGestureRecognizer)&#123; presentedViewController.dismiss(animated: true, completion: nil) &#125; &#125; ``` #### 6.extension 使用类扩展增加方法- swift 中extension 相当于OC中的category 作为类的扩展- 单独创建文件做类的扩展- 在vc 中使用extension 作为 vc 的方法分类 苹果推荐 代理等方法写在extension里。- 上代码 command + N 创建Swift 文件，名字为UIBarBarItem+category- 为 UIBarButtonItem 增加一个类方法， 创建item 的titleLable extension UIBarButtonItem { class func titleLableWithText(title:String)-&gt;UILabel{ let lable = UILabel() lable.clipsToBounds = true lable.frame = CGRect(x: 0, y: 0, width: UIScreen.main.bounds.size.width*0.5, height: 30) lable.font = UIFont.systemFont(ofSize: 16) lable.textColor = UIColor.init(red: 51, green: 51, blue: 51, alpha: 1) lable.text = title return lable } } 123456789101112#### 7.创建二维码- 1.创建滤镜- 2.还原滤镜设置- 3.设置数据存入数据- 4.取出图片- 5.增加中间的头像- 6.设置高清图像&gt; 上代码 如下 - 1.2.3.4 步骤 //1.创建滤镜 let filer = CIFilter.init(name: “CIQRCodeGenerator”) // 2.还原滤镜的设置 filer?.setDefaults() // 3.设置数据 filer?.setValue(astring.data(using: .utf8), forKey: “inputMessage”) // 4.从滤镜中取出图片 CIImage let fileCiImage = filer?.outputImage 1- 增加中间的头像 UIGraphicsBegin // 开启图像上下文 UIGraphicsBeginImageContext(bgImage.size) // 绘制背景大小 bgImage.drawInRect(CGRect(origin: CGPointZero, size: bgImage.size)) // 绘制头像 let width:CGFloat = 50 let height:CGFloat = width let x = (bgImage.size.width - width) 0.5 let y = (bgImage.size.height - height) 0.5 iconImage.drawInRect(CGRect(x: x, y: y, width: width, height: height)) // 取出绘制好的图像 let newImage = UIGraphicsGetImageFromCurrentImageContext() // 关闭上下文 UIGraphicsEndImageContext() // 返回头像 return newImage 1- 绘制高清图像 /* 根据CIImage生成指定大小的高清UIImage :param: image 指定CIImage :param: size 指定大小 :returns: 生成好的图片 / private func createNonInterpolatedUIImageFormCIImage(image: CIImage, size: CGFloat) -&gt; UIImage { let extent: CGRect = CGRectIntegral(image.extent) let scale: CGFloat = min(size/CGRectGetWidth(extent), size/CGRectGetHeight(extent)) // 1.创建bitmap; let width = CGRectGetWidth(extent) * scale let height = CGRectGetHeight(extent) * scale let cs: CGColorSpaceRef = CGColorSpaceCreateDeviceGray()! let bitmapRef = CGBitmapContextCreate(nil, Int(width), Int(height), 8, 0, cs, 0)! let context = CIContext(options: nil) let bitmapImage: CGImageRef = context.createCGImage(image, fromRect: extent) CGContextSetInterpolationQuality(bitmapRef, CGInterpolationQuality.None) CGContextScaleCTM(bitmapRef, scale, scale); CGContextDrawImage(bitmapRef, extent, bitmapImage); // 2.保存bitmap到图片 let scaledImage: CGImageRef = CGBitmapContextCreateImage(bitmapRef)! return UIImage(CGImage: scaledImage) } ` 8.扫描二维码 懒加载会话，输入，输出 判断会话能不能添加输入输出 ， 会话添加输入输出 设置输出数据类型 设置输出对象代理 开始扫描 添加预览图层]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Swift学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift高级运算符-读书笔记]]></title>
    <url>%2F2016%2F09%2F20%2F2016b%2Fswift%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[1.高级运算符 位运算符，移位运算符 ，溢出加法运算符， 2.位运算法 按位 取反 运算符 ～ 按位 与 运算符 &amp; 按位 或 运算符 | 按位 异或 运算符 ^ 按位 左移，右移 运算符 &lt;&lt; 和 &gt;&gt; 取反 ～0b00001111 = 0b11110000 与 0b11111100 &amp; 0b00111111 = 00111100 或 0b10110010 | 0b01011110 = 11111110 异或 0b00010100 ^ 0b00000101 = 00010001 无符号左移右移 逻辑移位 无符号整数的移位运算 对无符号整数进行移位的规则如下： 已经存在的位按指定的位数进行左移和右移 任何因移动而超出整型存储范围的位都会被丢弃 用 0 来填充移位后产生的空白位 颜色值16进制CC6699 转为10进制RGB（204，102，153） 有符号的按位左移右移运算 算术移位 符号为0为正，1为负 它存储的值的绝对值等于 2 的 n 次方减去它的实际值（也就是数值位表示的值），这里的 n 为数值位的比特位数。一个 8 比特位的数有 7 个比特位是数值位，所以是 2 的 7 次方，即 128 对有符号整数的右移有一个额外的规则 当对整数进行按位右移运算时，遵循与无符号整数相同的规则，但是对于移位产生的空白位使用符号位进行填充，而不是用 0 3.溢出运算符 溢出加法（&amp;+）溢出减法（&amp;-），溢出乘法（&amp;*） UInt8.max &amp;+ 1 = 0 UInt8.min &amp;- 1 = 255 在对有符号整型数值进行溢出加法或溢出减法运算时，符号位也需要参与计算 Int8.min &amp;- 1 = 127（-128 - 1 = 127） 对于无符号与有符号整型数值来说，当出现上溢时，它们会从数值所能容纳的最大数变成最小的数。同样地，当发生下溢时，它们会从所能容纳的最小数变成最大的数。 4.运算符函数 类和结构体可以为现有的运算符实现自定义的实现，成为运算符重载 双目中缀运算符的自定义实现 对加号的重载 前缀和后缀运算符（-A）取反 复合运算符 （+= ） 等价运算符 （== ，!=） 5.自定义运算符，自定义优先级 “新的运算符要使用 operator 关键字在全局作用域内进行定义，同时还要指定 prefix、infix或者 postfix 修饰符： +++ 实现，自增的正值 优先级]]></content>
      <categories>
        <category>实用技术</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>实用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift语法-读书笔记]]></title>
    <url>%2F2016%2F09%2F20%2F2016b%2Fswift%E8%AF%AD%E6%B3%95-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1.字符串语法 字符串的转移 类型转换运算符 字面量表达式 2.语句 guard defer 语句 #if endif 下标声明 运算符声明 infix operator 优先级声明 声明修饰符 3.特性 available iOS，iOSApplicationExtension —- @available(iOS 10.0, macOS 10.12, *) unavailable 在指定的平台上无效的 introduced = 版本号 deprecated = 版本号 obsoleted = 版本号 renamed = 新名字 discardableResult 抑制编译器中 函数或方法的返回值被调而没有使用其结果的警告 GKInspectable 暴露一个自定义GameplayKit组件属性给SpriteKit编辑器UI objc NSApplicationMain NSCopying NSManaged testable UIApplicationMain autoclosure escaping convention 4.权限 下面的代码表示把变量UUID的赋值权限设为private，对整个app可读，但值只能在本文件里写入 5.值类型和引用类型 值类型：枚举，结构体，元组 引用类型：类 值类型复制，是全部复制；引用类型复制是指针复制，其实是同一个数据。]]></content>
      <categories>
        <category>实用技术</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>实用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记网站]]></title>
    <url>%2F2016%2F09%2F06%2F2016b%2F%E7%AC%94%E8%AE%B0%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[技术路线： Java学习路线图 人工智能+Python学习路线图 前端与移动开发学习路线图 H5+全栈工程师学习路线图 产品经理学习路线图 云计算大数据学习路线图1.IT社区: 推荐 http://www.cnblogs.com/ http://www.csdn.net/ http://www.51cto.com/ http://www.cocoachina.com/ http://www.techcn.com.cn/ http://mobilehub.io/ 2.iOS 学习网站: iOS 学习网站 http://www.w3school.com.cn/ http://objccn.io/ http://github.ibireme.com/github/list/ios/ github上ios第三方库集合 可以多看看 https://github.com/chasseurmic/TWRProgressView Swift学习 https://github.com/CocoaChina-editors/Welcome-to-Swift https://github.com/numbbbbb/the-swift-programming-language-in-chinese http://www.infoq.com/cn 软件开发领域:此网站里面有很多文章都是翻译国外的 里面有一些架构设计的文章很不错 http://www.cnblogs.com/wendingding/ 传智学员记录了学习ios 安全: http://blog.csdn.net/yiyaaixuexi 好像是一位妹子好牛逼 http://nianxi.net/ 她的新博客不过现在内容比较少 http://bbs.pediy.com/ 开雪学院 国内重量级 数据结构与算法 http://blog.csdn.net/v_july_v http://blog.csdn.net/itcastcpp?viewmode=contents C++学院院长 尹成 blog: http://blog.devtang.com/ 唐巧 曾开发网易微博后台\ iOS:曾开发过 有道云笔记\粉笔网\猿题库 http://onevcat.com/ 王巍 就职Line 技术领域: ios+Unity3d http://beyondvincent.com/blog/archives/ http://esoftmobile.com/ http://blog.csdn.net/tonny_guan?viewmode=contents http://blog.csdn.net/opengl_es 游戏开发: http://blog.codingnow.com/ 吴云洋( 云风) 很牛逼 网易研究中心总监 http://www.gameres.com/ 非常不错的一个 游戏资讯门户 http://game.ceeger.com/forum/ Unity3D 学习论坛 开源网站: https://github.com/ http://code4app.com/ http://code.cocoachina.com/ 推荐书籍: 现代操作系统 iOS与OS X多线程和内存管理 Effective Objective-C 2.0：编写高质量iOS与OS X代码的52个有效方法 Objective-C编程之道：iOS设计模式解析 iOS应用逆向工程：分析与实战 重构：改善既有代码的设计 鸟哥的Linux私房菜 3.学习资源 一个非常强大的mac retina高清壁纸网站 http://wallpaperswide.com Quartz2D使用 http://www.cnblogs.com/wendingding/p/3778940.html Quartz2D简单介绍 Quartz2D简单使用（一） Quartz2D简单使用(二) Quartz2D简单使用（三） iOS开发UI篇—Quartz2D使用（绘制基本图形） Quartz2D(自定义UIImageView控件) Quartz2D使用（截屏） Quartz2D使用(信纸条纹) Quartz2D使用（绘图路径） Quartz2D使用（图片剪切） Quartz2D使用（矩阵操作） Quartz2D使用（图形上下文栈） 李明杰浅谈逆向 https://pan.baidu.com/s/1kVn1Nc7#list/path=%2F 密码: hq19 自动化测试视频讲解 https://pan.baidu.com/s/1boQb6cZ#list/path=%2F 揭秘微博、微信刷fen平台内幕与实战吸粉 https://pan.baidu.com/s/1i5PzDpb#list/path=%2F 密码: cgj6 求职心态篇 https://pan.baidu.com/s/1nvC02ZB#list/path=%2F 密码: wz8a vue.js腾讯课堂百度云链接： https://pan.baidu.com/s/1nvPXGpj#list/path=%2F 密码: v2vw 带你玩转github https://pan.baidu.com/s/1mi4uMhU#list/path=%2F 密码: yg1t 微信朋友圈开发视频：（转给你需要的朋友） https://pan.baidu.com/s/1cKUb9c#list/path=%2F 即时通常融云讲解视频： https://pan.baidu.com/s/1eRDehUi#list/path=%2F swiift项目实战视频： https://pan.baidu.com/s/1c1YgVoG#list/path=%2F iOS面试官面试上百个iOS感受以及面试技巧 https://pan.baidu.com/s/1eSqtFlo#list/path=%2F-1000套求职简历模板： https://pan.baidu.com/s/1jIHVLK6#list/path=%2F lldb调试bug高级用法 https://pan.baidu.com/s/1o89Gb82#list/path=%2F 支付宝生活圈开发视频：（仅限学习使用） https://pan.baidu.com/s/1nuZPSiH#list/path=%2F 4.GitHub网址 https://github.com/lihongli528628/HLBookReader 电子书+语音阅读 https://github.com/GGGHub/Reader 电子书源码 https://github.com/Aufree/trip-to-iOS iOS学习资料列表，开源框架前100， https://github.com/nicklockwood/iCarousel 动画 轮播动画，反转的类似 https://github.com/zwaldowski/BlocksKit 改变系统的target+selector模式为 block模式。 带来紧凑的代码风格，高效率的回调执行 objc.io Swift Apprentice objectManager 5.博客 iOS Provisioning Profile(Certificate)与Code Signing详解 基于 CoreText 的排版引擎：基础 iOS开发之网络编程篇六：AFNetworking3.0使用简介 RTImageAssets：自动生成全尺寸icon以及2x/3x图片 网易滚动导航栏——（第三方框架实现） HACursor AMScrollingNavbar框架(自动隐藏导航栏)使用简介 3D Touch 使用：Quick Action（Short Cut） 3D Touch 使用：Peek 和 Pop 系统自带的iOS扫描二维码 AVMetadataObjec 友盟消息推送SDK集成 NSScanner类的基本用法 6.技巧网址 iOS/mac开发的一些知名个人博客 http://www.cocoachina.com/bbs/read.php?tid=299721 Windows 8.1正式版官方专业版原版iso镜像系统下载 http://www.wingod8.com/a/yuanbanxitong/win8/466.html 程序员如何优雅地使用 Mac？ http://www.zhihu.com/question/20873070 ios开发学习笔记 http://blog.csdn.net/mad1989/article/details/7972612 苹果6Mac软件下载网址 http://www.pc6.com/mac/ 少数派 https://sspai.com/post/33493 Xcode插件优缺点对比（推荐20款插件） http://www.cnblogs.com/dsxniubility/p/5099191.html CocoaChina 代码分类 ://code.cocoachina.com/ code4App 7.分享网址 仿新浪微博表情键盘 HMEmoticon https://github.com/itheima-developer/HMEmoticon 轻量级的上拉／下拉刷新控件 https://github.com/itheima-developer/HMRefresh 轻量级图像选择框架 https://github.com/itheima-developer/HMImagePicker Objective-C 语法糖 https://github.com/itheima-developer/HMObjcSugar 轻量级图片浏览器 https://github.com/itheima-developer/HMPhotoBrowser swift二维码 https://github.com/liufan321/SwiftQRCode FFlable https://github.com/liufan321/FFLabel]]></content>
      <categories>
        <category>实用技术</category>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>实用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NSPropertyListSerialization 持久化字典与数组]]></title>
    <url>%2F2016%2F06%2F19%2F2016b%2FNSPropertyListSerialization%20%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%97%E5%85%B8%E4%B8%8E%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[NSPropertyListSerialization 持久化字典与数组 使用 封装细节 设置存储路径，方法1：根据字典路径存储 方法2： 根据路径返回字典，修改后存储 .m文件实现]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>实用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后台上传300张图片]]></title>
    <url>%2F2016%2F06%2F18%2F2016b%2F%E5%90%8E%E5%8F%B0%E4%B8%8A%E4%BC%A0300%E5%BC%A0%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[后台上传300张图片 监听进入后台通知，执行后台方法。结束任务时结束后台任务task 参考简书： http://www.jianshu.com/p/9bf161a14725 、 锁屏 或者进入后台能继续上传 监听通知： 设置后台任务，设置自己的任务，完成时结束任务写在block里面 执行耗时操作，如果所有的都上传完，就执行completionBlock(); 执行上面的代码，结束任务]]></content>
      <categories>
        <category>实用技术</category>
        <category>开发问题</category>
      </categories>
      <tags>
        <tag>实用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新浪微博分享不跳转]]></title>
    <url>%2F2016%2F06%2F18%2F2016b%2F%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A%E5%88%86%E4%BA%AB%E4%B8%8D%E8%B7%B3%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[实际开发中遇到第三方分享分享微博不能跳转 1.在info.plist 中，设置白名单，少设置了后面2个，加上之后正常跳转 2.新浪微博和其他分享不一样，只能分享图片和文字， 3.将网址和文字拼接在一块，在微信上显示网址，在微博上只显示链接，]]></content>
      <categories>
        <category>实用技术</category>
        <category>开发问题</category>
      </categories>
      <tags>
        <tag>实用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS关于启动页自定义特殊处理 启动广告]]></title>
    <url>%2F2016%2F06%2F17%2F2016b%2FiOS%E5%85%B3%E4%BA%8E%E5%90%AF%E5%8A%A8%E9%A1%B5%E8%87%AA%E5%AE%9A%E4%B9%89%E7%89%B9%E6%AE%8A%E5%A4%84%E7%90%86%20%E5%90%AF%E5%8A%A8%E5%B9%BF%E5%91%8A%2F</url>
    <content type="text"><![CDATA[其实原理也是很简单，启动页还是运用Launch Images Source的内容，然后在做一个视图在最上层，视图的背景用启动项的那张图，让人误以为还在启动中，启动页加载完成后，就显示这层视图，在2秒后再把这层视图删除，产生一个过度的假启动页效果；而我们自定义的动作就可以在这层视图上进行；下面将通过Coding.net的APP讲解这个功能 一：创建一个视图EaseStartView EaseStartView.h文件内容： 12345#import &lt;UIKit/UIKit.h&gt;@interface EaseStartView : UIView+ (instancetype)startView;- (void)startAnimationWithCompletionBlock:(void(^)(EaseStartView *easeStartView))completionHandler;@end EaseStartView.m文件内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#import "EaseStartView.h"#import &lt;NYXImagesKit/NYXImagesKit.h&gt;#import "StartImagesManager.h"@interface EaseStartView ()@property (strong, nonatomic) UIImageView *bgImageView, *logoIconView;@property (strong, nonatomic) UILabel *descriptionStrLabel;@end@implementation EaseStartView+ (instancetype)startView&#123; UIImage *logoIcon = [UIImage imageNamed:@"logo_coding_top"]; StartImage *st = [[StartImagesManager shareManager] randomImage]; return [[self alloc] initWithBgImage:st.image logoIcon:logoIcon descriptionStr:st.descriptionStr];&#125;- (instancetype)initWithBgImage:(UIImage *)bgImage logoIcon:(UIImage *)logoIcon descriptionStr:(NSString *)descriptionStr&#123; self = [super initWithFrame:kScreen_Bounds]; if (self) &#123; //add custom code UIColor *blackColor = [UIColor blackColor]; self.backgroundColor = blackColor; _bgImageView = [[UIImageView alloc] initWithFrame:kScreen_Bounds]; _bgImageView.contentMode = UIViewContentModeScaleAspectFill; _bgImageView.alpha = 0.0; [self addSubview:_bgImageView]; [self addGradientLayerWithColors:@[(id)[blackColor colorWithAlphaComponent:0.4].CGColor, (id)[blackColor colorWithAlphaComponent:0.0].CGColor] locations:nil startPoint:CGPointMake(0.5, 0.0) endPoint:CGPointMake(0.5, 0.4)]; _logoIconView = [[UIImageView alloc] init]; _logoIconView.contentMode = UIViewContentModeScaleAspectFit; [self addSubview:_logoIconView]; _descriptionStrLabel = [[UILabel alloc] init]; _descriptionStrLabel.font = [UIFont systemFontOfSize:10]; _descriptionStrLabel.textColor = [UIColor colorWithWhite:1.0 alpha:0.5]; _descriptionStrLabel.textAlignment = NSTextAlignmentCenter; _descriptionStrLabel.alpha = 0.0; [self addSubview:_descriptionStrLabel]; [_descriptionStrLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.centerX.equalTo(@[self, _logoIconView]); make.height.mas_equalTo(10); make.bottom.equalTo(self.mas_bottom).offset(-15); make.left.equalTo(self.mas_left).offset(20); make.right.equalTo(self.mas_right).offset(-20); &#125;]; [_logoIconView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.centerX.equalTo(self); make.top.mas_equalTo(kScreen_Height/7); make.width.mas_equalTo(kScreen_Width *2/3); make.height.mas_equalTo(kScreen_Width/4 *2/3); &#125;]; [self configWithBgImage:bgImage logoIcon:logoIcon descriptionStr:descriptionStr]; &#125; return self;&#125; 1234567- (void)configWithBgImage:(UIImage *)bgImage logoIcon:(UIImage *)logoIcon descriptionStr:(NSString *)descriptionStr&#123;bgImage = [bgImage scaleToSize:[_bgImageView doubleSizeOfFrame] usingMode:NYXResizeModeAspectFill];self.bgImageView.image = bgImage;self.logoIconView.image = logoIcon;self.descriptionStrLabel.text = descriptionStr;[self updateConstraintsIfNeeded];&#125; 1234567891011121314151617181920212223242526- (void)startAnimationWithCompletionBlock:(void(^)(EaseStartView *easeStartView))completionHandler&#123; [[UIApplication sharedApplication].keyWindowaddSubview:self]; [[UIApplication sharedApplication].keyWindowbringSubviewToFront:self]; _bgImageView.alpha = 0.0; _descriptionStrLabel.alpha = 0.0; @weakify(self); [UIView animateWithDuration:2.0 animations:^&#123; @strongify(self); self.bgImageView.alpha = 1.0; self.descriptionStrLabel.alpha = 1.0; &#125; completion:^(BOOL finished) &#123; [UIView animateWithDuration:0.6 delay:0.3 options:UIViewAnimationOptionCurveEaseIn animations:^&#123; @strongify(self); [self setX:-kScreen_Width]; &#125; completion:^(BOOL finished) &#123; @strongify(self); [self removeFromSuperview]; if (completionHandler) &#123; completionHandler(self); &#125; &#125;]; &#125;];&#125;@end 其实本实例中最为关键的内容在方法startAnimationWithCompletionBlock里 12[[UIApplication sharedApplication].keyWindow addSubview:self];[[UIApplication sharedApplication].keyWindow bringSubviewToFront:self]; 代码就是把这个视图设置成在最前的最上层，这样就可以盖住程序中的页面； 123456789101112131415161718192021_bgImageView.alpha = 0.0;_descriptionStrLabel.alpha = 0.0;这个是为了下面的动画做准备，若是直接用背景图可以把这两个都设置成0.99这样就不会有一闪的错觉；@weakify(self);[UIView animateWithDuration:2.0 animations:^&#123; @strongify(self); self.bgImageView.alpha = 1.0; self.descriptionStrLabel.alpha = 1.0;&#125; completion:^(BOOL finished) &#123; [UIView animateWithDuration:0.6 delay:0.3 options:UIViewAnimationOptionCurveEaseIn animations:^&#123; @strongify(self); [self setX:-kScreen_Width]; &#125; completion:^(BOOL finished) &#123; @strongify(self); [self removeFromSuperview]; if (completionHandler) &#123; completionHandler(self); &#125; &#125;];&#125;]; 这边是动画效果，时间设置为2秒，因为这边第一个动画完还有一个缩放的效果；当动画结束后就可以 [self removeFromSuperview]; 二：调用启动页视图 在AppDelegate中的didFinishLaunchingWithOptions进行调用； 1234567891011121314151617181920212223242526272829303132- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];// Override point for customization after application launch.self.window.backgroundColor = [UIColor whiteColor];//网络[[AFNetworkActivityIndicatorManager sharedManager] setEnabled:YES];[[AFNetworkReachabilityManager sharedManager] startMonitoring];//设置导航条样式[self customizeInterface];[[UIApplication sharedApplication] setStatusBarHidden:NO withAnimation:UIStatusBarAnimationFade];if ([Login isLogin]) &#123; [self setupTabViewController];&#125;else&#123; [UIApplication sharedApplication].applicationIconBadgeNumber = 0; [self setupIntroductionViewController];&#125;[self.window makeKeyAndVisible];[FunctionIntroManager showIntroPage];EaseStartView *startView = [EaseStartView startView];@weakify(self);[startView startAnimationWithCompletionBlock:^(EaseStartView *easeStartView) &#123; @strongify(self); //可以做其它事情&#125;];return YES;&#125; 注意，EaseStartView代码的位置是要放在最后面，因为要让它盖在最上层，就要后面加载，这样就可以盖在登录页面上面或者主页上；到这就已经可以成功启动页的效果； 三：下面实例为项目中用到的动态加载版本号到启动页上123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#import "StartUpView.h"@interface StartUpView()@property (strong, nonatomic) UIImageView *bgImageView;@property (strong, nonatomic) UILabel *descriptionStrLabel;@end@implementation StartUpView+ (instancetype)startView &#123; UIImage *bgImage=kshamLaunchImage; return [[self alloc] initWithBgImage:bgImage];&#125;- (instancetype)initWithBgImage:(UIImage *)bgImage&#123; self = [super initWithFrame:Main_Screen_Bounds]; if (self) &#123; _bgImageView = [[UIImageView alloc] initWithFrame:Main_Screen_Bounds]; _bgImageView.contentMode = UIViewContentModeScaleAspectFill; _bgImageView.alpha = 0; _bgImageView.image=bgImage; [self addSubview:_bgImageView]; _descriptionStrLabel = [[UILabel alloc] init]; _descriptionStrLabel.font = [UIFont systemFontOfSize:15]; _descriptionStrLabel.textColor = [UIColor blackColor]; _descriptionStrLabel.textAlignment = NSTextAlignmentCenter; _descriptionStrLabel.alpha = 0; _descriptionStrLabel.text=[NSString stringWithFormat:@"版本号为:%@",appVersion]; [self addSubview:_descriptionStrLabel]; [_descriptionStrLabel mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.height.mas_equalTo(50); make.bottom.equalTo(self.mas_bottom).offset(-15); make.left.equalTo(self.mas_left).offset(20); make.right.equalTo(self.mas_right).offset(-20); &#125;]; &#125; return self;&#125;- (void)startAnimationWithCompletionBlock:(void(^)(StartUpView *easeStartView))completionHandler&#123; [[UIApplication sharedApplication].keyWindow addSubview:self]; [[UIApplication sharedApplication].keyWindow bringSubviewToFront:self]; _bgImageView.alpha = 0.99; _descriptionStrLabel.alpha = 0.99; @weakify(self); [UIView animateWithDuration:2.0 animations:^&#123; @strongify(self); self.bgImageView.alpha = 1.0; self.descriptionStrLabel.alpha = 1.0; &#125; completion:^(BOOL finished) &#123; [self removeFromSuperview]; if (completionHandler) &#123; completionHandler(self); &#125; &#125;];&#125;@end]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>实用</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新特性界面]]></title>
    <url>%2F2016%2F06%2F16%2F2016b%2F%E6%96%B0%E7%89%B9%E6%80%A7%E7%95%8C%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[使用collectionView UIcollectionViewlayout 自定义prepared 调用顺序，1.count，2.准备布局，3.返回cell 重写init 方法，设置外部参数照片的数组， 一个文件中可以创建多个class ，创建类flowLyout. newFertureCell NewfeatureLayout 中prepareLayout() 方法 设置layout的参数，和collectionView的参数 什么时候调用? 1.先调用一个有多少行cell 2.调用准备布局 3.调用返回cell 1234567891011121314151617181920212223override func prepareLayout() &#123;// 1.设置layout布局itemSize = UIScreen.mainScreen().bounds.sizeminimumInteritemSpacing = 0minimumLineSpacing = 0scrollDirection = UICollectionViewScrollDirection.Horizontal// 2.设置collectionView的属性collectionView?.showsHorizontalScrollIndicator = falsecollectionView?.bounces = falsecollectionView?.pagingEnabled = true &#125; cell 中设置button 显示的动画，设置button的点击发送通知 设置 transform 动画，完成之后 transform 设置 CGAffineTransform.identity ，归位初始值 usingSpringWithDamping 为（0-1）， 数值越小，弹力越大 initialSpringVelocity 速度 5,10,15 1234567891011121314151617181920// button的动画func buttonStartAnimation()&#123; cellButton.isHidden = false cellButton.transform = CGAffineTransform(scaleX: 0, y: 0); cellButton.isUserInteractionEnabled = false UIView.animate(withDuration: 2, delay: 0, usingSpringWithDamping: 0.8, initialSpringVelocity: 10, options: UIViewAnimationOptions.init(rawValue: 0), animations: &#123; self.cellButton.transform = CGAffineTransform.identity &#125;) &#123; (_) in self.cellButton.isUserInteractionEnabled = true &#125;&#125; swift 3.0 之发送通知 创建一个swift文件，存储常量， 通知变化为 NSNotification.Name(rawValue:””） 123456789// 发送通知let SwitchRootVCNotification = NSNotification.Name(rawValue:"SwitchRootViewControllerKey")NotificationCenter.default.post(name:SwitchRootVCNotification, object: nil)// 接收通知NotificationCenter.default.addObserver(self, selector: #selector(changeRoot), name: SwitchRootVCNotification, object: nil)]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>实用</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FRDLiveLyButton]]></title>
    <url>%2F2016%2F05%2F05%2F2016b%2FFRDLiveLyButton%2F</url>
    <content type="text"><![CDATA[1.FRDLiveLyButton 使用FRDLiveLyButton 有动画的button，FRDLiveLyButton 实用方法 1.设置style 2: setOptions方法，设置外观 2.基于FMDB的keyValue 唐巧基于FMDB的keyValue模式存储，value是json格式活着是字典数组模型可以考虑存储 3.LazyFadeInView 说明LazyFadeInView 非常酷，以一种动画的形式来显示一个label。 使用LazyFadeInView，创建一个LazyFadeInView，然后添加到你的view中。它会自动的用动画的形式显示出来。 代码 1234LazyFadeInView *fadeInView = [[LazyFadeInView alloc] initWithFrame:CGRectMake(20, 120, 280, 200)];self.fadeInView.text = @"Stray birds of summer come to my window to sing and fly away.";self.fadeInView.textColor = [UIColor whiteColor];[self.view addSubview:self.fadeInView]; 4.YLGIFImage 异步加载GIF图片的类，支持GIF图片的播放与暂停。 它用的内存很少，完全解码GIF通常会消耗600MB的内存（800x600x389x4 Bytes），但是如果你用了YLGIFImage，它只占用30MB内存。 上面这张GIF图片。iOS加载时会直接崩溃，而使用了YLGIFImage，那就不会。 123YLImageView* imageView = [[YLImageView alloc] initWithFrame:CGRectMake(0, 160, 320, 240)];[self.view addSubview:imageView];imageView.image = [YLGIFImage imageNamed:@"joy.gif"]; 5.SDCycleScrollView 轮播图的使用 SDCycleScrollView 轮播图的使用： 初始化的方法，给定位置，何数据源，图片网址 若是顶部出现空白区域：设置 self.automaticallyAdjustsScrollViewInsets = NO pagecontrol的小圆点自定义接口改为：currentPageDotColor、pageDotColor、currentPageDotImage、pageDotImage 设置定义的标题，代理，时间间隔 12345// 网络加载图片的轮播器 SDCycleScrollView *cycleScrollView = [cycleScrollViewWithFrame:frame delegate:delegate placeholderImage:placeholderImage]; cycleScrollView.imageURLStringsGroup = imagesURLStrings; // 本地加载图片的轮播器 SDCycleScrollView *cycleScrollView = [SDCycleScrollView cycleScrollViewWithFrame: imagesGroup:图片数组]; 12345678// 设置pageControl居右，默认居中cycleScrollView.pageControlAliment = SDCycleScrollViewPageContolAlimentRight; // 如果设置title数组，则会在图片下面添加标题cycleScrollView.titlesGroup = 标题数组（数组元素个数必须和图片数组元素个数保持一致）; // 如需监听图片点击，请设置代理，实现代理方法cycleScrollView.delegate = ;// 自定义轮播时间间隔cycleScrollView.autoScrollTimeInterval = ;]]></content>
      <categories>
        <category>UI</category>
      </categories>
      <tags>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用cocoapods中遇到的问题]]></title>
    <url>%2F2016%2F03%2F21%2F2016b%2F%E4%BD%BF%E7%94%A8cocoapods%2F</url>
    <content type="text"><![CDATA[1.使用cocoapods 使用时需要新建一个名为 Podfile 的文件，以如下格式，将依赖的库名字依次列在 文件中即可 然后你将编辑好的 Podfile 文件放到你的项目根目录中，执行如下命令即可： 现在，你的所有第三方库都已经下载完成并且设置好了编译参数和依赖，你只需要记住如下 2 点即可： 使用 CocoaPods 生成的 .xcworkspace 文件来打开工程，而不是以前的 .xcodeproj 文件。 每次更改了 Podfile 文件，你需要重新执行一次pod update命令。 进行搜索第三方框架的时候，终端命令输入 pod search json 找到做多版本更新最多的，粘贴复制到podfile文件中，这个文件在项目的根目录下，一个项目使用一个podfile， 2.使用pod时 pod search 第三方框架 复制 版本更新最多的，将podfile 文件复制到项目跟路径下，修改podfile文件内容， 保存， 执行pod install命令，执行成功之后，是已经加入到workspace中。 3.使用第三方有cocoapods时，进行pod update: 用这时候，打开终端，进入UAAppReviewManagerExample所在的目录，也就是和Podfile在同一目录下，和场景1一样，输入以下命令（由于已经有Podfile，所以不需要再创建Podfile）： 下载的第三方中间有podfile和podlock,直接切换到根目录下进行更新。 $ pod update pod setup 等待时间过上 从GitHub上下载文件，下载，详情请看Alamofire4.4.0 安装 或替换下载源 123pod repo remove masterpod repo add master https://gitcafe.com/akuandev/Specs.gitpod repo update 4.问题： cocoapoadss的出现问题，pod Install 也不行， 1build diff: /../Podfile.lock: No such file or directory 开始的时候用pod install/update各种都没有用。后来试了这种方法，重新build就ok。 在工程设置中的Build Phases下删除Check Pods Manifest.lock及Copy Pods Resources 5.删除cocoapads 删除下载资源库 直接删除改行就行 cd到当前项目目录下，重新执行pod install命令 123451.打开Podfile文件，删除JSONKit该行，即：platform:ios, '7.0' pod 'AFNetworking', '~&gt; 2.1.0'pod 'JSONKit', '~&gt; 1.5pre'（删除该行）pod 'MBProgressHUD', '~&gt; 0.8' 删除整个cocoapods 删除工程文件夹下的Podfile、Podfile.lock和Pods文件夹 删除xcworkspace文件。 打开xcodeproj文件，删除项目中的libpods.a和Pods.xcconfig引用： 打开Build Phases选项，删除Check Pods Manifest.lock和Copy Pods Resources 6.cocoaPods - Alamofire4.4.0 安装cocoaPods 开始： -&gt; 打开Terminal 移走原有的ruby源 1gem sources -remove https://rubygems.org/ 指定添加国内最新镜像源 gem sources -a https://gems.ruby-china.org/ 查看结果 gem sources -l 检查更新ruby环境 sudo gem update --system 最新安装cocoapods的路径 sudo gem install -n /usr/local/bin cocoapods 直接敲 pod setup 检查是否安装成功 cd 项目目录下 cd ~/Path/To/Folder/Containing/IceCreamShop 创建podFile 12pod initopen -a Xcode Podfile 编辑podFile 123456*#* Uncomment this line to define a global platform for your project*#* platform :ios, '6.0' target 'IceCreamShop' do end target 'IceCreamShopTests' do end 将注释的内容替换成下面的两行： 12platform :ios, "8.0"use_frameworks! pod install 完成 有坑 pod install 中由于网络原因下载不动 最终解决方案：在GitHub上找到Specs 后fork到自己的工程,然后使用工具GitHub Desktop工具把Specs下载下来，更名成master ，替换路径~/.cocoapods/repos目录下的master。就可以正常使用了 master 中.git .gitignore 是隐藏文件，直接覆盖的话会出错 7.cocoaPods - Alamofire4.4.0]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>cocoapods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KVC/KVO的内部实现]]></title>
    <url>%2F2016%2F03%2F11%2F2016b%2FKVC%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[KVC的内部实现 KVC运用了isa-swizzing技术。isa-swizzing就是类型混合指针机制。KVC通过isa-swizzing实现其内部查找定位。 isa指针（is kind of 的意思）指向维护分发表的对象的类，该分发表实际上包含了指向实现类中的方法的指针和其他数据。 12345 [site setValue:@"sitename" forKey:@"name"]//会被编译器处理成SEL sel = sel_get_uid(setValue:forKey);IMP method = objc_msg_loopup(site-&gt;isa,sel);method(site,sel,@"sitename",@"name"); 每个类都有一张方法表，是一个hash表，值是还书指针IMP，SEL的名称就是查表时所用的键。 SEL数据类型：查找方法表时所用的键。定义成char*，实质上可以理解成int值。 IMP数据类型：他其实就是一个编译器内部实现时候的函数指针。当Objective-C编译器去处理实现一个方法的时候，就会指向一个IMP对象，这个对象是C语言表述的类型。 KVC的内部机制： 一个对象在调用setValue的时候进行了如下操作： 根据方法名找到运行方法的时候需要的环境参数 他会从自己的isa指针结合环境参数，找到具体的方法实现接口。 再直接查找得来的具体的实现方法 KVO概述 键值观察Key-Value-Observer就是观察者模式。 观察者模式的定义：一个目标对象管理所有依赖于它的观察者对象，并在它自身的状态改变时主动通知观察者对象。这个主动通知通常是通过调用各观察者对象所提供的接口方法来实现的。观察者模式较完美地将目标对象与观察者对象解耦。当需要检测其他类的属性值变化，但又不想被观察的类知道，有点像FBI监视嫌疑人，这个时候就可以使用KVO了。 KVO同KVC一样都依赖于Runtime的动态机制 注册： 1 -(void)addobserver:(nsobject*)anobserer forkeypath:(nsstrig*)keypath options:(nskeyValueObservingOptions)options context:(void*)context&#123;&#125; 实现方法： ofOject:(id)object change:(nsdictionary*)change context:(void*)context ```12- 移除：``` －(void)removeObsever:(nsobject)observer forkeypath:(nsnsting*)keypath; KVO实现步骤12345678910111213141516 注册//keyPath就是要观察的属性值//options给你观察键值变化的选择//context方便传输你需要的数据-(void)addObserver:(NSObject *)anObserver forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(void *)context 实现方法//change里存储了一些变化的数据，比如变化前的数据，变化后的数据；如果注册时context不为空，这里context就能接收到。-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context 移除- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath; 系统实现KVO有以下几个步骤： 当类A的对象第一次被观察的时候，系统会在运行期动态创建类A的派生类。我们称为B。 在派生类B中重写类A的setter方法，B类在被重写的setter方法中实现通知机制。类B重写会 class方法，将自己伪装成类A。类B还会重写dealloc方法释放资源。 系统将所有指向类A对象的isa指针指向类B的对象。 KVO同KVC一样，通过 isa-swizzling 技术来实现。当观察者被注册为一个对象的属性的观察对象的isa指针被修改，指向一个中间类，而不是在真实的类。其结果是，isa指针的值并不一定反映实例的实际类。 所以不能依靠isa指针来确定对象是否是一个类的成员。应该使用class方法来确定对象实例的类。]]></content>
      <categories>
        <category>实用技术</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>KVC/KVO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修正iOS从照相机和相册中获取的图片方向]]></title>
    <url>%2F2016%2F03%2F11%2F2016b%2F%E4%BF%AE%E6%AD%A3iOS%E4%BB%8E%E7%85%A7%E7%9B%B8%E6%9C%BA%E5%92%8C%E7%9B%B8%E5%86%8C%E4%B8%AD%E8%8E%B7%E5%8F%96%E7%9A%84%E5%9B%BE%E7%89%87%E6%96%B9%E5%90%91%2F</url>
    <content type="text"><![CDATA[使用系统相机拍照得到的图片的默认方向有时不是ImageOrientationDown，而是ImageOrientationLeft，在使用的时候会出现图片顺时针偏转90°。使用fixOrientation方法修正这个问题。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576- (UIImage *)fixOrientation&#123; // No-op if the orientation is already correct if (self.imageOrientation == UIImageOrientationUp) return self; // We need to calculate the proper transformation to make the image upright. // We do it in 2 steps: Rotate if Left/Right/Down, and then flip if Mirrored. CGAffineTransform transform = CGAffineTransformIdentity; switch (self.imageOrientation) &#123; case UIImageOrientationDown: case UIImageOrientationDownMirrored: transform = CGAffineTransformTranslate(transform, self.size.width, self.size.height); transform = CGAffineTransformRotate(transform, M_PI); break; case UIImageOrientationLeft: case UIImageOrientationLeftMirrored: transform = CGAffineTransformTranslate(transform, self.size.width, 0); transform = CGAffineTransformRotate(transform, M_PI_2); break; case UIImageOrientationRight: case UIImageOrientationRightMirrored: transform = CGAffineTransformTranslate(transform, 0, self.size.height); transform = CGAffineTransformRotate(transform, -M_PI_2); break; default: break; &#125; switch (self.imageOrientation) &#123; case UIImageOrientationUpMirrored: case UIImageOrientationDownMirrored: transform = CGAffineTransformTranslate(transform, self.size.width, 0); transform = CGAffineTransformScale(transform, -1, 1); break; case UIImageOrientationLeftMirrored: case UIImageOrientationRightMirrored: transform = CGAffineTransformTranslate(transform, self.size.height, 0); transform = CGAffineTransformScale(transform, -1, 1); break; default: break; &#125; // Now we draw the underlying CGImage into a new context, applying the transform // calculated above. CGContextRef ctx = CGBitmapContextCreate(NULL, self.size.width, self.size.height, CGImageGetBitsPerComponent(self.CGImage), 0, CGImageGetColorSpace(self.CGImage), CGImageGetBitmapInfo(self.CGImage)); CGContextConcatCTM(ctx, transform); switch (self.imageOrientation) &#123; case UIImageOrientationLeft: case UIImageOrientationLeftMirrored: case UIImageOrientationRight: case UIImageOrientationRightMirrored: // Grr... CGContextDrawImage(ctx, CGRectMake(0,0,self.size.height,self.size.width), self.CGImage); break; default: CGContextDrawImage(ctx, CGRectMake(0,0,self.size.width,self.size.height), self.CGImage); break; &#125; // And now we just create a new UIImage from the drawing context CGImageRef cgimg = CGBitmapContextCreateImage(ctx); UIImage *img = [UIImage imageWithCGImage:cgimg]; CGContextRelease(ctx); CGImageRelease(cgimg); return img;&#125;]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>实用</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[StoryBoard]]></title>
    <url>%2F2016%2F03%2F10%2F2016b%2FStoryBoard%2F</url>
    <content type="text"><![CDATA[1.UIStoryboard 通过xib 加载控制器的View initWithName:bundle: 如果指定了特定的名称的xib,会去加载指定的xib 如果指定是nil, 判断有没有当前控制器相同的xib,如果有，自动加载跟它相同名称的xib(aTextViewController.xib) r如果没有和它相同名称的xib，自动加载和它相同名称并且是去掉Controller的xib(aTextView.xib) 使用storyboard 界面跳转 使用UIStoryboardSegue 的destinationViewController和sourceViewController进行控制亲间传值 2.loadView 方法 loadView 作用是用来创建控制器的view 什么时候调用，当控制器的view，第一次使用的时候调用 load view的底层u 原理 先判断当前控制器是不是从storyBoard当中加载的，如果是从中加载的控制器，那么它会就会从storyBoard当中加载的控制器的view，设置当前控制器的view 当前控制器是不是从xib当中加载的，如果是从xib当中加载的话，把xib当中指定的view，设置当前控制器的view 如果也不是从xib加载的，会创建空白的view 3.load 方法 程序一运行，就创建对象 load 方法：当类被加载到内存中就会调用 使用shareInstance 禁止不能使用alloc 方法：如果调用，抛出异常 view 的实现原理 1.设置角标，首先设注册用户通知，才能设置提醒值：]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Swift学习</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 单元测试]]></title>
    <url>%2F2016%2F03%2F09%2F2016b%2FiOS%20%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[1.单元测试 测试性能，测试消耗时间 相同的代码重复执行10次，统计计算时间，平均时间 测试异步的耗时操作，使用Expection 2.猴子测试 猴子测试不能和UI测试共存 https://github.com/jonathanpenn/ui-auto-monkey]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>实用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[svn常用到操作指令]]></title>
    <url>%2F2016%2F03%2F08%2F2016b%2Fsvn%E5%B8%B8%E7%94%A8%E5%88%B0%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1.显示隐藏的文件夹 打开“终端”，根据自己的版本选择命令 早期的OS X（10.6~10.8）系统可以使用如下两条命令来开始或者关闭系统隐藏文件的显示： 12defaults write com.apple.Finder AppleShowAllFiles Yes &amp;&amp; killall Finder //显示隐藏文件defaults write com.apple.Finder AppleShowAllFiles No &amp;&amp; killall Finder //不显示隐藏文件 当升级到OS X 10.9 Mavericks版本之后，这两条命令需要做一些修改，变成了如下命令： 12defaults write com.apple.finder AppleShowAllFiles Yes &amp;&amp; killall Finder //显示隐藏文件defaults write com.apple.finder AppleShowAllFiles No &amp;&amp; killall Finder //不显示隐藏文件 快捷键： 在 macOS Sierra，我们可以使用快捷键⌘⇧.(Command + Shift + .) 来快速（在 Finder 中）显示和隐藏隐藏文件了。 2.查看 svn 所在文件下的文件状态， svn status / svn st 3.unix 下的命令行 unix 下的命令行 4.svn的客户端命令行 svn checkout 拉取服务器代码创建本地仓库 svn commit 提交到服务器 svn update 拉取服务器代码同步本地/会有本地冲突 svn add 将创建的文件添加到本地版本控制中 svn delete 删除本地文件 svn remove 移除本地文件 svn move 移动本地文件 svn mkdir 创建本地管理新目录 svn revert 撤销之前的修改 svn merge 合并某一个版本的代码 5.svn 常用到操作指令。 svn checkout 拉取服务器代码创建本地仓库 svn commit 提交到服务器 svn add - &gt; svn commit 将新创建的文件 添加到服务器上 svn delete -&gt; svn commit 删除本地文件，同步到服务器上 svn update 拉取服务器代码同步本地/会有本地冲突 // 124881677]]></content>
      <categories>
        <category>实用技术</category>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>实用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断银行卡-识别银行卡所在银行]]></title>
    <url>%2F2015%2F09%2F23%2F2015b%2F%E5%88%A4%E6%96%AD%E9%93%B6%E8%A1%8C%E5%8D%A1-%E8%AF%86%E5%88%AB%E9%93%B6%E8%A1%8C%E5%8D%A1%E6%89%80%E5%9C%A8%E9%93%B6%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[获取bank.infoPlist 根据银行卡号的前6位，或者前8位进行识别 1234567891011121314151617181920212223242526- (NSString *)returnBankName:(NSString*) idCard&#123; if(idCard==nil || idCard.length&lt;16 || idCard.length&gt;19)&#123; _resultLabel.text = @"卡号不合法"; return @""; &#125; NSString *plistPath = [[NSBundle mainBundle] pathForResource:@"bank" ofType:@"plist"]; NSDictionary* resultDic = [NSDictionary dictionaryWithContentsOfFile:plistPath]; NSArray *bankBin = resultDic.allKeys; //6位Bin号 NSString* cardbin_6 = [idCard substringWithRange:NSMakeRange(0, 6)]; //8位Bin号 NSString* cardbin_8 = [idCard substringWithRange:NSMakeRange(0, 8)]; if ([bankBin containsObject:cardbin_6]) &#123; return [resultDic objectForKey:cardbin_6]; &#125;else if ([bankBin containsObject:cardbin_8])&#123; return [resultDic objectForKey:cardbin_8]; &#125;else&#123; _resultLabel.text = @"plist文件中不存在请自行添加对应卡种"; return @""; &#125; return @""; &#125; 在输入的过程中控制4位1控制，使用uitext的代理： 12345678910111213141516171819202122232425262728293031323334-(BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string&#123; NSString *text = [self.textField text]; NSCharacterSet *characterSet = [NSCharacterSet characterSetWithCharactersInString:@"0123456789\b"]; string = [string stringByReplacingOccurrencesOfString:@" " withString:@""]; if ([string rangeOfCharacterFromSet:[characterSet invertedSet]].location != NSNotFound) &#123; return NO; &#125; text = [text stringByReplacingCharactersInRange:range withString:string]; text = [text stringByReplacingOccurrencesOfString:@" " withString:@""]; NSString *newString = @""; while (text.length &gt; 0) &#123; NSString *subString = [text substringToIndex:MIN(text.length, 4)]; newString = [newString stringByAppendingString:subString]; if (subString.length == 4) &#123; newString = [newString stringByAppendingString:@" "]; &#125; text = [text substringFromIndex:MIN(text.length, 4)]; &#125; newString = [newString stringByTrimmingCharactersInSet:[characterSet invertedSet]]; // 限制长度 if (newString.length &gt;= 24) &#123; return NO; &#125; [self.textField setText:newString]; return NO;&#125;]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>实用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题《三》]]></title>
    <url>%2F2015%2F09%2F22%2F2015b%2F%E9%9D%A2%E8%AF%95%E9%A2%983%2F</url>
    <content type="text"><![CDATA[100道面试题1.__weak什么时候用？2.是否使用过coreImage和coreText?如果使用过，说说你的体验3.数据结构、写一个顺序排列4.什么是TCP、DUP等协议？他们分别属于第几层？5.写一个单项链表逆序6.在iPhone中怎么写入C++程序，详细写下来7.写一个快速排序8.autorelease的对象是在什么时候被release的？11.什么是OpenGL?具体使用12.开发过程中应用程序内存泄露了该怎么办13.ios开发中有什么方式支持多继承？（obj-c有多重继承么?不是的话有什么替代方法?）14.从1-n个五序列的数字中排序的算法有哪些，简单代码实现一个并写出时间复杂度15.开启一个其他线程来计算1+1 并且把结果用主线程显示在label上更新UI16.ios7中navigationBar的背景如何设置成透明的吗？需求是这样的：viewController的背景是蓝色的，然后让navigationbar的背景是透明的，就 这样navigationbar也变成蓝色的了18.用预处理指令#define声明一个常数，用以表明1年中有多少秒（忽略闰年问题）19.写一个委托的 interface20.写一个NSString类的实现21.obj-c有私有方法么?私有变量呢22.关键字const有什么含意？修饰类呢?static的作用,用于类呢?还有extern c的作用23.为什么标准头文件都有类似以下的结构？ 12345678910#ifndef __INCvxWorksh #define __INCvxWorksh #ifdef __cplusplus extern "C" &#123; #endif /*...*/ #ifdef __cplusplus &#125; #endif #endif /* __INCvxWorksh */ 25.列举几种进程的同步机制，并比较其优缺点。 26.什么是键-值,键路径是什么 27.c和obj-c如何混用 28.cocoa touch框架 29.自动释放池是什么,如何工作 30.objc优点和objc缺点？ 31.sprintf,strcpy,memcpy使用上有什么要注意的地方 32..http和scoket通信的区别。 35.什么是push。 36.静态链接库 37.fmmpeg框架 38.fmdb框架 39.320框架 40.什么是沙箱模型？哪些操作是属于私有api范畴? 41.你在开发项目中时，用到了哪些数据存储方式，iphone中常见的方式有哪些，各有什么区别？ 43..init和initwithobject区别（语法）？ 44.你连接服务器用的是什么方法，如果请求过程中，网络出了问题这么办？ 47.协议是什么，有什么作用.？ 49.分线程回调主线程方法是什么，有什么作用？ 50.iphone阅读器，如果要读取一个文本文件，请问你是如何处理编码问题的？另外像pdf格式的文件，你如何读取。? 51.你在开发大型项目的时候，如何进行内存泄露检测的? 52.你做iphone开发时候，有哪些传值方式，view和view之间是如何传值的？ 53.让一个物体从界面中的一点运动到另外一点，有哪些方法？ 54.你了解哪些加密方式？ 55.地图定位 56.http网络通信 57.图片浏览 58.对像序列化 59.线程 ？ 123a. 线程的创建和使用规则?b. 主分线程c.线程锁 60.各种 排序算法？61.通信底层原理62.为什么很多内置类如UITableViewController的delegate属性都是assign而不是retain的？ 以下每行代码执行后，person对象的retain count分别是多少？ 1234Person *person = [[Person alloc] init]; count 1[person retain]; [person release];[person release]; 64.在一个对象的方法里面:self.name = “object”;和name ＝”object”有什么不同吗?67.请写出obj-c的内存管理代码68.什么是OOP？69.类变量的@protected, @private,@public, @package声明各有什么含义71.什么是序列化或者Archiving?可以用来作什么？怎么跟copy结合？74.KVO是同步还是异步？notification是同步还是异步？75.ios对象的生命周期？78.为NSString扩展一个方法，方法能判断字符串是否是Url地址（即判断字符串是否以“http://”），放回BOOL值类型 85.写一个简单的Objective C中的类的继承示例86.这段代码的意义，有没有问题 12345-(void) setName : (NSString*)name&#123;[myname release];[name retain];myname = name;&#125; 87.上机题 写一个iphone程序，有2屏，可以通过滑动切换，第二屏有一个webview，读取本地的html文件，Html文件中会加载一个本地xml文件，获取xml文件中的数据内容并显示。（可选：html中加载的js文件） 88.协议？89.TCP、HTTP、UDP90.什么是协议？分几层？91.UIView从出现到销毁的过程92.认证93.drawRect方法什么时候调用94.js和webview如何交互、95.框架phonegap96.地图中怎么计算两点间的曲线距离97.定位不准如何优化98.TCP和DUP的区别这两包的字节内容有啥不同答 ：TCP多了一些纠错码包装，DUP纠错和校验码99.简单的顺序列表100.如何避免json解析出现内存泄露，内存泄露后怎么解决 iOS性能优化技巧 通过静态 Analyze 工具，以及运行时 Profile 工具分析性能瓶颈，并进行性能优化。结合本人在开发中遇到的问题，可以从以下几个方面进行性能优化。 view优化 透明，懒加载，不要使用layoutsubViews，尽量使用drawRect，不要直接调用，使用替代setneedsdisplayinrect,layoutifneeded, UITableView优化 重用cell，透明。复杂的cell使用drawrect, 不要使用cellforrowatinddexpatn,cache尽可能高的东西，包括行高。 缓存优化 缓存，尽量缓存使用率高。但改变比较少的，服务器的相应，图片，计算结果 线程优化 线程，耗时操作放到子线程中。同步使用串行队列，代替同步锁 内存优化 内存优化，使用autoreleasepoll 实现减少 内存峰值。 代码细节优化 图片优化 对图片数据进行decode。在子线程中设置image的大小后，在imageview中使用缩放后的image。原因：由于UIImage的 imageWithData函数是每次画图的时候才将Data解压成ARGB的图像，所以在每次画图的时候，会有一个解压操作，UIImage初始化后仅 仅是把图片加载到内存中，而实际的解码和重采样是在图片需要显示时才进行。 1234567//图片重采样，在子线程中进行CGSize itemSize = CGSizeMake(width, height);//实际要缩放的大小UIGraphicsBeginImageContext(itemSize);CGRect imageRect = CGRectMake(0.0, 0.0, itemSize.width, itemSize.height);[image drawInRect:imageRect];UIImage newImage = UIGraphicsGetImageFromCurrentImageContext(); //重采样后的图片UIGraphicsEndImageContext(); ７、代码的优化，viewappear中不进行耗时操作，关键代码使用c效率更高。]]></content>
      <categories>
        <category>实用技术</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有用的UI组件]]></title>
    <url>%2F2015%2F09%2F22%2F2015b%2F%E6%9C%89%E7%94%A8%E7%9A%84UI%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Xcode 快捷键倒计时闪烁问题可视化编程中—-cell的自适应高度iOS 关闭图片渲染setValue 和setObject 的区别IOS如何让实现国际化的相关配置UITextView的点击链接collecton的长按编辑的代码实现NSAttributedString.h 中属性的定义，key使用openURL实现程序间带参数跳转详解 1.子类父类class/superclass判断 子类调用子类自己的方法，判断如下 子类调用父类的方法，结果如下 2.倒计时闪烁问题 UIButton+countDown.h，点击获取验证码后进行倒计时，效果挺好，但会闪烁， 解决办法:将UIButton的类型由system改为custom就OK。 3.Xcode 快捷键 快捷键 123456789101112131、command 1/2/3/4/5 左侧的不同栏目2、commad + e 搜索当前词 在本文件中搜索 3、command +g 结合上面，选中搜索，然后下一个4、 Command + [ 左缩进 Command + ] 右缩进5、 control +6 搜索本文件的方法显示出方法列表6、command option + j 跳到目录搜索7、command option + [ 当前行上下移动8、command option ＋ Left/Right 折叠、展开当前代码段9、command control + Up/Down .h 和.m 之间的切换10、command control ＋ Left/Right浏览历史的前进后退11、command shift o 文件、方法全局搜索12、command shift ＋f 全局搜索 13、 command shift +J 左侧栏显示当前所在文件 4.Xcode描述文件问题 No matching provisioning profile found: Your build settings specify a provis 解决办法~/Library/MobileDevice/Provisioning Profiles 全部删除，之后重新安装描述文件即可 5.可视化编程中—-cell的自适应高度 可视化编程中—-cell的自适应高度 1234567891011- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath&#123;Joke *joke = self.dataArray[indexPath.row];NSString *content = joke.joke;self.customCell.contentLabel.text = content;self.customCell.bounds = CGRectMake(0, 0, self.view.frame.size.width, self.customCell.frame.size.height);[self.customCell updateConstraintsIfNeeded];[self.customCell layoutIfNeeded];CGFloat height = [self.customCell systemLayoutSizeFittingSize: UILayoutFittingCompressedSize].height + 1;return height;&#125; 6.iOS 关闭图片渲染 在为Button 设置背景图片的时候, 会发现显示的效果和UI给的图片不一样, 往往是把图片显示成为蓝色, 这是因为在新版的iOS中, 会自动对图片渲染.我们只要把图片渲染关掉就OK了 1234567- (UIImage *)imageWithRenderingMode:(UIImageRenderingMode)renderingMode这个方法就是用来设置图片的渲染模式的UIImageRenderingModeAlwaysOriginal这个枚举值是声明这张图片要按照原来的样子显示，不需要渲染成其他颜色UIImage *playImage = [UIImage imageNamed:@"luzhi"];playImage = [playImage imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal];[_playBtn setImage:playImage forState:UIControlStateNormal]; 7.setValue 和setObject 的区别 setObject：forkey：中value是不能够为nil的，不然会报错。 setValue：forKey：中value能够为nil，但是当value为nil的时候，会自动调用removeObject：forKey方法 setValue：forKey：中key的参数只能够是NSString类型，而setObject：forKey：的可以是任何类型 8.IOS如何让实现国际化的相关配置 iOS中国际化需要做相关的配置： 选中应用程序对应的project，然后添加所需要国际化的语言。 新建Localizable.strings文件，作为多语言对应的词典，存储多种语言，点击右侧Localization，勾选国际化对应的语言。 添加一个字段，设置你想要国际化的字段 在English中，添加：SUBMIT_BTN_TITLE = Go; 在Chinese中，添加：SUBMIT_BTN_TITLE = 开始; 9.UITextView的点击链接 UITextView的链接创建一个NSAttributedString然后增加给它增加一个NSLinkAttributeName 属性，见以下： 1234567891011121314NSMutableAttributedString *attributedString = [[NSMutableAttributedString alloc] initWithString:@"This is an example by @marcelofabri_"];[attributedString addAttribute:NSLinkAttributeName value:@"username://marcelofabri_" range:[[attributedString string] rangeOfString:@"@marcelofabri_"]]; NSDictionary *linkAttributes = @&#123;NSForegroundColorAttributeName: [UIColor greenColor], NSUnderlineColorAttributeName: [UIColor lightGrayColor], NSUnderlineStyleAttributeName: @(NSUnderlinePatternSolid)&#125;;textView.linkTextAttributes = linkAttributes; // customizes the appearance of linkstextView.attributedText = attributedString;textView.delegate = self; 这样就可以让链接在文本中显示。然而，你也可以控制当链接被点击的时候会发生什么，实现这个可以使用UITextViewDelegate协议的新的shouldInteractWithURL方法，就像这样： 12345678- (BOOL)textView:(UITextView *)textView shouldInteractWithURL:(NSURL *)URL inRange:(NSRange)characterRange &#123; if ([[URL scheme] isEqualToString:@"username"]) &#123; NSString *username = [URL host]; // do something with this username return NO; &#125; return YES; // let the system open this URL&#125; 10.table下面滑不下去，是table的高度超出了屏幕宽度 高度超过了屏幕宽度，高度设置的不对 12[weakSelf.currentVC.view setFrame:CGRectMake(0, 100, ScreenW, ScreenH-64)]; self.edgesForExtendedLayout = UIRectEdgeNone; //也是个方法，是上方多处一块64时 11.气泡图片中间拉伸 把一张小的图片做背景保持四周不变，拉伸中间，则用如下属性。UIEdgeInsets是拉伸的区域，一般取最中间的一个点 1234UIImage *meBgNor=[UIImage imageNamed:@"chat_send_nor"];UIEdgeInsets edge1=UIEdgeInsetsMake(28, 32, 28, 32);meBgNor=[meBgNor resizableImageWithCapInsets:edge1 resizingMode:UIImageResizingModeStretch];[self.textView setBackgroundImage:meBgNor forState:UIControlStateNormal]; 背景气泡图 1234567891011UIImage *normal;if (message.from == UUMessageFromMe) &#123; normal = [UIImage imageNamed:@"chatto_bg_normal"]; normal = [normal resizableImageWithCapInsets:UIEdgeInsetsMake(35, 10, 10, 22)];&#125;else&#123; normal = [UIImage imageNamed:@"chatfrom_bg_normal"]; normal = [normal resizableImageWithCapInsets:UIEdgeInsetsMake(35, 22, 10, 10)];&#125;[self.btnContent setBackgroundImage:normal forState:UIControlStateNormal];[self.btnContent setBackgroundImage:normal forState:UIControlStateHighlighted]; 12.collecton的长按编辑的代码实现 （1） 对collectionView的处理 123456789101112131415161718192021222324252627282930- (void)handlelongGesture:(UILongPressGestureRecognizer *)longGesture &#123;//判断手势状态switch (longGesture.state) &#123; case UIGestureRecognizerStateBegan: &#123; //判断手势落点位置是否在路径上 NSIndexPath *indexPath = [self.theCollectionView indexPathForItemAtPoint:[longGesture locationInView:self.theCollectionView]]; if (indexPath == nil) &#123; break; &#125; //在路径上则开始移动该路径上的cell [self.theCollectionView beginInteractiveMovementForItemAtIndexPath:indexPath]; &#125; break; case UIGestureRecognizerStateChanged: //移动过程当中随时更新cell位置 [self.theCollectionView updateInteractiveMovementTargetPosition: [longGesture locationInView:self.theCollectionView]]; break; case UIGestureRecognizerStateEnded: //移动结束后关闭cell移动 [self.theCollectionView endInteractiveMovement]; break; default: [self.theCollectionView cancelInteractiveMovement]; break;&#125;&#125; (2) 代理方法能否编辑返回yes, 1234- (BOOL)collectionView:(UICollectionView *)collectionViewcanMoveItemAtIndexPath:(NSIndexPath *)indexPath &#123; return YES;&#125; (3) 对数据源数据的处理： 1234567891011121314151617- (void)collectionView:(UICollectionView *)collectionViewmoveItemAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath &#123;//取出源item数据id objc1 = [_titleMuarray objectAtIndex:sourceIndexPath.row];id objc2 = [_imageNameMuarray objectAtIndex:sourceIndexPath.row];//从资源数组中移除该数据[_titleMuarray removeObject:objc1];[_imageNameMuarray removeObject:objc2];//将数据插入到资源数组中的目标位置上[_titleMuarray insertObject:objc1 atIndex:destinationIndexPath.row];[_imageNameMuarray insertObject:objc2 atIndex:destinationIndexPath.row];WorkStore *workStoreInfomation1 = [WorkStore MR_findFirst];workStoreInfomation1.sortOrder = _titleMuarray;workStoreInfomation1.imageName = _imageNameMuarray;[[NSManagedObjectContext MR_defaultContext] MR_saveToPersistentStoreAndWait];&#125; 13.项目中使用多个storyBoard之间的跳转 使用代码进行2个storyboard之间的跳转： 另外创建的storyboard的名字自己定义，之后在将要跳转的controller中取出storyboard，然后再取出其中需要的controller，进行跳转 123UIStoryboard *secondStroyBoard=[UIStoryboard storyboardWithName:@"Storyboard2" bundle:nil]; UIViewController *test2obj=[secondStroyBoard instantiateViewControllerWithIdentifier:@"test2"];[self.navigationController pushViewController:test2obj animated:NO]; 如何从多个storyboard中取出控制器实例。不用管控制在哪个storyboard文件里，只要 控制器设置identifier为类名就OK。 14.NSAttributedString.h 中属性的定义，key 如何使用NSString在 drawInRect中居中 drewRect属性， withAttributes:参数是属性字典，该字典的key在NSAttributedString.h中获得， 123456789NSMutableParagraphStyle style = [[NSMutableParagraphStyle alloc] init]; [style setAlignment:UITextAlignmentCenter]; style.lineBreakMode =NSLineBreakByCharWrapping;NSDictionary attr = @&#123; NSParagraphStyleAttributeName:style, NSFontAttributeName: [UIFont systemFontOfSize:10], NSForegroundColorAttributeName:[UIColor colorWithHexString:@"333333"]&#125;; NSAttributedString.h 中属性的定义，key 1234567891011121314字符属性字符属性可以应用于 attributed string 的文本中。NSString *const NSFontAttributeName;(字体)NSString *const NSParagraphStyleAttributeName;(段落)NSString *const NSForegroundColorAttributeName;(字体颜色)NSString *const NSBackgroundColorAttributeName;(字体背景色)NSString *const NSLigatureAttributeName;(连字符)NSString *const NSKernAttributeName;(字间距)NSString *const NSStrikethroughStyleAttributeName;(删除线)NSString *const NSUnderlineStyleAttributeName;(下划线)NSString *const NSStrokeColorAttributeName;(边线颜色)NSString *const NSStrokeWidthAttributeName;(边线宽度)NSString *const NSShadowAttributeName;(阴影)(横竖排版)NSString *const NSVerticalGlyphFormAttributeName; 详细解释 123456789101112131415161718192021222324252627282930313233343536常量1&gt; NSFontAttributeName(字体)该属性所对应的值是一个 UIFont 对象。该属性用于改变一段文本的字体。如果不指定该属性，则默认为12-point Helvetica(Neue)。2&gt; NSParagraphStyleAttributeName(段落)该属性所对应的值是一个 NSParagraphStyle 对象。该属性在一段文本上应用多个属性。如果不指定该属性，则默认为 NSParagraphStyle 的defaultParagraphStyle 方法返回的默认段落属性。3&gt; NSForegroundColorAttributeName(字体颜色)该属性所对应的值是一个 UIColor 对象。该属性用于指定一段文本的字体颜色。如果不指定该属性，则默认为黑色。4&gt; NSBackgroundColorAttributeName(字体背景色)该属性所对应的值是一个 UIColor 对象。该属性用于指定一段文本的背景颜色。如果不指定该属性，则默认无背景色。5&gt; NSLigatureAttributeName(连字符)该属性所对应的值是一个 NSNumber 对象(整数)。连体字符是指某些连在一起的字符，它们采用单个的图元符号。0 表示没有连体字符。1 表示使用默认的连体字符。2表示使用所有连体符号。默认值为 1（注意，iOS 不支持值为 2）。6&gt; NSKernAttributeName(字间距)该属性所对应的值是一个 NSNumber 对象(整数)。字母紧排指定了用于调整字距的像素点数。字母紧排的效果依赖于字体。值为 0 表示不使用字母紧排。默认值为0。7&gt; NSStrikethroughStyleAttributeName(删除线)该属性所对应的值是一个 NSNumber 对象(整数)。该值指定是否在文字上加上删除线，该值参考“Underline Style Attributes”。默认值是NSUnderlineStyleNone。8&gt; NSUnderlineStyleAttributeName(下划线)该属性所对应的值是一个 NSNumber 对象(整数)。该值指定是否在文字上加上下划线，该值参考“Underline Style Attributes”。默认值是NSUnderlineStyleNone。9&gt; NSStrokeColorAttributeName(边线颜色)该属性所对应的值是一个 UIColor 对象。如果该属性不指定（默认），则等同于 NSForegroundColorAttributeName。否则，指定为删除线或下划线颜色。更多细节见“Drawing attributedstrings that are both filled and stroked”。10&gt; NSStrokeWidthAttributeName(边线宽度)该属性所对应的值是一个 NSNumber 对象(小数)。该值改变描边宽度（相对于字体size 的百分比）。默认为 0，即不改变。正数只改变描边宽度。负数同时改变文字的描边和填充宽度。例如，对于常见的空心字，这个值通常为3.0。11&gt; NSShadowAttributeName(阴影)该属性所对应的值是一个 NSShadow 对象。默认为 nil。12&gt; NSVerticalGlyphFormAttributeName(横竖排版)该属性所对应的值是一个 NSNumber 对象(整数)。0 表示横排文本。1 表示竖排文本。在 iOS 中，总是使用横排文本，0 以外的值都未定义。 15.清除所有的NSUserDefault 清除所有的NSUserDefault 1234- (void)clearAllUserDefaultsData&#123; NSString *appDomain = [[NSBundle mainBundle] bundleIdentifier]; [[NSUserDefaults standardUserDefaults] removePersistentDomainForName:appDomain];&#125; 16.使用openURL实现程序间带参数跳转详解 (1) target -&gt; info -&gt; url scheme 添加URL (2) 正常跳转 1234567NSURL *url = [NSURL URLWithString:@"B://com.YouXianMing"];if ([[UIApplication sharedApplication] canOpenURL:url])&#123; NSLog(@"跳转并打开"); [[UIApplication sharedApplication] openURL:url];&#125;else&#123; NSLog(@"打开失败");&#125; (3) 带参数跳转 1234567891011// 其他应用的 URL Schemes --&gt; B// 其他应用的 Identifier --&gt; com.xinguan// values? --&gt; 要传递的参数,方便解析NSURL *url = [NSURL URLWithString:\ @"B://com.xinguan/values?username=WT&amp;password=123456&amp;callback=invoking"];if ([[UIApplication sharedApplication] canOpenURL:url])&#123; NSLog(@"跳转并打开"); [[UIApplication sharedApplication] openURL:url];&#125;else&#123; NSLog(@"打开失败");&#125; (4) 接收到参数解析 123456789101112131415161718192021- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation&#123; if ([[url scheme] isEqualToString:@"B"])&#123; if ([[url host] isEqualToString:@"com.xinguan"])&#123; /* query用法 The query string from the URL. If the receiver does not conform to RFC 1808, returns nil. For example, in the URL http://www.example.com/index.php?key1=value1&amp;key2=value2, the query string is key1=value1&amp;key2=value2. */ NSString *query = [url query]; // 分割&amp; NSArray *array = [query componentsSeparatedByString:@"&amp;"]; // 显示数据 NSLog(@"%@", array); &#125; return YES; &#125; return NO;&#125; 17.在view上的window问题 在view上的window问题： 当在一个XIB上添加一个window，拖线出来，默认是显示的，就是不写任何代码，也是在当前窗口上覆盖，影响交互， 先设置hidden，后在makeKeyAndVisible 当取消key window的时候，注意hidden调]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>实用</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实用软件工具]]></title>
    <url>%2F2015%2F09%2F22%2F2015b%2F%E5%AE%9E%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[1.突破百度网盘下载速度现在，使用 Aria2下载 Aria2-不限速全平台下载利器 但是百度网盘账号会被限速 ，冲会员解除正常限制网速 2.Safari + 预览，将网页转化为自定义尺寸 PDF3.清除Xcode 缓存 删除模拟器运行缓存，找到Developer-&gt;Devices,打开后可以看到是哪个项目，自行决定删除 1~/Library/Developer/Xcode/CoreSimulator /Devices 清除 Xcode 的打包数据缓存 1~/Library/Developer/Xcode/Archives 清除 Xcode 支持的真机系统文件 每次连接新的真机，Xcode都会拷贝设备系统 1~/Library/Developer/Xcode/iOS DeviceSupport 删除Xcode运行缓存。不同版本会有不同的缓存，尽量删除不必要的。 Xcode-&gt;DerivedData 路径 123456789101.Xcode证书路径：~/Library/MobileDevice/Provisioning Profiles2.Jenkines共享证书路径：/用户/共享/Jenkins/Library/MobileDevice/Provisioning Profiles3.Xcode编译项目缓存垃圾的目录：~/Library/Developer/Xcode/DerivedData4.Xcode PCH 根文件路径：$(PROJECT_DIR)/$(PROJECT_NAME)/5.Xcode插件路径：~/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins -name 4.表格优化模拟器技巧 1).代码评审 代码评审工具phabricator 评审之后上传SVN 或git 2).awakefromnib 中布局，子视图还没有bounds，取宽度为0 3).图像的优化，设置圆角的优化 模拟器技巧 使用 color Misaligned Images 对齐 如果图片拉伸使用CPU 拉伸图片，如果显示黄色，是拉伸的，需要编程绿色，或者不变色 使用Color Blended Layers 混合 4).模拟器常用性能测试工具 5.表格视图优化 缓存行高，是解决性能的最佳途径， 尽量少计算，所需要的素材是提前计算好，使用ViewModel中计算，再赋值给cell 控件上不要设置圆角半径，所有图像渲染的属性，都要注意 不要动态创建控件，所需要的控件，都要提前准备好，在显示的时候，根据数据隐藏 cell 中的控件曾是越少越好，数量越少越好 离屏渲染 ,需要在CPU和GPU之间快速切换，耗电增加 layer 异步加载，self.layer.drawsAsynchronously = true 栅格化 异步绘制的时候会生成一张独立的图像，滚动的是一张图像，停下来会切换CPU， 12self.layer.shouldRasterize = trueself.layer.rasterizationScale = UIScreen.main().scale 6.使用instrument 工具分析 Leaks 找到引发内存泄漏的起点 Core Animation 测试核心动画屏幕刷新帧率 time Profiler 分析代码的执行时间，找出导致程序变慢原因 Allocation 监测内存使用／分配情况 Zombiles 僵尸对象，（MRC 开发必备）]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>实用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题《二》]]></title>
    <url>%2F2015%2F09%2F21%2F2015b%2F%E9%9D%A2%E8%AF%95%E9%A2%982%2F</url>
    <content type="text"><![CDATA[一个区分度很大的面试题 考察一个面试者基础咋样，基本上问一个 @property 就够了： 1.@property 后面可以有哪些修饰符？ 2.什么情况使用 weak 关键字，相比 assign 有什么不同？ 3.怎么用 copy 关键字？ 4.这个写法会出什么问题： @property (copy) NSMutableArray *array; 5.如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？ 这一套问题区分度比较大，如果上面的问题都能回答正确，可以延伸问更深入点的： @property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的 @protocol 和 category 中如何使用 @property runtime 如何实现 weak 属性 每个人擅长的领域不一样，我们一般会从简历上找自己写擅长的技术聊，假如自己并不是很熟，最好别写出来或扯出来，万一面试官刚好非常精通这里就露馅了。 总结过些面试题，没坚持下去，后来把这些当 checklist，面试的时候实在没话聊的时候做个提醒，语言、框架、运行机制性质的： @property中有哪些属性关键字？ weak属性需要在dealloc中置nil么？ @synthesize和@dynamic分别有什么作用？ ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？ 用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？ @synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？ 在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？ objc中向一个nil对象发送消息将会发生什么？ objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？ 什么时候会报unrecognized selector的异常？ 一个objc对象如何进行内存布局？（考虑有父类的情况） 一个objc对象的isa的指针指向什么？有什么作用？ runtime | runloop runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法） 使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？ objc中的类方法和实例方法有什么本质区别和联系？ _objc_msgForward函数是做什么的，直接调用它将会发生什么？ runtime如何实现weak变量的自动置nil？ 能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？ runloop和线程有什么关系？ runloop的mode作用是什么？ 以+ scheduledTimerWithTimeInterval…的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？ 猜想runloop内部是如何实现的？ objc使用什么机制管理对象内存？ ARC通过什么方式帮助开发者管理内存？ 不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建） BAD_ACCESS在什么情况下出现？ 苹果是如何实现autoreleasepool的？ 使用block时什么情况会发生引用循环，如何解决？ 在block内如何修改block外部变量？ 使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？ GCD的队列（dispatch_queue_t）分哪两种类型？ 如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图） dispatch_barrier_async的作用是什么？ 苹果为什么要废弃dispatch_get_current_queue？ 以下代码运行结果如何？ 12345678- (void)viewDidLoad&#123; [super viewDidLoad]; NSLog(@"1"); dispatch_sync(dispatch_get_main_queue(),^&#123; NSLog(@"2"); &#125;); NSLog(@"3");&#125; addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？ 如何手动触发一个value的KVO 若一个类有实例变量NSString *_foo，调用setValue:forKey:时，可以以foo还是_foo作为key？ KVC的keyPath中的集合运算符如何使用？ KVC和KVO的keyPath一定是属性么？ 如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？ apple用什么方式实现对一个对象的KVO？ IBOutlet连出来的视图属性为什么可以被设置成weak? IB中User Defined Runtime Attributes如何使用？ 如何调试BAD_ACCESS错误 lldb（gdb）常用的调试命令？ 这些小题可以做为讨论的入口，根据面试者的回答再继续聊下去。其中一些题比较底层，是留给屌屌的面试者或者试探评级用的，一般情况并不是重点的考察内容。 业务能力 毕竟平常的工作内容不是 runtime、runloop，不怎么会用到底层的黑魔法，80% 的时间都是和搭建页面、写业务逻辑、网络请求打交道。要求面试者能够熟练构建 UI，我会找一个面试者做过的页面让他分析下页面结构、约束或者 frame 布局的连法和计算方法；有时也会让面试者说说 UITableView 常用的几个 delegate 和 data source 代理方法，动态 Cell 高度计算什么的；接下来，在手机里随便找一个 App 的页面，让面试者当场说说如果是他写应该用哪些 UI 组件和布局方式等。问几个问题后就能大概了解业务能力了，我们这边重度使用 IB 和 AutoLayout，假如面试者依然使用代码码 UI 也到没关系，有“从良”意愿就很好~ 程序架构和一些设计模式如果面试者自己觉得还不错的话也会聊聊，但跪求别说 Singleton 了，用的越多对水平就越表示怀疑。对设计模式自信的我一般问一个问题，抽象工厂模式在 Cocoa SDK 中哪些类中体现？架构上 MVC 还是 MVVM 还是 MVP 神马的到是可以聊聊各自的见解，反正也没有正确答案，只要别搞的太离谱就行，比如有的人说网络请求和数据库的操作最好放到 UIView 的子类里面干。 网络请求、数据库等各家都有成熟的封装，基本知道咋用就行。除此之外，我们还会顺带的问下除了 iOS 开发外，还会什么其他编程语言、或者熟悉哪种脚本语言和 Terminal 操作等，甚至还问问是如何翻墙- -，相信这些技能都是很重要的。 性格 大家都是写程序的，没啥必要用奇怪的、很难的问题难为对方，更关键的还是性格，和 Team 的风格是不是和的来。一个心态良好的面试者需要有个平常心，不傲娇也不跪舔，表达要正常，经常遇到问一个问题后一两分钟一直处于沉思状态，一句话不说，交流像挤牙膏一样，很是憋屈；还有非常屌屌的，明明不懂仍然强行据理力争，镇得住面试官也罢，撞枪口上就别怪不客气了- - 。决定要不要一个人基本上聊 5 分钟就可以确定了，喜欢水到渠成的感觉，看对眼了挡都挡不住。]]></content>
      <categories>
        <category>实用技术</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有用的开发记录]]></title>
    <url>%2F2015%2F09%2F21%2F2015b%2F%E6%9C%89%E7%94%A8%E7%9A%84%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95%3C1%3E%2F</url>
    <content type="text"><![CDATA[1.字符串GB2312编码 字符串GB2312编码 123NSString *arrr = @"测试";NSStringEncoding gbkEncoding =CFStringConvertEncodingToNSStringEncoding(kCFStringEncodingGB_18030_2000);NSData *adata = [arrr dataUsingEncoding:gbkEncoding]; 2.UIView独占响应事件 一个布尔值,用来标示一个view独占触摸事件. 当把一个view中的exclusiveTouch设置成YES时,会致使这个window屏蔽掉其他的view触发响应事件.默认值是NO. 1_button1.exclusiveTouch = YES; 3.设置导航栏 设置隐藏导航栏 12345678- (void)viewWillAppear:(BOOL)animated &#123;[super viewWillAppear:animated]; [self.navigationController setNavigationBarHidden:YES animated:YES]; &#125; - (void)viewWillDisappear:(BOOL)animated &#123; [super viewWillDisappear:animated]; [self.navigationController setNavigationBarHidden:NO animated:YES];&#125; 设置导航栏为白色： 在plist中设置 View controller-based status bar appearance 11、plist View controller-based status bar appearance 设置为 NO 在appdelegate 代码设置 1[UIApplication sharedApplication].statusBarStyle = UIStatusBarStyleLightContent; 4.OC中block作为函数参数传递 使用枚举 typedef void (^OnFoolCallback)(NSString *name); 定义方法 - (void)productFool:(OnFoolCallback)callback; 123456typedef void (^OnFoolCallback)(NSString *name); - (void)productFool:(OnFoolCallback)callback; [fb productFool:^(NSString *name) &#123; NSLog(@"name = %@", name); &#125;]; 4.collectionView的section刷新的时候有动画会闪一下解决 解决办法：停止动画： 123456[UIView setAnimationsEnabled:NO];[self.homeCollectionView performBatchUpdates:^&#123; [self.homeCollectionView reloadSections:[NSIndexSet indexSetWithIndex:index]];&#125; completion:^(BOOL finished) &#123; [UIView setAnimationsEnabled:YES]; &#125;]; 5.控制数据越界崩溃 数组越界控制 1234567891011121314151617181920+(void)load&#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; SEL safeSel=@selector(safeObjectAtIndex:); SEL unsafeSel=@selector(objectAtIndex:); Class myClass = NSClassFromString(@"__NSArrayI"); Method safeMethod=class_getInstanceMethod (myClass, safeSel); Method unsafeMethod=class_getInstanceMethod (myClass, unsafeSel); Method_exchangeImplementations(unsafeMethod, safeMethod); &#125;);&#125;-(id)safeObjectAtIndex:(NSUInteger)index&#123; if (index&gt;(self.count-1)) &#123; NSAssert(NO, @"beyond the boundary"); return nil; &#125; else&#123; return [self safeObjectAtIndex:index]; &#125;&#125; 6.Pt与Px 相互转换关系 Pt与Px 相互转换关系。Pt＝（Px／96.0)＊72.0 Pixel Point 7.设置声音静音：soundname 推送通知禁止声音 设置声音静音：soundname ，震动也是一个souond：kSystemSoundID_Vibrate 后台的代码设置推送内容 1234PushNotificationPayload payLoad = PushNotificationPayload.fromJSON(message); payLoad.addAlert("iphone推送测试 www.baidu.com"); // 消息内容 payLoad.addBadge(count); // iphone应用图标上小红圈上的数值 payLoad.addSound("default"); // 铃音 默认 2:程序内代码 12345678910111213#import &lt;AudioToolbox/AudioToolbox.h&gt; AudioServicesPlaySystemSound(kSystemSoundID_Vibrate); AudioServicesPlaySystemSound(1007);其中1007是系统声音的编号，其他的可用编号：//音效文件路径 NSString *path = [[NSBundle mainBundle] pathForResource:@"message" ofType:@"wav"]; //组装并播放音效 SystemSoundID soundID; NSURL *filePath = [NSURL fileURLWithPath:path isDirectory:NO]; AudioServicesCreateSystemSoundID((__bridge CFURLRef)filePath, &amp;soundID); AudioServicesPlaySystemSound(soundID); //声音停止 AudioServicesDisposeSystemSoundID(soundID); 8.编辑键盘问题-&gt;键盘下缩 有键盘，点击保存，或者编辑等时候点击键盘下缩，出现如下bug 1“[App] if we're in the real pre-commit handler we can't actually add any new fences due to CA restriction” 解决办法： [self layoutSubviews]; 9.UI View相对位置 获取点击事件的点相对于屏幕的位置 如果点击事件是如下这个方法（将UIEvent当做参数传回来） 1234-(void)expandButtonClicked:(id)sender withEvent:(UIEvent*)event那么点击的位置相对于屏幕的坐标就是：UITouch* touch = [[event touchesForView:btn] anyObject];CGPoint rootViewLocation = [touch locationInView:[FtAppDelegate shareAppDelegate].rootViewCtrl.view]; 如果想知道一个view相对于屏幕或者另外一个view 的坐标，那么可以通过如下的方法得到： 12UIWindow * window=[[[UIApplication sharedApplication] delegate] window];CGRect rect=[bView convertRect: bView.bounds toView:window]; 10.UI View 移除子视图 移除所有子视图，无需循环只需要一句代码 1[view.subviews makeObjectsPerformSelector:@selector(removeFromSuperview)]; 11.虚拟机安装之后隔一段时间不能实用了修复 VirtualBox 打开虚拟机，报如下错误 123456shjyytxnj Implementation of the USB 2.0 controller not found!Because the USB 2.0 controller state is part of the saved VM state, the VM cannot be started. To fix this problem, either install the 'Oracle VM VirtualBox Extension Pack' or disable USB 2.0 support in the VM settings.Note! This error could also mean that an incompatible version of the 'Oracle VM VirtualBox Extension Pack' is installed (VERR_NOT_FOUND). 安装了不兼容版本的“Oracle VM VirtualBox Extension Pack” 1234重新下载 最新版的（1）VirtualBox 5.1.12 platform packages.\（2）VirtualBox 5.1.12 Oracle VM VirtualBox Extension Pack https://www.virtualbox.org/wiki/Downloads找到相匹配的版本和插件 重新札幌 12.设置textField 的placeholder的颜色 设置textField 的placeholder的颜色 12[self.searchtextField setValue:RGB(156, 86, 49) forKeyPath:@"_placeholderLabel.textColor"];[self.searchtextField setValue:[UIFont boldSystemFontOfSize:14] forKeyPath:@"_placeholderLabel.font"]; 13.navbarhiddern ,消失之后的显示隐藏的缺一部分bug, Hidden动画问题 12345678910111213141516171819202122@property (nonatomic, assign) BOOL closeNavBarAnimating;- (void)viewDidLoad&#123; [super viewDidLoad]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(chageBool:) name:@"closeBarAnimationing" object:nil];&#125;-(void)viewWillAppear:(BOOL)animated&#123; [super viewWillAppear:animated]; if (self.closeNavBarAnimating) &#123; animated = NO; &#125; [self.navigationController setNavigationBarHidden:YES animated:animated];｝-(void)viewWillDisappear:(BOOL)animated&#123; [super viewWillDisappear:animated]; [self.navigationController setNavigationBarHidden:NO animated:animated]; self.closeNavBarAnimating = NO; &#125;-(void)chageBool:(id)sedner&#123; self.closeNavBarAnimating = YES; &#125; 14.APP启动GIF动画 UIImageView和UIImage都不支持GIF动画，使用UIWebView 加载GIF启动动画 1234567891011121314151617181920212223242526@interface ViewController ()@property (weak, nonatomic) IBOutlet UIWebView *webViewBG;@property (weak, nonatomic) IBOutlet UIButton *regBtn;@property (weak, nonatomic) IBOutlet UIButton *loginBtn;@end@implementation ViewController - (void)viewDidLoad &#123; [super viewDidLoad]; //初始化UIWebView对象，添加GIF文件 NSString *filePath = [[NSBundle mainBundle] pathForResource:@"bg" ofType:@"gif"]; NSData *gif =[NSData dataWithContentsOfFile:filePath]; [self.webViewBG loadData:gif MIMEType:@"image/gif" textEncodingName:nil baseURL:nil]; self.webViewBG.userInteractionEnabled = NO; //创建一个灰色的蒙版，提升效果（可选） UIView *filter = [[UIView alloc] initWithFrame:self.view.bounds]; filter.backgroundColor = [UIColor blackColor]; filter.alpha = 0.5; [self.view addSubview:filter]; //修改登录按钮和注册按钮的显示层级 [self.view bringSubviewToFront:self.loginBtn]; [self.view bringSubviewToFront:self.regBtn];&#125; 15.QQ聊天气泡样式界面 定义枚举区别是自己还是别人 1234typedef enum&#123; WPMessageTypeMe=0, WPMessageTypeOther=1&#125;WPMessageType; 计算一段文字所占据的宽和高 123CGSize textMaxSize=CGSizeMake(200, MAXFLOAT);NSDictionary *attr1=@&#123;NSFontAttributeName:[UIFont systemFontOfSize:14]&#125;;CGSize textSize=[message.text boundingRectWithSize:textMaxSize options:NSStringDrawingUsesLineFragmentOrigin attributes:attr1 context:nil].size; 把一张小的图片做背景保持四周不变，拉伸中间，则用如下属性。UIEdgeInsets是拉伸的区域，一般取最中间的一个点 1234UIImage *meBgNor=[UIImage imageNamed:@"chat_send_nor"];UIEdgeInsets edge1=UIEdgeInsetsMake(28, 32, 28, 32);meBgNor=[meBgNor resizableImageWithCapInsets:edge1 resizingMode:UIImageResizingModeStretch];[self.textView setBackgroundImage:meBgNor forState:UIControlStateNormal]; 监听键盘的弹出隐藏 12345678910[[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(changeFrame:) name:UIKeyboardDidChangeFrameNotification object:nil];-(void)changeFrame:(NSNotification *)note&#123; self.view.superview.backgroundColor=[UIColor colorWithRed:0.9 green:0.9 blue:0.9 alpha:0.9]; CGFloat duration=[note.userInfo[UIKeyboardAnimationDurationUserInfoKey] doubleValue]; CGFloat keyboardY=[note.userInfo[UIKeyboardFrameEndUserInfoKey] CGRectValue].origin.y; CGFloat screenH=[UIScreen mainScreen].bounds.size.height; [UIView animateWithDuration:duration animations:^&#123; self.view.transform=CGAffineTransformMakeTranslation(0, keyboardY-screenH); &#125;];&#125; 输入框不是键盘的inputView没有键盘的时候也是悬浮在视图上，弹出键盘的时候控制view的frame就行，底部对齐 lable自适应 1label.adjustsFontSizeToFitWidth = YES; 16.使用CAShapeLayer实现一个音量大小动态改变的控件 类似微信的语音 思路，外界轮廓是有圆角的图像类似椭圆，layer是个矩形，maskToBounds 为yes, _dynamicView 表示外部轮廓的View。 _indicateLayer 表示内容动态显示的Layer 12345678910-(void)refreshUIWithVoicePower : (NSInteger)voicePower&#123; CGFloat height = (voicePower)*(CGRectGetHeight(_dynamicView.frame)/TOTAL_NUM); [_indicateLayer removeFromSuperlayer]; _indicateLayer = nil; UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(0, CGRectGetHeight(_dynamicView.frame)-height, CGRectGetWidth(_dynamicView.frame), height) cornerRadius:0]; _indicateLayer = [CAShapeLayer layer]; _indicateLayer.path = path.CGPath; _indicateLayer.fillColor = [UIColor whiteColor].CGColor; [_dynamicView.layer addSublayer:_indicateLayer];&#125; 17.比较UIimageView的image是哪张图片 实现手势引导页根据图片名字的不通切换下一张，最后一张的时候移除UIimageView 根据imageData判断是哪一个图片，也可以为imageView增加tag 12345678NSData *data = UIImagePNGRepresentation(self.guidImageView.image); NSData *data1 = UIImagePNGRepresentation([UIImage imageNamed:@"home_bj_yd1"]); NSData *data2 = UIImagePNGRepresentation([UIImage imageNamed:@"home_bj_yd2"]); NSData *data3 = UIImagePNGRepresentation([UIImage imageNamed:@"home_bj_yd3"]);if ( [data isEqual:data1]) &#123; self.guidImageView.image=[UIImage imageNamed:@"home_bj_yd2"]; &#125; 18.APP开发注意的手机尺寸 启动页 尺寸 引导页尺寸 AppStore商店的介绍图尺寸 12345NSLog(@"name: %@", [[UIDevice currentDevice] name]);NSLog(@"systemName: %@", [[UIDevice currentDevice] systemName]);NSLog(@"systemVersion: %@", [[UIDevice currentDevice] systemVersion]);NSLog(@"model: %@", [[UIDevice currentDevice] model]);NSLog(@"localizedModel: %@", [[UIDevice currentDevice] localizedModel]); 19.点击顶部通知消息报错： 在点击事件中，如果我们不写completionHandler（）这个方法，可能会报一下的错误，希望大家注意下~ 1234Warning: UNUserNotificationCenter delegate received call to -userNotificationCenter:didReceiveNotificationResponse:withCompletionHandler: but the completion handler was never called.2017-01-16 15:00:36.045772 JYYinYongBao[1006:326459] Warning: UNUserNotificationCenter delegate received call to -userNotificationCenter:didReceiveNotificationResponse:withCompletionHandler: but the completion handler was never called. 20.Xcode 文件夹 文件夹拖拽注意点 黄色的文件夹，打包的时候，不会建立目录，主要保存程序文件 素材不允许重名 蓝色的文件夹，打包的时候，会建立目录，可以分目录的存储素材文件 素材可以重名 游戏的场景，background.png 【草地／雪地／高山／坟墓】 手机应用的皮肤，／白天／夜间模式 切记：不能把程序文件放在蓝色文件夹内，程序会暴漏` Bundle： 通常在第三方框架素材 可以按照黄色文件夹的方式拖拽，同时保留目录结构 可以避免文件重名]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>实用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题《一》]]></title>
    <url>%2F2015%2F08%2F21%2F2015b%2F%E9%9D%A2%E8%AF%95%E9%A2%981%2F</url>
    <content type="text"><![CDATA[文章来自转载上面的答案都比较“抽象”，下面是我面试iOS程序员的问题列表（私人珍藏），能准确答对一半以上的人非常少（其实这些问题真的不难）。。有兴趣的可以试试。。 什么是arc？（arc是为了解决什么问题诞生的？） 请解释以下keywords的区别： assign vs weak, block vs weak __block在arc和非arc下含义一样吗？ 使用atomic一定是线程安全的吗？ 描述一个你遇到过的retain cycle例子。(别撒谎，你肯定遇到过) +(void)load; +(void)initialize；有什么用处？ 为什么其他语言里叫函数调用， objective c里则是给对象发消息（或者谈下对runtime的理解） 什么是method swizzling? UIView和CALayer是啥关系？ 如何高性能的给UIImageView加个圆角？（不准说layer.cornerRadius!） 使用drawRect有什么影响？（这个可深可浅，你至少得用过。。） ASIHttpRequest或者SDWebImage里面给UIImageView加载图片的逻辑是什么样的？（把UIImageView放到UITableViewCell里面问更赞） 麻烦你设计个简单的图片内存缓存器（移除策略是一定要说的） 讲讲你用Instrument优化动画性能的经历吧（别问我什么是Instrument） loadView是干嘛用的？ viewWillLayoutSubView你总是知道的。。 GCD里面有哪几种Queue？你自己建立过串行queue吗？背后的线程模型是什么样的？ 用过coredata或者sqlite吗？读写是分线程的吗？遇到过死锁没？咋解决的？ http的post和get啥区别？（区别挺多的，麻烦多说点） 我知道你大学毕业过后就没接触过算法数据结构了，但是请你一定告诉我什么是Binary search tree? search的时间复杂度是多少？我很想知道！ 技术层面： 1、对面向对象的理解，不好也可以写程序，但是写不好大程序2、对内存的理解3、调试的能力4、调优的能力 产品层面： 1、对基本商业模式的了解2、对流行产品和产品流行趋势的了解3、对app store营销基础知识的了解4、对SNS的了 其他技能 1.通用编程技能，例如：一道小算法，数据结构的实现方式，网络，多线程。2.开发语言，例如：语言特性，重新实现语言提供的功能，是否深入研究过这门语言的某部分。3.开发平台，例如：该平台的内部消息，内存，线程等机制。4.工具，例如：调试技巧，是否熟练使用，代码管理工具，项目管理工具，效率工具。5.行业视角，例如：用什么，知道什么。6.其他能力，例如：网络上解决问题的能力，是否有持续学习的意识。 有经验的，1-6都会问到，刚毕业的，只要重点面1和6 你使用过Objective-C的运行时编程（Runtime Programming）么？如果使用过，你用它做了什么？你还能记得你所使用的相关的头文件或者某些方法的名称吗？ 你实现过多线程的Core Data么？NSPersistentStoreCoordinator，NSManagedObjectContext和NSManagedObject中的哪些需要在线程中创建或者传递？你是用什么样的策略来实现的？ Core开头的系列的内容。是否使用过CoreAnimation和CoreGraphics。UI框架和CA，CG框架的联系是什么？分别用CA和CG做过些什么动画或者图像上的内容。（有需要的话还可以涉及Quartz的一些内容） 是否使用过CoreText或者CoreImage等？如果使用过，请谈谈你使用CoreText或者CoreImage的体验。 NSNotification和KVO的区别和用法是什么？什么时候应该使用通知，什么时候应该使用KVO，它们的实现上有什么区别吗？如果用protocol和delegate（或者delegate的Array）来实现类似的功能可能吗？如果可能，会有什么潜在的问题？如果不能，为什么？（虽然protocol和delegate这种东西面试已经面烂了…） 你用过NSOperationQueue么？如果用过或者了解的话，你为什么要使用NSOperationQueue，实现了什么？请描述它和GCD的区别和类似的地方（提示：可以从两者的实现机制和适用范围来描述）。 既然提到GCD，那么问一下在使用GCD以及block时要注意些什么？它们两是一回事儿么？block在ARC中和传统的MRC中的行为和用法有没有什么区别，需要注意些什么？ 您是否做过异步的网络处理和通讯方面的工作？如果有，能具体介绍一些实现策略么？ 对于Objective-C，你认为它最大的优点和最大的不足是什么？对于不足之处，现在有没有可用的方法绕过这些不足来实现需求。如果可以的话，你有没有考虑或者实践过重新实现OC的一些功能，如果有，具体会如何做？ 你实现过一个框架或者库以供别人使用么？如果有，请谈一谈构建框架或者库时候的经验；如果没有，请设想和设计框架的public的API，并指出大概需要如何做、需要注意一些什么方面，来使别人容易地使用你的框架。 申请的空间的内存在哪个区？ new 申请的时候，申请的空间在内存的堆区，（程序动态分配的内存空间） 初始化的时候，如果实例变量是基本类型，此时给初始化的为0，如果是字符串，初始化为null， 实例变量又保存在什么地方？ 实例变量，存放在堆区，指针变量，对象名存放在栈区， 对象方法保存在什么地方？ 对象的方法存放在代码区 首先找到p对应的堆区空间，然后找到－isa指针，在找到指向的代码区，然后到该空间中找方法， 一个类可以创建多个对象。]]></content>
      <categories>
        <category>实用技术</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[viewController的生命周期]]></title>
    <url>%2F2015%2F03%2F23%2F2015b%2FviewController%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425UIViewController中的view显示步骤--------------------------------------------------------------------------------------------------------进入UIViewController时的情况:viewDidLoadviewWillLayoutSubviewsviewDidLayoutSubviewsviewWillAppearviewWillLayoutSubviewsviewDidLayoutSubviewsviewDidAppear切换了Controller后的情况(比如你在TabbarController中切换了):viewWillDisappearviewDidDisappear再次切换回来后的情况:viewWillLayoutSubviewsviewDidLayoutSubviewsviewWillAppearviewWillLayoutSubviewsviewDidLayoutSubviewsviewDidAppear退入到后台后的情况:无从后台进入程序时的情况:viewWillLayoutSubviewsviewDidLayoutSubviews]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>实用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apple Pay]]></title>
    <url>%2F2015%2F03%2F23%2F2015b%2FApple%20Pay%2F</url>
    <content type="text"><![CDATA[1.介绍： Apple Pay并不是独立的第三方支付服务，相比较支付宝和微信支付，他没有自己的账户，也不参与资金的流动， Apple Pay只是将原有的实体银行卡变成手机上“虚拟的银行卡”。Apple Pay依赖iPhone系统底层的整合,在便捷程度上,非第三方支付能比。和第三方的支付对比：一个是系统级的，一个是应用级的。 iOS 8 中第一次被介绍，支持到iOS9以上的系统 2配置证书： 需要有一个具有ApplePay服务的APPid.以及真机测试的证书和描述文件 创建或者编辑appID的支持Apple pay 编辑Merchant ID 从钥匙串中请求证书 在Xcode 中设置允许Apple pay 3. 在界面中设置pay button PKPaymentButton –我们需要添加一个按钮，进行支付代码的实现 切图可以拉伸，但是不可以变窄！ 这个按钮有三个样式：White; WhiteOutLine; Black 同样具有三个不同类型：Plain; Buy；SetUp 4.上代码 创建button 123456789101112131415#import &lt;PassKit/PassKit.h&gt;// Type : 类型// PKPaymentButtonTypePlain// PKPaymentButtonTypeBuy// PKPaymentButtonTypeSetUp // style : 样式// PKPaymentButtonStyleWhite// PKPaymentButtonStyleWhiteOutline// PKPaymentButtonStyleBlack //以上的样式和类型，大家可以更换下，运行后可以直接查看到效果。在这里就不在解释。 PKPaymentButton * payButton = [PKPaymentButton buttonWithType:PKPaymentButtonTypePlain style:PKPaymentButtonStyleWhiteOutline]; payButton.center = self.view.center; [payButton addTarget:self action:@selector(payAction:) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:payButton]; 开始支付 系统提供了API来判断当前设备是否支持Apple Pay支付的功能。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112 if([PKPaymentAuthorizationViewController canMakePayments])&#123; //设备支持支付 //PKPayment类来创建支付请求 PKPaymentRequest *request = [[PKPaymentRequest alloc] init]; //国家 //HK 香港 CN : 中国大陆 request.countryCode = @"CN"; //人民币 // HKD 港币 CNY : 人民币 USD : 美元 request.currencyCode = @"CNY";// 其他国家以及币种的缩写自行百度 ///由商家支持的支付网络 所支持的卡类型 //此属性限制支付卡，可以支付。 // PKPaymentNetworkAmex : 美国运通 // PKPaymentNetworkChinaUnionPay : 中国银联 // PKPaymentNetworkVisa : Visa卡 // PKPaymentNetworkMasterCard : 万事达信用卡 // PKPaymentNetworkDiscover // PKPaymentNetworkInterac // PKPaymentNetworkPrivateLabel // PKEncryptionSchemeECC_V2 request.supportedNetworks = @[PKPaymentNetworkAmex, PKPaymentNetworkChinaUnionPay, PKPaymentNetworkDiscover, PKPaymentNetworkInterac, PKPaymentNetworkMasterCard, PKPaymentNetworkPrivateLabel, PKPaymentNetworkVisa, PKEncryptionSchemeECC_V2]; // PKMerchantCapability3DS // 美国的一个卡 必须支持 // PKMerchantCapabilityEMV // 欧洲的卡 // PKMerchantCapabilityCredit //信用卡 // PKMerchantCapabilityDebit //借记卡 //商家的支付处理能力 //PKMerchantCapabilityEMV : 他的旗下有三大银行 ： 中国银联 Visa卡 万事达信用卡 //也就是说merchantCapabilities指的支付的银行卡的范围。 request.merchantCapabilities = PKMerchantCapabilityDebit | PKMerchantCapabilityCredit | PKMerchantCapabilityEMV; //merchantIdentifier 要和你在开发者中心生成的id保持一致 request.merchantIdentifier = @"merchant.com.lanou3g.hanshanhuApplePayTest"; //需要的配送信息和账单信息 request.requiredBillingAddressFields = PKAddressFieldAll; request.requiredShippingAddressFields = PKAddressFieldAll; //运输方式 NSDecimalNumber * shippingPrice = [NSDecimalNumber decimalNumberWithString:@"11.0"]; PKShippingMethod *method = [PKShippingMethod summaryItemWithLabel:@"快递公司" amount:shippingPrice]; method.detail = @"24小时送到！"; method.identifier = @"kuaidi"; request.shippingMethods = @[method]; request.shippingType = PKShippingTypeServicePickup; // 2.9 存储额外信息 // 使用applicationData属性来存储一些在你的应用中关于这次支付请求的唯一标识信息，比如一个购物车的标识符。在用户授权支付之后，这个属性的哈希值会出现在这次支付的token中。 request.applicationData = [@"商品ID:123456" dataUsingEncoding:NSUTF8StringEncoding]; //添加物品到支付页 //创建物品并显示，这个对象描述了一个物品和它的价格，数组最后的对象必须是总价格。 //使用PKPaymentSummaryItem来创建商品信息 PKPaymentSummaryItem *widget1 = [PKPaymentSummaryItem summaryItemWithLabel:@"商品1" amount:[NSDecimalNumber decimalNumberWithString:@"20.0"]]; PKPaymentSummaryItem *widget2 = [PKPaymentSummaryItem summaryItemWithLabel:@"商品2" amount:[NSDecimalNumber decimalNumberWithString:@"10.0"]]; PKPaymentSummaryItem *total = [PKPaymentSummaryItem summaryItemWithLabel:@"商品3" amount:[NSDecimalNumber decimalNumberWithString:@"25.0"]]; request.paymentSummaryItems = @[widget1, widget2, total]; // request.paymentSummaryItems = @[widget1]; //显示认证视图 PKPaymentAuthorizationViewController * paymentPane = [[PKPaymentAuthorizationViewController alloc] initWithPaymentRequest:request]; paymentPane.delegate = self; [self presentViewController:paymentPane animated:TRUE completion:nil]; &#125;else&#123; //设备不支持支付 NSLog(@"设备不支持支付"); &#125; ``` - 支付过程中会进行调用 `PKPaymentAuthorizationViewControllerDelegate` ``` swift //这个代理方法指的是支付过程中会进行调用 - (void)paymentAuthorizationViewController:(PKPaymentAuthorizationViewController *)controller didAuthorizePayment:(PKPayment *)payment completion:(void (^)(PKPaymentAuthorizationStatus status))completion &#123; //payment:代表的是一个支付对象， 支付相关的所有信息都在他的身上：1.token. 2.address //completion : 是一个回调的block ，block回调的参数，直接影响到界面结果的展示。 /*PKPaymentAuthorizationStatus 交易状态 PKPaymentAuthorizationStatusSuccess, // 成功交易 PKPaymentAuthorizationStatusFailure // 没有授权交易 PKPaymentAuthorizationStatusInvalidBillingPostalAddress // 拒绝账单地址 PKPaymentAuthorizationStatusInvalidShippingPostalAddress, // 拒绝收货地址 PKPaymentAuthorizationStatusInvalidShippingContact //提供的信息不够 PKPaymentAuthorizationStatusPINRequired // 交易需要指纹输入 PKPaymentAuthorizationStatusPINIncorrect // 输入不正确,重新输入. PKPaymentAuthorizationStatusPINLockout// 输入次数超出 */ PKPaymentToken * token = payment.token; NSLog(@"获取token---%@", token); //获取订单地址 NSString * address = payment.billingContact.postalAddress.city; NSLog(@"获取到地址： %@", address); NSLog(@"验证通过后, 需要开发者继续完成交易"); // 在这个位置， 我们开发人员需要把token值和商品的其他信息如：地址 id 这些 ， 上传到自己公司的服务器。然后公司的服务器和银行的商家接口进行接口的调用，并将接口调用返回的支付结果信息返回到这里。 //根据不同的支付结果状态，让block调用不同的交易状态； //比如说：服务器调用支付结果是成功的， 就让 completion(PKPaymentAuthorizationStatusSuccess); 如果失败 调用 completion(PKPaymentAuthorizationStatusFailure); //如： BOOL isSuccess = YES; if (isSuccess) &#123; completion(PKPaymentAuthorizationStatusSuccess); &#125;else &#123; completion(PKPaymentAuthorizationStatusFailure); &#125; &#125; 授权成功之后或者取消授权之后会调用这个代理方法 1234- (void)paymentAuthorizationViewControllerDidFinish:(PKPaymentAuthorizationViewController *)controller &#123;NSLog(@"取消或者交易完成");[self dismissViewControllerAnimated:YES completion:nil];&#125;]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>实用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[支付-微信支付（2）]]></title>
    <url>%2F2015%2F03%2F22%2F2015b%2F%E6%94%AF%E4%BB%98-%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1 微信支付2 ，参与后台接口： 123456789101112131415161718192021222324252627282930313233343536373839404142434445-(void)textWeixin&#123; // 1.拼接请求参数 JYUserInfomation *info=[JYUserInfomation allObjects].firstObject; if (info==nil|| !info.isLoged) &#123; return; &#125; WeakSelf(weakSelf); NSDictionary *dic = @&#123; @"person_id":info.person_id, @"orderId":self.listModel.id, @"token":info.appkey, @"version":AppVersion, &#125;; [LOHttpHelper lo_requestWithType:LO_HttpRequestTypeGet withPath:@"app/pay/weixinPay.htm?" params:dic successOrFail:^(NSDictionary *responseDic, NSError *error) &#123; if (!error) &#123; if ([responseDic[@"status"] integerValue]==1) &#123; NSLog(@"%@",responseDic); NSDictionary *dict=responseDic[@"data"]; NSMutableString *retcode = [dict objectForKey:@"retcode"]; if (retcode.intValue == 0)&#123; NSMutableString *stamp = [dict objectForKey:@"timestamp"]; //调起微信支付 PayReq* req = [[PayReq alloc] init]; req.partnerId = [dict objectForKey:@"partnerid"]; req.prepayId = [dict objectForKey:@"prepayid"]; req.nonceStr = [dict objectForKey:@"noncestr"]; req.timeStamp = stamp.intValue; req.package = [dict objectForKey:@"package"]; req.sign = [dict objectForKey:@"sign"]; [WXApi sendReq:req]; //日志输出 NSLog(@"appid=%@\npartid=%@\nprepayid=%@\nnoncestr=%@\ntimestamp=%ld\npackage=%@\nsign=%@",[dict objectForKey:@"appid"],req.partnerId,req.prepayId,req.nonceStr,(long)req.timeStamp,req.package,req.sign ); &#125; &#125;else&#123; [KVNProgress showErrorWithStatus:responseDic[@"msg"]]; &#125; &#125;else&#123; [KVNProgress showErrorWithStatus:@"请重新再试!"]; &#125; &#125;];&#125; 拼接参数，掉后台接口，接受后台参数： 根据返回的参数，调用微信SDK，进行支付：]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>实用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[支付-微信支付（1）]]></title>
    <url>%2F2015%2F03%2F21%2F2015b%2F%E6%94%AF%E4%BB%98-%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[微信支付 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758- (void)wechatPayClick&#123; NSMutableDictionary *dict = [NSMutableDictionary dictionary]; [dict setObject:WeChatAppID forKey:@"appid"]; [dict setObject:@"税务代理预缴税金" forKey:@"body"]; [dict setObject:WeChatMCH_ID forKey:@"mch_id"]; [dict setObject:[AppMethod getRandomString] forKey:@"nonce_str"]; [dict setObject:WeChatNOTIFY_URL forKey:@"notify_url"]; [dict setObject:@"ZLDD-201703070014" forKey:@"out_trade_no"]; [dict setObject:[AppMethod deviceIPAdress] forKey:@"spbill_create_ip"]; [dict setObject:@"1" forKey:@"total_fee"]; [dict setObject:@"APP" forKey:@"trade_type"]; NSDictionary *params = [AppMethod partnerSignOrder:dict]; NSString *postStr = [params XMLString]; NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"https://api.mch.weixin.qq.com/pay/unifiedorder"]]; [request setHTTPMethod:@"POST"]; [request addValue: @"text/html,text/plain,text/json" forHTTPHeaderField:@"Content-Type"]; [request setHTTPBody:[postStr dataUsingEncoding:NSUTF8StringEncoding]]; NSURLSession *requestSession = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]]; NSURLSessionDataTask *task = [requestSession dataTaskWithRequest:request completionHandler:^(NSData * _Nullable body , NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; NSLog(@"Response object: %@" , response); NSString *bodyString = [[NSString alloc] initWithData:body encoding:NSUTF8StringEncoding]; // NSDictionary *dic=[bodyString mj_JSONObject]; //打印应答中的body NSLog(@"Response body: %@" , body); NSDictionary *dic= [[XMLDictionaryParser sharedInstance] dictionaryWithData:body]; PayReq* req = [[PayReq alloc] init]; req.partnerId = WeChatMCH_ID; req.prepayId = [dic objectForKey:@"prepay_id"]; req.nonceStr = [dic objectForKey:@"nonce_str"]; req.timeStamp = [[NSString stringWithFormat:@"%.0f",[[NSDate date] timeIntervalSince1970]] intValue]; req.package = @"Sign=WXPay"; NSMutableDictionary *rdict = [NSMutableDictionary dictionary]; [rdict setObject:WeChatAppID forKey:@"appid"]; [rdict setObject:req.partnerId forKey:@"partnerid"]; [rdict setObject:req.prepayId forKey:@"prepayid"]; [rdict setObject:req.nonceStr forKey:@"noncestr"]; [rdict setObject:[NSString stringWithFormat:@"%u",(unsigned int)req.timeStamp] forKey:@"timestamp"]; [rdict setObject:req.package forKey:@"package"]; NSDictionary *result = [AppMethod partnerSignOrder:rdict]; req.sign = [result objectForKey:@"sign"]; [WXApi sendReq:req]; &#125;]; [task resume]; &#125; 拼接参数： 上传接口，获取预下单ID，打开微信，支付]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>实用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[支付-支付宝支付]]></title>
    <url>%2F2015%2F03%2F20%2F2015b%2F%E6%94%AF%E4%BB%98-%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98%2F</url>
    <content type="text"><![CDATA[1.支付宝支付，获取上传的参数加密参数等在后台处理，手机端拿到拼接好的sign，直接调取支付宝SDK： 123456789101112131415161718192021222324252627282930313233343536373839404142JYUserInfomation *info=[JYUserInfomation allObjects].firstObject;if (info==nil|| !info.isLoged) &#123; return;&#125;NSDictionary *dic=@&#123;@"person_id":info.person_id, @"orderId":self.listModel.id, @"token":info.appkey, @"version":AppVersion, &#125;;[LOHttpHelper lo_requestWithType:LO_HttpRequestTypeGet withPath:@"app/pay/getOrderInfo.htm?" params:dic successOrFail:^(NSDictionary *responseDic, NSError *error) &#123; if (!error) &#123; if ([responseDic[@"status"] integerValue]==1) &#123; NSLog(@"%@",responseDic); NSDictionary *data=responseDic[@"data"]; if ([data isKindOfClass:[NSNull class]]) &#123; return ; &#125; NSString *orderInfo=data[@"orderInfo"]; // NOTE: 调用支付结果开始支付 [[AlipaySDK defaultService] payOrder:orderInfo fromScheme:@"JYAliPaySDK" callback:^(NSDictionary *resultDic) &#123; NSLog(@"%@",resultDic); if ([[resultDic objectForKey:@"resultStatus"]intValue] == 9000) &#123; &#125; else if ([[resultDic objectForKey:@"resultStatus"]intValue] == 8000) &#123; //处理中 &#125; else &#123; &#125; &#125;]; &#125;else&#123; [KVNProgress showErrorWithStatus:responseDic[@"msg"]]; &#125; &#125;else&#123; [KVNProgress showErrorWithStatus:@"请重新再试!"]; &#125;&#125;]; 调取后台接口，获取sign 调取支付宝SDK]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>实用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取音视频文件AVMetadata数据]]></title>
    <url>%2F2015%2F03%2F19%2F2015b%2F%E8%8E%B7%E5%8F%96%E9%9F%B3%E8%A7%86%E9%A2%91%E6%96%87%E4%BB%B6AVMetadata%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[做音乐播放器应用有时候需要获取音乐文件的一些数据信息,比如该音乐文件中的封面图片,艺人名,专辑名等,如何获取呢?本人抛砖引玉,写一个获取封面图片的类供大家参考. 创建一个工具类 1234567891011#import &lt;AVFoundation/AVFoundation.h&gt;#warning 需要引入AVFoundation.framework@interface AVMetadataInfo : NSObject/**获取音视频文件的Metadata信息(可以获取到mp3以及m4a的相关信息)*AVMetadataCommonKeyArtwork这个参数是可以换的,换不同的参数可以取得不同的值*[注意]此方法中用到了信号量将异步操作转换成了同步操作,尽量在主线程中使用@param fileURL 文件的URL地址@return 一个包含了相关内容的字典*/+ (NSDictionary *)dataInfoFromFileURL:(NSURL *)fileURL; 实现方法 12345678910111213141516171819202122232425262728293031323334+ (NSDictionary *)dataInfoFromFileURL:(NSURL *)fileURL&#123; // 创建字典 NSMutableDictionary *dic = [NSMutableDictionary dictionary]; // 创建信号量(将异步变成同步) dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); AVAsset *asset = [AVURLAsset URLAssetWithURL:fileURL options:nil]; [asset loadValuesAsynchronouslyForKeys:@[@"commonMetadata"] completionHandler:^&#123; // 发送信号量 dispatch_semaphore_signal(semaphore); &#125;]; // 无限等待 dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); // 获取数据 NSArray *artworks = [AVMetadataItem metadataItemsFromArray:asset.commonMetadata withKey:AVMetadataCommonKeyArtwork keySpace:AVMetadataKeySpaceCommon]; for (AVMetadataItem *item in artworks)&#123; if ([item.keySpace isEqualToString:AVMetadataKeySpaceID3])&#123; NSDictionary *dict = [item.value copyWithZone:nil]; // 获取图片 UIImage *image = [UIImage imageWithData:[dict objectForKey:@"data"]]; [dic setObject:image forKey:@"Artwork"]; &#125; if ([item.keySpace isEqualToString:AVMetadataKeySpaceiTunes])&#123; // 获取图片 UIImage *image = [UIImage imageWithData:[item.value copyWithZone:nil]]; [dic setObject:image forKey:@"Artwork"]; &#125; &#125; return [NSDictionary dictionaryWithDictionary:dic];&#125;]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>实用</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIsearchViewControl]]></title>
    <url>%2F2015%2F03%2F18%2F2015b%2FUIsearchViewControl%2F</url>
    <content type="text"><![CDATA[创建UItableViewVC UISearchController alloc init ResultsController 一个tableVC，搜索到的数据源呈现在tableVC 继承UITableViewController .h文件 12@interface TestTableViewController : UITableViewController@end 继承UITableViewController .m文件 12345678910111213141516171819@interface TestTableViewController ()&lt;UISearchResultsUpdating, UISearchBarDelegate&gt;@property (nonatomic, strong) UISearchController *searchController;@property (nonatomic, strong) NSMutableArray *searchResults; // Filtered search results@property (nonatomic, strong) NSArray *products;@end@implementation TestTableViewController- (void)viewDidLoad&#123; [super viewDidLoad]; self.title = @"全部品牌"; self.products = [Product allProducts]; TestResultTableViewController *result = [[TestResultTableViewController alloc] init]; result.view.frame = CGRectMake(0, 0, [UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height); self.searchController = [[UISearchController alloc] initWithSearchResultsController:result]; self.searchController.searchResultsUpdater = self; self.searchController.searchBar.placeholder = @"搜索品牌"; self.searchController.searchBar.frame = CGRectMake(self.searchController.searchBar.frame.origin.x, self.searchController.searchBar.frame.origin.y, self.searchController.searchBar.frame.size.width, 44.0); self.tableView.tableHeaderView = self.searchController.searchBar; self.definesPresentationContext = YES;&#125; UISearchResultsUpdating UISearchBarDelegate 的代理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#pragma mark - UISearchResultsUpdating- (void)updateSearchResultsForSearchController:(UISearchController *)searchController&#123; NSString *searchString = [self.searchController.searchBar text]; NSString *scope = nil; NSInteger selectedScopeButtonIndex = [self.searchController.searchBar selectedScopeButtonIndex]; if (selectedScopeButtonIndex &gt; 0) &#123; scope = [[Product deviceTypeNames] objectAtIndex:(selectedScopeButtonIndex - 1)]; &#125; [self updateFilteredContentForProductName:searchString type:scope]; if (self.searchController.searchResultsController) &#123; TestResultTableViewController *vc = (TestResultTableViewController *)self.searchController.searchResultsController; vc.searchResults = self.searchResults; [vc.tableView reloadData]; &#125;&#125;#pragma mark - Content Filtering- (void)updateFilteredContentForProductName:(NSString *)productName type:(NSString *)typeName&#123; if ((productName == nil) || [productName length] == 0) &#123; if (typeName == nil) &#123; self.searchResults = [self.products mutableCopy]; &#125; else &#123; NSMutableArray *searchResults = [[NSMutableArray alloc] init]; for (Product *product in self.products) &#123; if ([product.type isEqualToString:typeName]) &#123; [searchResults addObject:product]; &#125; &#125; self.searchResults = searchResults; &#125; return; &#125; [self.searchResults removeAllObjects]; for (Product *product in self.products) &#123; if ((typeName == nil) || [product.type isEqualToString:typeName]) &#123; NSUInteger searchOptions = NSCaseInsensitiveSearch | NSDiacriticInsensitiveSearch; NSRange productNameRange = NSMakeRange(0, product.name.length); NSRange foundRange = [product.name rangeOfString:productName options:searchOptions range:productNameRange]; if (foundRange.length &gt; 0) &#123; [self.searchResults addObject:product]; &#125; &#125; &#125;&#125;#pragma mark - UISearchBarDelegate- (void)searchBar:(UISearchBar *)searchBar selectedScopeButtonIndexDidChange:(NSInteger)selectedScope&#123; [self updateSearchResultsForSearchController:self.searchController];&#125; 代码]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>实用</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MJRefreshGifHeader设置刷新动画]]></title>
    <url>%2F2015%2F03%2F17%2F2015b%2FMJRefreshGifHeader%E8%AE%BE%E7%BD%AE%E5%88%B7%E6%96%B0%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[设置MJRefreshGifHeader 的子类，重写prepare 方法。 interface12@interface CLRefreshHeaderCLRefreshHeader : MJRefreshGifHeaderMJRefreshGifHeader@end prepare() 12345678910111213141516171819-(void)prepare&#123; [super prepare]; // 设置普通状态的动画图片 NSMutableArray *idleImages = [NSMutableArray array]; for (NSUInteger i = 1; i&lt;=60; i++) &#123; UIImage *image = [UIImage imageNamed:@"icon_refresh_1"]; [idleImages addObject:image]; &#125; [self setImages:idleImages forState:MJRefreshStateIdle]; // 设置即将刷新状态的动画图片（一松开就会刷新的状态） NSMutableArray *refreshingImages = [NSMutableArray array]; for (NSUInteger i = 1; i&lt;=7; i++) &#123; UIImage *image = [UIImage imageNamed:[NSString stringWithFormat:@"icon_refresh_%zd", i]]; [refreshingImages addObject:image]; &#125; [self setImages:refreshingImages forState:MJRefreshStatePulling]; // 设置正在刷新状态的动画图片 [self setImages:refreshingImages forState:MJRefreshStateRefreshing];&#125; 设置tableView的header 刷新方法 1self.mTableView.header = [CLRefreshHeader headerWithRefreshingTarget:self refreshingAction:@selector(loadNewData)];]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>实用</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CAShapeLayer]]></title>
    <url>%2F2015%2F03%2F16%2F2015b%2FCAShapeLayer%2F</url>
    <content type="text"><![CDATA[CAShapeLayer 和 CALayer 的区别 普通CALayer在被初始化时是需要给一个frame值的,这个frame值一般都与给定view的bounds值一致,它本身是有形状的,而且是矩形. CAShapeLayer在初始化时也需要给一个frame值,但是,它本身没有形状,它的形状来源于你给定的一个path,然后它去取CGPath值,它与CALayer有着很大的区别 使用UIBezierPath绘制不规则曲线1 12345678910111213141516// 获取pathUIBezierPath *aPath = [UIBezierPath bezierPath];// 设定起始点[aPath moveToPoint:CGPointMake(0.0f, 0.0f)];// 添加一个不规则点[aPath addCurveToPoint:CGPointMake(100.f, 100.f) controlPoint1:CGPointMake(50.f, 0.f) // 开始点 controlPoint2:CGPointMake(0.f, 50.f)]; // 结束点// 添加一个点[aPath addLineToPoint:CGPointMake(0.0f, 100.f)];// 闭合path[aPath closePath]; 使用UIBezierPath绘制不规则曲线2 123456789101112131415// 获取pathUIBezierPath *aPath = [UIBezierPath bezierPath];// 设定起始点[aPath moveToPoint:CGPointMake(0.0f, 0.0f)];// 添加一个不规则点[aPath addQuadCurveToPoint:CGPointMake(100.f, 100.f) controlPoint:CGPointMake(0.f, 90.f)]; // 控制点// 添加一个点[aPath addLineToPoint:CGPointMake(0.0f, 100.f)];// 闭合path[aPath closePath];]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>实用</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Predicate]]></title>
    <url>%2F2015%2F03%2F15%2F2015b%2FPredicate%2F</url>
    <content type="text"><![CDATA[谓词： NSPredicate 1.比较操作 2.字符串常规操作 3.范围 4.通配符 5.逻辑运算符 6.正则表达式 判断是不是字母，判断是不是数字，判断是是不是字母和数字 123456789101112131415161718// If my string contains ony letters- (BOOL)containsOnlyLetters&#123; NSCharacterSet *letterCharacterset = [[NSCharacterSet letterCharacterSet] invertedSet]; return ([self rangeOfCharacterFromSet:letterCharacterset].location == NSNotFound);&#125;// If my string contains only numbers- (BOOL)containsOnlyNumbers&#123; NSCharacterSet *numbersCharacterSet = [[NSCharacterSet characterSetWithCharactersInString:@"0123456789"] invertedSet]; return ([self rangeOfCharacterFromSet:numbersCharacterSet].location == NSNotFound);&#125;// If my string contains letters and numbers- (BOOL)containsOnlyNumbersAndLetters&#123; NSCharacterSet *numAndLetterCharSet = [[NSCharacterSet alphanumericCharacterSet] invertedSet]; return ([self rangeOfCharacterFromSet:numAndLetterCharSet].location == NSNotFound);&#125;]]></content>
      <categories>
        <category>实用技术</category>
      </categories>
      <tags>
        <tag>实用</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARC下的block导致的循环引用问题解析]]></title>
    <url>%2F2015%2F03%2F14%2F2015b%2FARC%E4%B8%8B%E7%9A%84block%E5%AF%BC%E8%87%B4%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1.在ARC下面使用block,无论怎样,你都需要注意这几点: 外部对象进入block,请使用__weak修饰后再进入到block中 不要在block中初始化对象,请在block的外面初始化对象后再进入到block中去 无论该block是不是copy的,请都当做copy的block来处理 传入到堆区block中的对象会被强引用 2.Block的类型与内存管理 据Block在内存中的位置分为三种类型NSGlobalBlock，NSStackBlock, NSMallocBlock。 NSGlobalBlock：类似函数，位于text段； NSStackBlock：位于栈内存，函数返回后Block将无效； NSMallocBlock：位于堆内存。 此处我们可以得知,在处理对象时,block会malloc的. :这种block会导致_model对象泄露吗? 问:方法中的block是怎么回事呢? :MRC中的__block与ARC中的__weak有啥联系? 在MRC中, __block 可以让一个变量在 block 中进行修改而不会被这个 block retain. 在ARC中, __weak 才能让一个变量在 block 中不被这个block强引用. __block是在MRC中使用的. __weak是在ARC中使用的.]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>实用</tag>
      </tags>
  </entry>
</search>
